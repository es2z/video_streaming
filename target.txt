```.gitignore
# Byte-code files
*.pyc
__pycache__/

# Virtual environment
venv/
env/
.venv/
.git/

# Database files
*.sqlite3

# Media and static files (if served locally for development)
media/
static/

# Environment-specific configuration (e.g., sensitive settings)
.env
local_settings.py

# Editor and IDE specific files
.vscode/
.idea/
*.swp
*~

# Test coverage files
.coverage
.coverage.*

# Django specific
migrations/00*.py # Ignore initial migration files if you're using a specific migration workflow
```

```backend/backend/__init__.py
"""
Backend Django project package.
"""
```

```backend/backend/asgi.py
"""
ASGI config for backend project.
It exposes the ASGI callable as a module-level variable named ``application``.
"""

import os
from django.core.asgi import get_asgi_application
from channels.routing import ProtocolTypeRouter, URLRouter
from channels.auth import AuthMiddlewareStack

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'backend.settings')

# Django ASGI application
django_asgi_app = get_asgi_application()

# Import routing after Django setup
from videos import routing

application = ProtocolTypeRouter({
    "http": django_asgi_app,
    "websocket": AuthMiddlewareStack(
        URLRouter(
            routing.websocket_urlpatterns
        )
    ),
})
```

```backend/backend/celery.py
"""
Celery configuration for backend project.
"""

import os
from celery import Celery
from celery.schedules import crontab

# Djangoの設定モジュールを指定
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'backend.settings')

# Celeryアプリケーションインスタンスを作成
app = Celery('backend')

# Djangoの設定ファイルから設定を読み込み
app.config_from_object('django.conf:settings', namespace='CELERY')

# 登録されたDjangoアプリケーションからタスクを自動検出
app.autodiscover_tasks()

# 定期タスクの設定
app.conf.beat_schedule = {
    # 6時間ごとにファイルスキャンを実行
    'periodic-file-scan': {
        'task': 'videos.tasks.periodic_scan_task',
        'schedule': crontab(minute=0, hour='*/6'),  # 0:00, 6:00, 12:00, 18:00に実行
    },
    # 毎日午前3時に古いスキャン履歴を削除
    'cleanup-scan-history': {
        'task': 'videos.tasks.cleanup_old_scan_history',
        'schedule': crontab(hour=3, minute=0),
    },
    # 毎日午前4時に欠けているサムネイルを生成
    'generate-missing-thumbnails': {
        'task': 'videos.tasks.generate_missing_thumbnails',
        'schedule': crontab(hour=4, minute=0),
    },
}

@app.task(bind=True)
def debug_task(self):
    """デバッグ用タスク"""
    print(f'Request: {self.request!r}')
```

```backend/backend/settings.py
"""
Django settings for video streaming backend project.
"""

from pathlib import Path
import os
from datetime import timedelta

# Build paths inside the project
BASE_DIR = Path(__file__).resolve().parent.parent

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = "django-insecure-your-secret-key-change-this-in-production-@#$%^&*()"

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

ALLOWED_HOSTS = ["localhost", "127.0.0.1", "0.0.0.0", "*"]

# Application definition
INSTALLED_APPS = [
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",
    "rest_framework",
    "corsheaders",
    "channels",
    "videos",
    "django_cleanup.apps.CleanupConfig",
]

MIDDLEWARE = [
    "django.middleware.security.SecurityMiddleware",
    "django.contrib.sessions.middleware.SessionMiddleware",
    "corsheaders.middleware.CorsMiddleware",
    "django.middleware.common.CommonMiddleware",
    "django.middleware.csrf.CsrfViewMiddleware",
    "django.contrib.auth.middleware.AuthenticationMiddleware",
    "django.contrib.messages.middleware.MessageMiddleware",
    "django.middleware.clickjacking.XFrameOptionsMiddleware",
]

ROOT_URLCONF = "backend.urls"

TEMPLATES = [
    {
        "BACKEND": "django.template.backends.django.DjangoTemplates",
        "DIRS": [],
        "APP_DIRS": True,
        "OPTIONS": {
            "context_processors": [
                "django.template.context_processors.debug",
                "django.template.context_processors.request",
                "django.contrib.auth.context_processors.auth",
                "django.contrib.messages.context_processors.messages",
            ],
        },
    },
]

# ASGI application for Daphne
ASGI_APPLICATION = "backend.asgi.application"

# Database configuration for MySQL
DATABASES = {
    "default": {
        "ENGINE": "django.db.backends.mysql",
        "NAME": "video_streaming_db",
        "USER": "video_user",
        "PASSWORD": "video_pass_2024",
        "HOST": "localhost",
        "PORT": "3306",
        "OPTIONS": {
            "charset": "utf8mb4",
            "init_command": "SET sql_mode='STRICT_TRANS_TABLES'",
        },
    }
}

# Password validation
AUTH_PASSWORD_VALIDATORS = [
    {
        "NAME": "django.contrib.auth.password_validation.UserAttributeSimilarityValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.MinimumLengthValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.CommonPasswordValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.NumericPasswordValidator",
    },
]

# Internationalization
LANGUAGE_CODE = "ja-JP"
TIME_ZONE = "Asia/Tokyo"
USE_I18N = True
USE_TZ = True

# Static files (CSS, JavaScript, Images)
STATIC_URL = "/static/"
STATIC_ROOT = os.path.join(BASE_DIR, "staticfiles")

# Media files configuration
MEDIA_URL = "/media/"
MEDIA_ROOT = os.path.join(BASE_DIR.parent, "media")

# Video and GIF directories
VIDEO_DIR = os.path.join(MEDIA_ROOT, "videos")
GIF_DIR = os.path.join(MEDIA_ROOT, "gifs")

# Default primary key field type
DEFAULT_AUTO_FIELD = "django.db.models.BigAutoField"

# REST Framework configuration
REST_FRAMEWORK = {
    "DEFAULT_PERMISSION_CLASSES": [
        "rest_framework.permissions.AllowAny",
    ],
    "DEFAULT_AUTHENTICATION_CLASSES": [],
    "DEFAULT_PAGINATION_CLASS": "rest_framework.pagination.PageNumberPagination",
    "PAGE_SIZE": 100,
    "DEFAULT_RENDERER_CLASSES": [
        "rest_framework.renderers.JSONRenderer",
    ],
}

# CORS settings
CORS_ALLOW_ALL_ORIGINS = True
CORS_ALLOW_CREDENTIALS = True

# Celery Configuration (for background tasks)
CELERY_BROKER_URL = "redis://localhost:6379/0"
CELERY_RESULT_BACKEND = "redis://localhost:6379/0"
CELERY_ACCEPT_CONTENT = ["json"]
CELERY_TASK_SERIALIZER = "json"
CELERY_RESULT_SERIALIZER = "json"
CELERY_TIMEZONE = TIME_ZONE

# File scan settings
FILE_SCAN_INTERVAL = 6 * 60 * 60  # 6 hours in seconds

# FFmpeg settings
FFMPEG_BINARY = "ffmpeg"  # Assumes ffmpeg is in PATH

# Logging configuration
LOGGING = {
    "version": 1,
    "disable_existing_loggers": False,
    "formatters": {
        "verbose": {
            "format": "{levelname} {asctime} {module} {message}",
            "style": "{",
        },
    },
    "handlers": {
        "file": {
            "level": "INFO",
            "class": "logging.FileHandler",
            "filename": os.path.join(BASE_DIR.parent, "logs", "django.log"),
            "formatter": "verbose",
        },
        "console": {
            "level": "INFO",
            "class": "logging.StreamHandler",
            "formatter": "verbose",
        },
    },
    "root": {
        "handlers": ["console", "file"],
        "level": "INFO",
    },
    "loggers": {
        "django": {
            "handlers": ["console", "file"],
            "level": "INFO",
            "propagate": False,
        },
        "videos": {
            "handlers": ["console", "file"],
            "level": "DEBUG",
            "propagate": False,
        },
    },
}
# WebP サムネイル保存先（例：<プロジェクト>/media/webp）
WEBP_DIR = os.path.join(MEDIA_ROOT, 'webp')

# サムネイルの既定拡張子（将来切替用）
THUMBNAIL_EXT = 'webp'
```

```backend/backend/urls.py
"""
URL configuration for backend project.
"""

from django.contrib import admin
from django.urls import path, include
from django.conf import settings
from django.conf.urls.static import static

urlpatterns = [
    path('admin/', admin.site.urls),
    path('api/', include('videos.urls')),
]

# Serve media files in development
if settings.DEBUG:
    urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)
    urlpatterns += static(settings.STATIC_URL, document_root=settings.STATIC_ROOT)
```

```backend/backend/wsgi.py
"""
WSGI config for backend project.

It exposes the WSGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.0/howto/deployment/wsgi/
"""

import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'backend.settings')

application = get_wsgi_application()
```

```backend/manage.py
#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""
import os
import sys


def main():
    """Run administrative tasks."""
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'backend.settings')
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)


if __name__ == '__main__':
    main()
```

```backend/videos/__init__.py
"""
Videos application package.
"""

default_app_config = 'videos.apps.VideosConfig'
```

```backend/videos/admin.py
"""
Django admin configuration for videos app.
"""

from django.contrib import admin
from django.utils.html import format_html
from .models import File, Folder, Tag, Group, ScanHistory


@admin.register(File)
class FileAdmin(admin.ModelAdmin):
    list_display = ['file_name', 'file_size_display', 'duration_display', 'delete_flag', 'duplicate_flag', 'created_at']
    list_filter = ['delete_flag', 'duplicate_flag', 'created_at', 'folders']
    search_fields = ['file_name', 'md5_hash']
    filter_horizontal = ['folders', 'tags']
    readonly_fields = ['file_path', 'md5_hash', 'file_size', 'video_duration', 'width', 'height', 'fps', 'codec', 'bitrate', 'created_at', 'updated_at']
    
    fieldsets = (
        ('基本情報', {
            'fields': ('file_name', 'file_path', 'file_size', 'md5_hash')
        }),
        ('動画情報', {
            'fields': ('video_duration', 'width', 'height', 'fps', 'codec', 'bitrate')
        }),
        ('分類', {
            'fields': ('folders', 'tags')
        }),
        ('フラグ', {
            'fields': ('delete_flag', 'duplicate_flag')
        }),
        ('サムネイル', {
            'fields': ('thumbnail_file_path',)
        }),
        ('メタデータ', {
            'fields': ('metadata',),
            'classes': ('collapse',)
        }),
        ('タイムスタンプ', {
            'fields': ('created_at', 'updated_at', 'last_accessed')
        })
    )
    
    def file_size_display(self, obj):
        """ファイルサイズを人間が読みやすい形式で表示"""
        size = obj.file_size
        for unit in ['B', 'KB', 'MB', 'GB', 'TB']:
            if size < 1024.0:
                return f"{size:.1f} {unit}"
            size /= 1024.0
        return f"{size:.1f} PB"
    file_size_display.short_description = 'ファイルサイズ'
    
    def duration_display(self, obj):
        """動画の長さを時:分:秒形式で表示"""
        if obj.video_duration:
            hours = int(obj.video_duration // 3600)
            minutes = int((obj.video_duration % 3600) // 60)
            seconds = int(obj.video_duration % 60)
            if hours > 0:
                return f"{hours}:{minutes:02d}:{seconds:02d}"
            else:
                return f"{minutes}:{seconds:02d}"
        return "-"
    duration_display.short_description = '動画の長さ'
    
    actions = ['mark_as_deleted', 'restore_files', 'mark_as_duplicate']
    
    def mark_as_deleted(self, request, queryset):
        """選択したファイルに削除フラグを設定"""
        updated = queryset.update(delete_flag=True)
        self.message_user(request, f"{updated}個のファイルに削除フラグを設定しました。")
    mark_as_deleted.short_description = "削除フラグを設定"
    
    def restore_files(self, request, queryset):
        """選択したファイルの削除フラグを解除"""
        updated = queryset.update(delete_flag=False)
        self.message_user(request, f"{updated}個のファイルの削除フラグを解除しました。")
    restore_files.short_description = "削除フラグを解除"
    
    def mark_as_duplicate(self, request, queryset):
        """選択したファイルに重複フラグを設定"""
        updated = queryset.update(duplicate_flag=True)
        self.message_user(request, f"{updated}個のファイルに重複フラグを設定しました。")
    mark_as_duplicate.short_description = "重複フラグを設定"


@admin.register(Folder)
class FolderAdmin(admin.ModelAdmin):
    list_display = ['folder_name', 'parent', 'files_count', 'children_count', 'created_at']
    list_filter = ['created_at', 'parent']
    search_fields = ['folder_name']
    raw_id_fields = ['parent']
    
    def files_count(self, obj):
        """フォルダ内のファイル数"""
        return obj.files.count()
    files_count.short_description = 'ファイル数'
    
    def children_count(self, obj):
        """子フォルダ数"""
        return obj.children.count()
    children_count.short_description = '子フォルダ数'


@admin.register(Tag)
class TagAdmin(admin.ModelAdmin):
    list_display = ['tag_name', 'usage_count', 'groups_display', 'created_at']
    list_filter = ['groups', 'created_at']
    search_fields = ['tag_name']
    filter_horizontal = ['groups']
    readonly_fields = ['usage_count', 'created_at', 'updated_at']
    
    def groups_display(self, obj):
        """所属グループを表示"""
        groups = obj.groups.all()
        if groups:
            return ", ".join([g.name for g in groups])
        return "-"
    groups_display.short_description = '所属グループ'


@admin.register(Group)
class GroupAdmin(admin.ModelAdmin):
    list_display = ['name', 'tags_count', 'created_at']
    search_fields = ['name']
    readonly_fields = ['created_at', 'updated_at']
    
    def tags_count(self, obj):
        """グループ内のタグ数"""
        return obj.tags.count()
    tags_count.short_description = 'タグ数'


@admin.register(ScanHistory)
class ScanHistoryAdmin(admin.ModelAdmin):
    list_display = ['started_at', 'status_display', 'files_scanned', 'files_added', 'duplicates_found', 'duration_display']
    list_filter = ['status', 'started_at']
    readonly_fields = ['started_at', 'completed_at', 'status', 'files_scanned', 'files_added', 'files_updated', 'duplicates_found', 'errors']
    
    def status_display(self, obj):
        """ステータスを色付きで表示"""
        colors = {
            'running': 'orange',
            'completed': 'green',
            'failed': 'red'
        }
        color = colors.get(obj.status, 'black')
        return format_html(
            '<span style="color: {};">{}</span>',
            color,
            obj.get_status_display()
        )
    status_display.short_description = 'ステータス'
    
    def duration_display(self, obj):
        """実行時間を表示"""
        if obj.completed_at and obj.started_at:
            delta = obj.completed_at - obj.started_at
            total_seconds = int(delta.total_seconds())
            hours = total_seconds // 3600
            minutes = (total_seconds % 3600) // 60
            seconds = total_seconds % 60
            if hours > 0:
                return f"{hours}時間{minutes}分{seconds}秒"
            elif minutes > 0:
                return f"{minutes}分{seconds}秒"
            else:
                return f"{seconds}秒"
        elif obj.status == 'running':
            return "実行中..."
        return "-"
    duration_display.short_description = '実行時間'
    
    def has_add_permission(self, request):
        """手動でスキャン履歴を追加することを防ぐ"""
        return False
```

```backend/videos/apps.py
# backend/videos/apps.py
import os
import sys
import threading
import logging
import importlib
from typing import Optional, Tuple, Set

from django.apps import AppConfig, apps as django_apps
from django.db import connection
from django.db.models.signals import post_migrate

logger = logging.getLogger(__name__)


class VideosConfig(AppConfig):
    name = 'videos'
    verbose_name = 'Videos'

    def __init__(self, app_name, app_module):
        super().__init__(app_name, app_module)
        # スキャン開始済みフラグ（重複起動防止）
        self._scans_started = False
        # post_migrate ハンドラ登録用フラグ
        self._post_migrate_connected = False

    # ------------------------------------------------------------------
    # DB 準備が整っているかを判定するユーティリティ
    # モデルの _meta.db_table を動的に参照することで、
    # db_table 名を変更しても追従できるようにする。
    # ------------------------------------------------------------------
    def _db_ready(self) -> bool:
        try:
            existing_tables: Set[str] = set(connection.introspection.table_names())
        except Exception as e:
            logger.debug("Failed to introspect DB tables: %s", e)
            return False

        required_model_names = ['ScanHistory', 'File', 'Folder', 'Tag', 'Group']
        required_tables = set()
        for mname in required_model_names:
            try:
                model = django_apps.get_model('videos', mname)
            except LookupError:
                # モデルがロードされていない（アプリ未ロードなど）
                logger.debug("Model videos.%s not available yet", mname)
                return False
            required_tables.add(model._meta.db_table)

        missing = required_tables - existing_tables
        if missing:
            logger.debug("DB missing required tables: %s", missing)
            return False
        return True

    # ------------------------------------------------------------------
    # スキャン関数（initial_scan, periodic_scan）を探して返す
    # 探索候補モジュールはプロジェクト差で異なるため複数候補を見る
    # ------------------------------------------------------------------
    def _find_scan_functions(self) -> Tuple[Optional[callable], Optional[callable]]:
        candidates = [
            'videos.scanner',
            'videos.tasks',
            'videos.scan',
            'videos.utils',
            'videos.management.scan',  # まれに管理コマンド配下
        ]
        initial_scan = None
        periodic_scan = None
        for modname in candidates:
            try:
                mod = importlib.import_module(modname)
            except Exception:
                continue
            # 明示的に関数名を探す
            if hasattr(mod, 'initial_scan'):
                initial_scan = getattr(mod, 'initial_scan')
            if hasattr(mod, 'periodic_scan'):
                periodic_scan = getattr(mod, 'periodic_scan')
            # もしモジュールがクラス内実装であれば属性名違いの可能性もあるが
            # 最低限上記2つが見つかれば十分。
            if initial_scan or periodic_scan:
                logger.debug("Found scan module %s (initial=%s periodic=%s)", modname, bool(initial_scan), bool(periodic_scan))
                break
        return initial_scan, periodic_scan

    # ------------------------------------------------------------------
    # 実際にスキャンスレッドを起動する。重複起動しないようにチェックする。
    # ------------------------------------------------------------------
    def _start_scans(self):
        if self._scans_started:
            logger.debug("Scans already started; skip.")
            return

        initial_scan, periodic_scan = self._find_scan_functions()

        if not initial_scan and not periodic_scan:
            logger.warning("No scan entrypoints found (initial_scan / periodic_scan). Skipping automatic scan startup.")
            return

        # 起動用ラッパー。例外が出てもスレッドが潰れないようにする。
        def _safe_run(func, *args, **kwargs):
            try:
                logger.info("Starting scan function: %s", getattr(func, '__name__', repr(func)))
                func(*args, **kwargs)
            except Exception:
                logger.exception("Exception occurred while running scan function %s", getattr(func, '__name__', repr(func)))

        # initial_scan は一度だけ起動（バックグラウンド）
        if initial_scan:
            t = threading.Thread(target=_safe_run, args=(initial_scan,), daemon=True, name='videos.initial_scan')
            t.start()
            logger.info("Initial scan thread started.")

        # periodic_scan はデーモンスレッドで起動（実装側でループ/スリープ管理する想定）
        if periodic_scan:
            t2 = threading.Thread(target=_safe_run, args=(periodic_scan,), daemon=True, name='videos.periodic_scan')
            t2.start()
            logger.info("Periodic scan thread started.")

        self._scans_started = True

    # ------------------------------------------------------------------
    # post_migrate シグナルハンドラ（マイグレーション完了後に呼ばれる）
    # DB が未準備で起動時にスキップされた場合、ここで再チェックしてスキャンを開始する
    # ------------------------------------------------------------------
    def _on_post_migrate(self, **kwargs):
        # 開発サーバの再読み込み子プロセス対策
        if os.environ.get('RUN_MAIN') != 'true':
            return
        # 既に起動済みなら無視
        if self._scans_started:
            return
        # テーブルが用意できているか再チェック
        if self._db_ready():
            logger.info("DB ready after migrations; starting scans via post_migrate handler.")
            self._start_scans()
        else:
            logger.debug("post_migrate: DB still not ready; skipping start.")

    # ------------------------------------------------------------------
    # AppConfig.ready(): Django 起動時に呼ばれる
    # - RUN_MAIN チェックで子プロセスを除外
    # - runserver からの起動時のみ自動スキャンを検討
    # - DB が未準備なら post_migrate で開始するよう接続
    # ------------------------------------------------------------------
    def ready(self):
        # 開発サーバのリロード子プロセスでは実行しない（重複防止）
        if os.environ.get('RUN_MAIN') != 'true':
            return

        # まず runserver / daphne などサーバ起動コマンドかどうかを判定
        is_server = any(k in ' '.join(sys.argv) for k in ('runserver', 'daphne', 'gunicorn', 'uvicorn'))

        if not is_server:
            # サーバ以外（manage.py migrate 等）のときはスキャンを開始しない
            logger.debug("Not a server process (sys.argv: %s). Skipping automatic scan startup.", sys.argv)
            return

        # DB の準備状況に応じて即時かシグナル待ちかを決める
        try:
            if self._db_ready():
                logger.info("Database ready at startup; starting initial and periodic scans.")
                self._start_scans()
            else:
                logger.warning("Database not ready at startup; connecting post_migrate handler to start scans after migrations.")
                # post_migrate を一度だけ接続する
                if not self._post_migrate_connected:
                    post_migrate.connect(self._on_post_migrate, dispatch_uid=f'videos_post_migrate_{id(self)}')
                    self._post_migrate_connected = True
        except Exception:
            logger.exception("Exception while checking DB readiness in ready(); connecting post_migrate handler as fallback.")
            if not self._post_migrate_connected:
                post_migrate.connect(self._on_post_migrate, dispatch_uid=f'videos_post_migrate_{id(self)}')
                self._post_migrate_connected = True

```

```backend/videos/migrations/__init__.py

```

```backend/videos/migrations/0001_initial.py
# Generated by Django 5.0.1 on 2025-09-21 15:07

import django.core.validators
import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='Group',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(max_length=100, unique=True, verbose_name='グループ名')),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
            ],
            options={
                'verbose_name': 'タググループ',
                'verbose_name_plural': 'タググループ',
                'db_table': 'video_groups',
                'ordering': ['name'],
            },
        ),
        migrations.CreateModel(
            name='ScanHistory',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('started_at', models.DateTimeField(auto_now_add=True, verbose_name='開始時刻')),
                ('completed_at', models.DateTimeField(blank=True, null=True, verbose_name='完了時刻')),
                ('status', models.CharField(choices=[('running', '実行中'), ('completed', '完了'), ('failed', '失敗')], default='running', max_length=20, verbose_name='ステータス')),
                ('files_scanned', models.IntegerField(default=0, verbose_name='スキャン済みファイル数')),
                ('files_added', models.IntegerField(default=0, verbose_name='追加ファイル数')),
                ('files_updated', models.IntegerField(default=0, verbose_name='更新ファイル数')),
                ('duplicates_found', models.IntegerField(default=0, verbose_name='重複ファイル数')),
                ('errors', models.JSONField(blank=True, default=list, verbose_name='エラー')),
            ],
            options={
                'verbose_name': 'スキャン履歴',
                'verbose_name_plural': 'スキャン履歴',
                'db_table': 'scan_history',
                'ordering': ['-started_at'],
            },
        ),
        migrations.CreateModel(
            name='Folder',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('folder_name', models.CharField(max_length=255, verbose_name='フォルダ名')),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
                ('parent', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, related_name='children', to='videos.folder', verbose_name='親フォルダ')),
            ],
            options={
                'verbose_name': 'フォルダ',
                'verbose_name_plural': 'フォルダ',
                'db_table': 'folders',
                'ordering': ['parent__id', 'folder_name'],
                'unique_together': {('folder_name', 'parent')},
            },
        ),
        migrations.CreateModel(
            name='Tag',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('tag_name', models.CharField(max_length=100, unique=True, verbose_name='タグ名')),
                ('usage_count', models.IntegerField(default=0, validators=[django.core.validators.MinValueValidator(0)], verbose_name='使用回数')),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
                ('groups', models.ManyToManyField(blank=True, related_name='tags', to='videos.group', verbose_name='所属グループ')),
            ],
            options={
                'verbose_name': 'タグ',
                'verbose_name_plural': 'タグ',
                'db_table': 'tags',
                'ordering': ['-usage_count', 'tag_name'],
            },
        ),
        migrations.CreateModel(
            name='File',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('file_name', models.CharField(max_length=255, verbose_name='ファイル名')),
                ('file_path', models.CharField(db_index=True, max_length=255, verbose_name='ファイルパス')),
                ('file_size', models.BigIntegerField(validators=[django.core.validators.MinValueValidator(0)], verbose_name='ファイルサイズ（バイト）')),
                ('md5_hash', models.CharField(db_index=True, max_length=32, verbose_name='MD5ハッシュ')),
                ('video_duration', models.FloatField(blank=True, null=True, validators=[django.core.validators.MinValueValidator(0)], verbose_name='動画の長さ（秒）')),
                ('delete_flag', models.BooleanField(db_index=True, default=False, verbose_name='削除フラグ')),
                ('duplicate_flag', models.BooleanField(db_index=True, default=False, verbose_name='重複フラグ')),
                ('thumbnail_file_path', models.CharField(blank=True, max_length=255, null=True, verbose_name='サムネイルGIFパス')),
                ('metadata', models.JSONField(blank=True, default=dict, verbose_name='メタデータ')),
                ('width', models.IntegerField(blank=True, null=True, verbose_name='動画の幅')),
                ('height', models.IntegerField(blank=True, null=True, verbose_name='動画の高さ')),
                ('fps', models.FloatField(blank=True, null=True, verbose_name='FPS')),
                ('codec', models.CharField(blank=True, max_length=50, null=True, verbose_name='コーデック')),
                ('bitrate', models.IntegerField(blank=True, null=True, verbose_name='ビットレート')),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
                ('last_accessed', models.DateTimeField(blank=True, null=True)),
                ('folders', models.ManyToManyField(blank=True, related_name='files', to='videos.folder', verbose_name='所属フォルダ')),
                ('tags', models.ManyToManyField(blank=True, related_name='files', to='videos.tag', verbose_name='タグ')),
            ],
            options={
                'verbose_name': 'ファイル',
                'verbose_name_plural': 'ファイル',
                'db_table': 'files',
                'ordering': ['-created_at'],
                'indexes': [models.Index(fields=['file_size', 'md5_hash'], name='files_file_si_9d1719_idx'), models.Index(fields=['delete_flag', 'duplicate_flag'], name='files_delete__2332b5_idx')],
            },
        ),
    ]

```

```backend/videos/migrations/0002_file_file_path_hash.py
# Generated by Django 5.0.1 on 2025-09-21 15:10

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('videos', '0001_initial'),
    ]

    operations = [
        migrations.AddField(
            model_name='file',
            name='file_path_hash',
            field=models.CharField(blank=True, db_index=True, editable=False, max_length=64, null=True, unique=True, verbose_name='ファイルパスハッシュ'),
        ),
    ]

```

```backend/videos/models.py
"""
Models for video streaming application.
"""

import hashlib
from django.db import models
from django.core.validators import MinValueValidator
import json


def sha256_hex(s: str) -> str:
    return hashlib.sha256(s.encode('utf-8')).hexdigest()


class Group(models.Model):
    """タググループモデル"""
    name = models.CharField(max_length=100, unique=True, verbose_name='グループ名')
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        db_table = 'video_groups'
        verbose_name = 'タググループ'
        verbose_name_plural = 'タググループ'
        ordering = ['name']

    def __str__(self):
        return self.name


class Tag(models.Model):
    """タグモデル"""
    tag_name = models.CharField(max_length=100, unique=True, verbose_name='タグ名')
    groups = models.ManyToManyField(Group, related_name='tags', blank=True, verbose_name='所属グループ')
    usage_count = models.IntegerField(default=0, validators=[MinValueValidator(0)], verbose_name='使用回数')
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        db_table = 'tags'
        verbose_name = 'タグ'
        verbose_name_plural = 'タグ'
        ordering = ['-usage_count', 'tag_name']

    def __str__(self):
        return self.tag_name

    def increment_usage(self):
        """使用回数をインクリメント"""
        self.usage_count += 1
        self.save(update_fields=['usage_count'])


class Folder(models.Model):
    """フォルダモデル"""
    folder_name = models.CharField(max_length=255, verbose_name='フォルダ名')
    parent = models.ForeignKey(
        'self',
        on_delete=models.CASCADE,
        null=True,
        blank=True,
        related_name='children',
        verbose_name='親フォルダ'
    )
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        db_table = 'folders'
        verbose_name = 'フォルダ'
        verbose_name_plural = 'フォルダ'
        ordering = ['parent__id', 'folder_name']
        unique_together = [['folder_name', 'parent']]

    def __str__(self):
        if self.parent:
            return f"{self.parent} / {self.folder_name}"
        return self.folder_name

    def get_full_path(self):
        """フルパスを取得"""
        if self.parent:
            return f"{self.parent.get_full_path()}/{self.folder_name}"
        return self.folder_name

    def get_ancestors(self):
        """祖先フォルダのリストを取得"""
        ancestors = []
        current = self.parent
        while current:
            ancestors.insert(0, current)
            current = current.parent
        return ancestors


class File(models.Model):
    """ファイルモデル"""
    file_name = models.CharField(max_length=255, verbose_name='ファイル名')
    file_path = models.CharField(max_length=255, verbose_name='ファイルパス', db_index=True)
    # 追加フィールド：固定長ハッシュ（SHA-256）。このフィールドをユニークキーとして使い、MySQLのインデックス長エラーを回避する
    file_path_hash = models.CharField(max_length=64, unique=True, editable=False, null=True, blank=True, verbose_name='ファイルパスハッシュ', db_index=True)

    file_size = models.BigIntegerField(validators=[MinValueValidator(0)], verbose_name='ファイルサイズ（バイト）')
    md5_hash = models.CharField(max_length=32, db_index=True, verbose_name='MD5ハッシュ')
    video_duration = models.FloatField(null=True, blank=True, validators=[MinValueValidator(0)], verbose_name='動画の長さ（秒）')
    folders = models.ManyToManyField(Folder, related_name='files', blank=True, verbose_name='所属フォルダ')
    tags = models.ManyToManyField('Tag', related_name='files', blank=True, verbose_name='タグ')
    delete_flag = models.BooleanField(default=False, db_index=True, verbose_name='削除フラグ')
    duplicate_flag = models.BooleanField(default=False, db_index=True, verbose_name='重複フラグ')
    thumbnail_file_path = models.CharField(max_length=255, null=True, blank=True, verbose_name='サムネイルGIFパス')

    # メタデータ用のJSONフィールド
    metadata = models.JSONField(default=dict, blank=True, verbose_name='メタデータ')

    # 動画情報
    width = models.IntegerField(null=True, blank=True, verbose_name='動画の幅')
    height = models.IntegerField(null=True, blank=True, verbose_name='動画の高さ')
    fps = models.FloatField(null=True, blank=True, verbose_name='FPS')
    codec = models.CharField(max_length=50, null=True, blank=True, verbose_name='コーデック')
    bitrate = models.IntegerField(null=True, blank=True, verbose_name='ビットレート')

    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    last_accessed = models.DateTimeField(null=True, blank=True)

    class Meta:
        db_table = 'files'
        verbose_name = 'ファイル'
        verbose_name_plural = 'ファイル'
        ordering = ['-created_at']
        indexes = [
            models.Index(fields=['file_size', 'md5_hash']),
            models.Index(fields=['delete_flag', 'duplicate_flag']),
        ]

    def __str__(self):
        return self.file_name

    def add_tag(self, tag_name):
        """タグを追加"""
        tag, created = Tag.objects.get_or_create(tag_name=tag_name)
        self.tags.add(tag)
        tag.increment_usage()
        return tag

    def remove_tag(self, tag_name):
        """タグを削除"""
        try:
            tag = Tag.objects.get(tag_name=tag_name)
            self.tags.remove(tag)
            if tag.usage_count > 0:
                tag.usage_count -= 1
                tag.save(update_fields=['usage_count'])
        except Tag.DoesNotExist:
            pass

    def add_to_folder(self, folder):
        """フォルダに追加"""
        self.folders.add(folder)

    def remove_from_folder(self, folder):
        """フォルダから削除"""
        self.folders.remove(folder)

    def mark_as_deleted(self):
        """削除フラグを設定"""
        self.delete_flag = True
        self.save(update_fields=['delete_flag', 'updated_at'])

    def restore(self):
        """削除フラグを解除"""
        self.delete_flag = False
        self.save(update_fields=['delete_flag', 'updated_at'])

    def mark_as_duplicate(self):
        """重複フラグを設定"""
        self.duplicate_flag = True
        self.save(update_fields=['duplicate_flag', 'updated_at'])

    def get_relative_thumbnail_path(self):
        """相対サムネイルパスを取得"""
        if self.thumbnail_file_path:
            return self.thumbnail_file_path.replace('\\', '/')
        return None

    # ここに save() を追加してハッシュをセットする（既存メソッドは消していません）
    def save(self, *args, **kwargs):
        # file_path が設定されているなら SHA-256 を計算して file_path_hash に入れる
        if self.file_path:
            self.file_path_hash = sha256_hex(self.file_path)
        super().save(*args, **kwargs)


class ScanHistory(models.Model):
    """ファイルスキャン履歴"""
    started_at = models.DateTimeField(auto_now_add=True, verbose_name='開始時刻')
    completed_at = models.DateTimeField(null=True, blank=True, verbose_name='完了時刻')
    status = models.CharField(
        max_length=20,
        choices=[
            ('running', '実行中'),
            ('completed', '完了'),
            ('failed', '失敗'),
        ],
        default='running',
        verbose_name='ステータス'
    )
    files_scanned = models.IntegerField(default=0, verbose_name='スキャン済みファイル数')
    files_added = models.IntegerField(default=0, verbose_name='追加ファイル数')
    files_updated = models.IntegerField(default=0, verbose_name='更新ファイル数')
    duplicates_found = models.IntegerField(default=0, verbose_name='重複ファイル数')
    errors = models.JSONField(default=list, blank=True, verbose_name='エラー')

    class Meta:
        db_table = 'scan_history'
        verbose_name = 'スキャン履歴'
        verbose_name_plural = 'スキャン履歴'
        ordering = ['-started_at']

    def __str__(self):
        return f"Scan {self.started_at.strftime('%Y-%m-%d %H:%M:%S')}"

```

```backend/videos/routing.py
"""
WebSocket routing for videos application.
"""

from django.urls import re_path

# WebSocketのURLパターン（現在は空だが、将来的にリアルタイム機能を追加する場合に使用）
websocket_urlpatterns = [
    # 例: re_path(r'ws/scan-status/$', ScanStatusConsumer.as_asgi()),
]
```

```backend/videos/scanner.py
# backend/videos/scanner.py
"""
Scan entrypoints used by VideosConfig to start background scans.
"""

import os
import time
import logging
from django.conf import settings
from .utils import scan_video_directory, check_and_mark_duplicates

logger = logging.getLogger("videos")


def _ensure_media_dirs() -> None:
    """MEDIA_ROOT / VIDEO_DIR / WEBP_DIR を必ず作成しておく。"""
    try:
        os.makedirs(settings.MEDIA_ROOT, exist_ok=True)
        os.makedirs(settings.VIDEO_DIR, exist_ok=True)
        webp_dir = getattr(settings, "WEBP_DIR", os.path.join(settings.MEDIA_ROOT, "webp"))
        os.makedirs(webp_dir, exist_ok=True)
    except Exception:
        logger.exception("Failed to create media directories.")


def initial_scan() -> None:
    """
    サーバ起動直後に 1 回だけ実行する初期スキャン。
    AppConfig から別スレッドで呼ばれる想定。
    """
    _ensure_media_dirs()
    logger.info("Starting initial file scan (with WebP thumbnails)...")
    try:
        scan_video_directory()
        check_and_mark_duplicates()
        logger.info("Initial file scan finished.")
    except Exception:
        logger.exception("Initial file scan failed.")


def periodic_scan() -> None:
    """
    常駐で定期的にスキャンを回すループ。
    AppConfig から別スレッドで呼ばれる想定。
    """
    _ensure_media_dirs()
    interval = getattr(settings, "FILE_SCAN_INTERVAL", 6 * 60 * 60)  # 既定 6 時間
    logger.info("Starting periodic scan loop (interval=%s sec) with WebP thumbnails...", interval)

    while True:
        try:
            logger.info("Periodic scan tick.")
            scan_video_directory()
            check_and_mark_duplicates()
            logger.info("Periodic scan tick finished.")
        except Exception:
            logger.exception("Periodic scan tick failed.")
        time.sleep(interval)

```

```backend/videos/serializers.py
"""
Serializers for video streaming application.
"""

from rest_framework import serializers
from .models import File, Folder, Tag, Group, ScanHistory


class GroupSerializer(serializers.ModelSerializer):
    """タググループシリアライザー"""
    tags_count = serializers.IntegerField(source='tags.count', read_only=True)
    
    class Meta:
        model = Group
        fields = ['id', 'name', 'tags_count', 'created_at', 'updated_at']
        read_only_fields = ['created_at', 'updated_at']


class TagSerializer(serializers.ModelSerializer):
    """タグシリアライザー"""
    groups = GroupSerializer(many=True, read_only=True)
    group_ids = serializers.PrimaryKeyRelatedField(
        many=True, 
        queryset=Group.objects.all(), 
        write_only=True, 
        required=False,
        source='groups'
    )
    
    class Meta:
        model = Tag
        fields = ['id', 'tag_name', 'groups', 'group_ids', 'usage_count', 'created_at', 'updated_at']
        read_only_fields = ['usage_count', 'created_at', 'updated_at']


class FolderSerializer(serializers.ModelSerializer):
    """フォルダシリアライザー"""
    full_path = serializers.CharField(source='get_full_path', read_only=True)
    children_count = serializers.IntegerField(source='children.count', read_only=True)
    files_count = serializers.IntegerField(source='files.count', read_only=True)
    parent_id = serializers.PrimaryKeyRelatedField(
        queryset=Folder.objects.all(),
        source='parent',
        allow_null=True,
        required=False
    )
    
    class Meta:
        model = Folder
        fields = [
            'id', 'folder_name', 'parent', 'parent_id', 'full_path', 
            'children_count', 'files_count', 'created_at', 'updated_at'
        ]
        read_only_fields = ['created_at', 'updated_at']
    
    def validate(self, data):
        """循環参照のチェック"""
        if self.instance and 'parent' in data:
            parent = data['parent']
            if parent:
                # 自分自身を親にできない
                if parent.id == self.instance.id:
                    raise serializers.ValidationError("フォルダは自分自身を親にできません。")
                
                # 自分の子孫を親にできない
                current = parent
                while current.parent:
                    if current.parent.id == self.instance.id:
                        raise serializers.ValidationError("フォルダの子孫を親にすることはできません。")
                    current = current.parent
        
        return data


class FileListSerializer(serializers.ModelSerializer):
    """ファイルリスト用シリアライザー（軽量版）"""
    thumbnail_url = serializers.SerializerMethodField()
    folder_ids = serializers.PrimaryKeyRelatedField(
        many=True, 
        source='folders',
        read_only=True
    )
    tag_names = serializers.StringRelatedField(
        many=True,
        source='tags',
        read_only=True
    )
    
    class Meta:
        model = File
        fields = [
            'id', 'file_name', 'file_size', 'video_duration',
            'folder_ids', 'tag_names', 'delete_flag', 'duplicate_flag',
            'thumbnail_url', 'created_at', 'updated_at'
        ]
    
    def get_thumbnail_url(self, obj):
        """サムネイルURLを取得"""
        if obj.thumbnail_file_path:
            request = self.context.get('request')
            if request:
                return request.build_absolute_uri(f'/media/{obj.get_relative_thumbnail_path()}')
        return None


class FileDetailSerializer(serializers.ModelSerializer):
    """ファイル詳細シリアライザー"""
    folders = FolderSerializer(many=True, read_only=True)
    tags = TagSerializer(many=True, read_only=True)
    thumbnail_url = serializers.SerializerMethodField()
    video_url = serializers.SerializerMethodField()
    
    folder_ids = serializers.PrimaryKeyRelatedField(
        many=True,
        queryset=Folder.objects.all(),
        write_only=True,
        required=False,
        source='folders'
    )
    tag_ids = serializers.PrimaryKeyRelatedField(
        many=True,
        queryset=Tag.objects.all(),
        write_only=True,
        required=False,
        source='tags'
    )
    tag_names = serializers.ListField(
        child=serializers.CharField(),
        write_only=True,
        required=False
    )
    
    class Meta:
        model = File
        fields = [
            'id', 'file_name', 'file_path', 'file_size', 'md5_hash',
            'video_duration', 'folders', 'folder_ids', 'tags', 'tag_ids', 'tag_names',
            'delete_flag', 'duplicate_flag', 'thumbnail_url', 'video_url',
            'metadata', 'width', 'height', 'fps', 'codec', 'bitrate',
            'created_at', 'updated_at', 'last_accessed'
        ]
        read_only_fields = [
            'file_path', 'file_size', 'md5_hash', 'video_duration',
            'width', 'height', 'fps', 'codec', 'bitrate',
            'created_at', 'updated_at'
        ]
    
    def get_thumbnail_url(self, obj):
        """サムネイルURLを取得"""
        if obj.thumbnail_file_path:
            request = self.context.get('request')
            if request:
                return request.build_absolute_uri(f'/media/{obj.get_relative_thumbnail_path()}')
        return None
    
    def get_video_url(self, obj):
        """動画URLを取得"""
        request = self.context.get('request')
        if request:
            relative_path = obj.file_path.replace('\\', '/')
            if relative_path.startswith('media/'):
                relative_path = relative_path[6:]
            return request.build_absolute_uri(f'/media/{relative_path}')
        return None
    
    def update(self, instance, validated_data):
        """更新処理"""
        # タグ名からタグを作成/取得
        tag_names = validated_data.pop('tag_names', None)
        if tag_names is not None:
            for tag_name in tag_names:
                instance.add_tag(tag_name)
        
        # フォルダとタグの更新
        folders = validated_data.pop('folders', None)
        tags = validated_data.pop('tags', None)
        
        instance = super().update(instance, validated_data)
        
        if folders is not None:
            instance.folders.set(folders)
        
        if tags is not None:
            instance.tags.set(tags)
            # 使用回数の更新
            for tag in tags:
                tag.increment_usage()
        
        return instance


class FileBulkActionSerializer(serializers.Serializer):
    """ファイル一括操作用シリアライザー"""
    file_ids = serializers.ListField(
        child=serializers.IntegerField(),
        required=True
    )
    action = serializers.ChoiceField(
        choices=[
            ('delete', '削除フラグ設定'),
            ('restore', '削除フラグ解除'),
            ('add_to_folder', 'フォルダに追加'),
            ('remove_from_folder', 'フォルダから削除'),
            ('add_tags', 'タグ追加'),
            ('remove_tags', 'タグ削除'),
        ],
        required=True
    )
    folder_id = serializers.IntegerField(required=False)
    tag_ids = serializers.ListField(
        child=serializers.IntegerField(),
        required=False
    )
    tag_names = serializers.ListField(
        child=serializers.CharField(),
        required=False
    )


class ScanHistorySerializer(serializers.ModelSerializer):
    """スキャン履歴シリアライザー"""
    duration = serializers.SerializerMethodField()
    
    class Meta:
        model = ScanHistory
        fields = [
            'id', 'started_at', 'completed_at', 'status',
            'files_scanned', 'files_added', 'files_updated',
            'duplicates_found', 'errors', 'duration'
        ]
    
    def get_duration(self, obj):
        """実行時間を取得"""
        if obj.completed_at and obj.started_at:
            delta = obj.completed_at - obj.started_at
            return delta.total_seconds()
        return None
```

```backend/videos/tasks.py
"""
Background tasks for video processing.
"""

import logging
from celery import shared_task
from django.utils import timezone
from datetime import timedelta
from .utils import scan_video_directory, check_and_mark_duplicates

logger = logging.getLogger('videos')


@shared_task
def periodic_scan_task():
    """
    定期的なファイルスキャンタスク
    """
    logger.info("Starting periodic file scan task...")
    
    try:
        # ファイルスキャンを実行
        scan_history = scan_video_directory()
        
        # 重複チェック
        duplicates = check_and_mark_duplicates()
        
        logger.info(f"Periodic scan completed. Files added: {scan_history.files_added}, Duplicates: {duplicates}")
        
        return {
            'status': 'success',
            'scan_id': scan_history.id,
            'files_added': scan_history.files_added,
            'files_updated': scan_history.files_updated,
            'duplicates_found': duplicates
        }
    
    except Exception as e:
        logger.error(f"Periodic scan failed: {str(e)}")
        return {
            'status': 'failed',
            'error': str(e)
        }


@shared_task
def cleanup_old_scan_history():
    """
    古いスキャン履歴を削除
    """
    from .models import ScanHistory
    
    # 30日以上前の履歴を削除
    cutoff_date = timezone.now() - timedelta(days=30)
    deleted_count = ScanHistory.objects.filter(started_at__lt=cutoff_date).delete()[0]
    
    logger.info(f"Deleted {deleted_count} old scan history records")
    return deleted_count


@shared_task
def generate_missing_thumbnails():
    """
    サムネイルが欠けているファイルのGIFを生成
    """
    from .models import File
    from .utils import create_gif_thumbnail
    import os
    from django.conf import settings
    
    files_without_thumbnails = File.objects.filter(
        thumbnail_file_path__isnull=True,
        delete_flag=False
    )
    
    generated_count = 0
    
    for file in files_without_thumbnails:
        try:
            video_path = os.path.join(settings.MEDIA_ROOT, file.file_path)
            
            if not os.path.exists(video_path):
                logger.warning(f"Video file not found: {video_path}")
                continue
            
            gif_filename = f"{os.path.splitext(file.file_name)[0]}.gif"
            gif_path = os.path.join(settings.GIF_DIR, gif_filename)
            
            if create_gif_thumbnail(video_path, gif_path):
                file.thumbnail_file_path = f"gifs/{gif_filename}"
                file.save(update_fields=['thumbnail_file_path', 'updated_at'])
                generated_count += 1
                logger.info(f"Generated thumbnail for: {file.file_name}")
        
        except Exception as e:
            logger.error(f"Failed to generate thumbnail for {file.file_name}: {str(e)}")
    
    logger.info(f"Generated {generated_count} missing thumbnails")
    return generated_count
```

```backend/videos/urls.py
"""
URL routing for videos application.
"""

from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import (
    FileViewSet, FolderViewSet, TagViewSet, GroupViewSet,
    ScanView, ScanHistoryViewSet
)

router = DefaultRouter()
router.register(r'files', FileViewSet, basename='file')
router.register(r'folders', FolderViewSet, basename='folder')
router.register(r'tags', TagViewSet, basename='tag')
router.register(r'groups', GroupViewSet, basename='group')
router.register(r'scan-history', ScanHistoryViewSet, basename='scan-history')

urlpatterns = [
    path('', include(router.urls)),
    path('force_refresh/', ScanView.as_view(), name='force-refresh'),
    
    # 特殊なファイルリスト用エンドポイント
    path('files/all/', FileViewSet.as_view({'get': 'all_files'}), name='all-files'),
    path('files/no-folder/', FileViewSet.as_view({'get': 'no_folder_files'}), name='no-folder-files'),
    path('files/deleted/', FileViewSet.as_view({'get': 'deleted_files'}), name='deleted-files'),
    path('files/duplicates/', FileViewSet.as_view({'get': 'duplicate_files'}), name='duplicate-files'),
]
```

```backend/videos/utils.py
"""
Utility functions for video processing and file management.
"""

import os
import hashlib
import subprocess
import json
import logging
from pathlib import Path
from datetime import datetime
import ffmpeg
import imageio  # 既存依存を残す（未使用でも削除不要）
from django.conf import settings
from .models import File, ScanHistory

logger = logging.getLogger('videos')


def get_video_info(file_path):
    """
    FFmpegを使用して動画情報を取得
    """
    try:
        probe = ffmpeg.probe(file_path)
        video_stream = next((stream for stream in probe['streams'] if stream['codec_type'] == 'video'), None)
        
        if video_stream:
            duration = float(probe['format'].get('duration', 0))
            width = int(video_stream.get('width', 0))
            height = int(video_stream.get('height', 0))
            fps = eval(video_stream.get('r_frame_rate', '0/1'))
            if isinstance(fps, tuple):
                fps = fps[0] / fps[1] if fps[1] != 0 else 0
            codec = video_stream.get('codec_name', '')
            bitrate = int(probe['format'].get('bit_rate', 0))
            
            return {
                'duration': duration,
                'width': width,
                'height': height,
                'fps': fps,
                'codec': codec,
                'bitrate': bitrate
            }
    except Exception as e:
        logger.error(f"Error getting video info for {file_path}: {e}")
    
    return None


def calculate_md5_partial(file_path, max_size=10*1024*1024):
    """
    ファイルの最初の部分のMD5ハッシュを計算（大きなファイル用）
    FFmpegを使用して最初のキーフレームまでをコピーしてから計算
    """
    try:
        temp_file = file_path + '.temp.mp4'
        try:
            (
                ffmpeg
                .input(file_path)
                .output(temp_file, t=1, c='copy', f='mp4')
                .overwrite_output()
                .run(capture_stdout=True, capture_stderr=True)
            )
        except ffmpeg.Error:
            return calculate_md5_direct(file_path, max_size)
        
        md5_hash = hashlib.md5()
        with open(temp_file, 'rb') as f:
            while chunk := f.read(8192):
                md5_hash.update(chunk)
        if os.path.exists(temp_file):
            os.remove(temp_file)
        return md5_hash.hexdigest()
    
    except Exception as e:
        logger.error(f"Error calculating MD5 for {file_path}: {e}")
        return calculate_md5_direct(file_path, max_size)


def calculate_md5_direct(file_path, max_size=10*1024*1024):
    """
    ファイルの最初の部分を直接読んでMD5を計算（フォールバック）
    """
    try:
        md5_hash = hashlib.md5()
        with open(file_path, 'rb') as f:
            bytes_read = 0
            while bytes_read < max_size:
                chunk = f.read(min(8192, max_size - bytes_read))
                if not chunk:
                    break
                md5_hash.update(chunk)
                bytes_read += len(chunk)
        return md5_hash.hexdigest()
    except Exception as e:
        logger.error(f"Error calculating MD5 (direct) for {file_path}: {e}")
        return None


def create_webp_thumbnail(video_path, webp_path, duration=10, fps=10, scale=320, quality=75, lossless=0, compression_level=6):
    """
    動画からアニメーションWebPサムネイルを作成
    - duration: 最初の何秒を使うか
    - fps: サムネイルのフレームレート
    - scale: 横幅（高さはアスペクト維持で自動）
    - quality: 0(低)〜100(高) 目安: 60〜80
    - lossless: 0=非可逆, 1=可逆
    - compression_level: 0(高速)〜6(高圧縮)
    """
    try:
        os.makedirs(os.path.dirname(webp_path), exist_ok=True)

        video_info = get_video_info(video_path)
        if not video_info:
            return False

        webp_duration = min(duration, max(0.0, float(video_info['duration'])))

        try:
            # ffmpeg-python で libwebp によるアニメーションWebP作成
            # -vf "fps=fps,scale=scale:-1:flags=lanczos" -loop 0 -vcodec libwebp -q:v quality -lossless {0|1} -compression_level 6
            (
                ffmpeg
                .input(video_path, ss=0, t=webp_duration)
                .filter('fps', fps=fps)
                .filter('scale', scale, -1)
                .output(
                    webp_path,
                    vcodec='libwebp',
                    loop=0,
                    lossless=lossless,
                    compression_level=compression_level,
                    **{'q:v': quality}
                )
                .overwrite_output()
                .run(capture_stdout=True, capture_stderr=True)
            )
            return True
        except ffmpeg.Error as e:
            try:
                # 互換のため -qscale:v で再試行
                (
                    ffmpeg
                    .input(video_path, ss=0, t=webp_duration)
                    .filter('fps', fps=fps)
                    .filter('scale', scale, -1)
                    .output(
                        webp_path,
                        vcodec='libwebp',
                        loop=0,
                        lossless=lossless,
                        compression_level=compression_level,
                        **{'qscale:v': quality}
                    )
                    .overwrite_output()
                    .run(capture_stdout=True, capture_stderr=True)
                )
                return True
            except ffmpeg.Error as e2:
                logger.error(f"FFmpeg error creating WebP: {e2.stderr.decode() if hasattr(e2, 'stderr') and e2.stderr else e2}")
                return False

    except Exception as e:
        logger.error(f"Error creating WebP thumbnail for {video_path}: {e}")
        return False


def scan_video_directory():
    """
    動画ディレクトリをスキャンしてデータベースを更新
    """
    scan_history = ScanHistory.objects.create()
    
    video_dir = settings.VIDEO_DIR
    # ★ 変更点: WebP 用ディレクトリを使用
    webp_dir = getattr(settings, 'WEBP_DIR', os.path.join(settings.MEDIA_ROOT, 'webp'))

    # ディレクトリを確実に作成
    try:
        os.makedirs(settings.MEDIA_ROOT, exist_ok=True)
        os.makedirs(video_dir, exist_ok=True)
        os.makedirs(webp_dir, exist_ok=True)
    except Exception as e:
        logger.error(f"Failed to prepare media directories: {e}")
        scan_history.status = 'failed'
        scan_history.errors = [f"Failed to prepare media directories: {e}"]
        scan_history.save()
        return scan_history
    
    video_extensions = {'.mp4', '.avi', '.mkv', '.mov', '.wmv', '.flv', '.webm', '.m4v', '.mpg', '.mpeg'}
    
    files_scanned = 0
    files_added = 0
    files_updated = 0
    duplicates_found = 0
    errors = []
    
    try:
        for root, dirs, files in os.walk(video_dir):
            for filename in files:
                file_path = os.path.join(root, filename)
                
                if not any(filename.lower().endswith(ext) for ext in video_extensions):
                    continue
                
                files_scanned += 1
                
                try:
                    file_size = os.path.getsize(file_path)
                    relative_path = os.path.relpath(file_path, settings.MEDIA_ROOT)
                    
                    existing_file = File.objects.filter(
                        file_name=filename,
                        file_size=file_size
                    ).first()
                    
                    if existing_file:
                        if existing_file.file_path != relative_path:
                            existing_file.file_path = relative_path
                            existing_file.save(update_fields=['file_path', 'updated_at'])
                            files_updated += 1
                        continue
                    
                    md5_hash = calculate_md5_partial(file_path)
                    if not md5_hash:
                        errors.append(f"Failed to calculate MD5 for {file_path}")
                        continue
                    
                    is_duplicate = File.objects.filter(
                        file_size=file_size,
                        md5_hash=md5_hash
                    ).exists()
                    
                    if is_duplicate:
                        File.objects.filter(
                            file_size=file_size,
                            md5_hash=md5_hash
                        ).update(duplicate_flag=True)
                        duplicates_found += 1
                    
                    video_info = get_video_info(file_path)

                    # ★ 変更点: WebP サムネイルを作成
                    webp_filename = f"{os.path.splitext(filename)[0]}.webp"
                    webp_path = os.path.join(webp_dir, webp_filename)
                    webp_created = create_webp_thumbnail(file_path, webp_path)

                    file_record = File(
                        file_name=filename,
                        file_path=relative_path,
                        file_size=file_size,
                        md5_hash=md5_hash,
                        duplicate_flag=is_duplicate
                    )
                    
                    if video_info:
                        file_record.video_duration = video_info['duration']
                        file_record.width = video_info['width']
                        file_record.height = video_info['height']
                        file_record.fps = video_info['fps']
                        file_record.codec = video_info['codec']
                        file_record.bitrate = video_info['bitrate']
                    
                    # ★ 変更点: WebP の相対パスを保存（フィールド名は互換のためそのまま）
                    if webp_created:
                        file_record.thumbnail_file_path = f"webp/{webp_filename}"
                    
                    file_record.save()
                    files_added += 1
                    
                    logger.info(f"Added file: {filename}")
                
                except Exception as e:
                    error_msg = f"Error processing file {file_path}: {str(e)}"
                    logger.error(error_msg)
                    errors.append(error_msg)
        
        scan_history.completed_at = datetime.now()
        scan_history.status = 'completed'
        scan_history.files_scanned = files_scanned
        scan_history.files_added = files_added
        scan_history.files_updated = files_updated
        scan_history.duplicates_found = duplicates_found
        scan_history.errors = errors
        scan_history.save()
        
        logger.info(f"Scan completed: {files_scanned} scanned, {files_added} added, {files_updated} updated, {duplicates_found} duplicates")
        
    except Exception as e:
        error_msg = f"Scan failed: {str(e)}"
        logger.error(error_msg)
        scan_history.completed_at = datetime.now()
        scan_history.status = 'failed'
        scan_history.errors = [error_msg]
        scan_history.save()
    
    return scan_history


def check_and_mark_duplicates():
    """
    すべてのファイルの重複をチェックしてフラグを更新
    """
    from django.db.models import Count
    
    duplicate_groups = File.objects.values('file_size', 'md5_hash').annotate(
        count=Count('id')
    ).filter(count__gt=1)
    
    duplicates_marked = 0
    
    for group in duplicate_groups:
        files = File.objects.filter(
            file_size=group['file_size'],
            md5_hash=group['md5_hash']
        )
        updated = files.update(duplicate_flag=True)
        duplicates_marked += updated
    
    logger.info(f"Marked {duplicates_marked} files as duplicates")
    return duplicates_marked

```

```backend/videos/views.py
"""
Views for video streaming application.
"""

from rest_framework import viewsets, status
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework.views import APIView
from django.db.models import Q, Count
from django.utils import timezone
import logging

from .models import File, Folder, Tag, Group, ScanHistory
from .serializers import (
    FileListSerializer, FileDetailSerializer, FileBulkActionSerializer,
    FolderSerializer, TagSerializer, GroupSerializer, ScanHistorySerializer
)
from .utils import scan_video_directory, check_and_mark_duplicates

logger = logging.getLogger('videos')


class FileViewSet(viewsets.ModelViewSet):
    """ファイルビューセット"""
    queryset = File.objects.all()
    
    def get_serializer_class(self):
        if self.action in ['list']:
            return FileListSerializer
        return FileDetailSerializer
    
    def get_queryset(self):
        queryset = super().get_queryset()
        
        # クエリパラメータでフィルタリング
        params = self.request.query_params
        
        # 削除フラグでフィルタ
        delete_flag = params.get('delete_flag')
        if delete_flag is not None:
            queryset = queryset.filter(delete_flag=delete_flag.lower() == 'true')
        
        # 重複フラグでフィルタ
        duplicate_flag = params.get('duplicate_flag')
        if duplicate_flag is not None:
            queryset = queryset.filter(duplicate_flag=duplicate_flag.lower() == 'true')
        
        # フォルダでフィルタ
        folder_id = params.get('folder_id')
        if folder_id:
            queryset = queryset.filter(folders__id=folder_id)
        
        # フォルダに属さないファイル
        no_folder = params.get('no_folder')
        if no_folder and no_folder.lower() == 'true':
            queryset = queryset.filter(folders__isnull=True)
        
        # タグでフィルタ
        tag_ids = params.getlist('tag_ids')
        if tag_ids:
            queryset = queryset.filter(tags__id__in=tag_ids).distinct()
        
        # 検索
        search = params.get('search')
        if search:
            queryset = queryset.filter(
                Q(file_name__icontains=search) |
                Q(tags__tag_name__icontains=search)
            ).distinct()
        
        # ソート
        sort_by = params.get('sort_by', '-created_at')
        queryset = queryset.order_by(sort_by)
        
        return queryset
    
    @action(detail=False, methods=['get'])
    def all_files(self, request):
        """削除されていないすべてのファイル"""
        queryset = self.get_queryset().filter(delete_flag=False)
        page = self.paginate_queryset(queryset)
        if page is not None:
            serializer = FileListSerializer(page, many=True, context={'request': request})
            return self.get_paginated_response(serializer.data)
        serializer = FileListSerializer(queryset, many=True, context={'request': request})
        return Response(serializer.data)
    
    @action(detail=False, methods=['get'])
    def no_folder_files(self, request):
        """フォルダに属さないファイル"""
        queryset = self.get_queryset().filter(folders__isnull=True, delete_flag=False)
        page = self.paginate_queryset(queryset)
        if page is not None:
            serializer = FileListSerializer(page, many=True, context={'request': request})
            return self.get_paginated_response(serializer.data)
        serializer = FileListSerializer(queryset, many=True, context={'request': request})
        return Response(serializer.data)
    
    @action(detail=False, methods=['get'])
    def deleted_files(self, request):
        """削除フラグが付いたファイル"""
        queryset = self.get_queryset().filter(delete_flag=True)
        page = self.paginate_queryset(queryset)
        if page is not None:
            serializer = FileListSerializer(page, many=True, context={'request': request})
            return self.get_paginated_response(serializer.data)
        serializer = FileListSerializer(queryset, many=True, context={'request': request})
        return Response(serializer.data)
    
    @action(detail=False, methods=['get'])
    def duplicate_files(self, request):
        """重複フラグが付いたファイル"""
        queryset = self.get_queryset().filter(duplicate_flag=True)
        page = self.paginate_queryset(queryset)
        if page is not None:
            serializer = FileListSerializer(page, many=True, context={'request': request})
            return self.get_paginated_response(serializer.data)
        serializer = FileListSerializer(queryset, many=True, context={'request': request})
        return Response(serializer.data)
    
    @action(detail=True, methods=['post'])
    def mark_deleted(self, request, pk=None):
        """削除フラグを設定"""
        file = self.get_object()
        file.mark_as_deleted()
        serializer = FileDetailSerializer(file, context={'request': request})
        return Response(serializer.data)
    
    @action(detail=True, methods=['post'])
    def restore(self, request, pk=None):
        """削除フラグを解除"""
        file = self.get_object()
        file.restore()
        serializer = FileDetailSerializer(file, context={'request': request})
        return Response(serializer.data)
    
    @action(detail=True, methods=['post'])
    def add_to_folder(self, request, pk=None):
        """フォルダに追加"""
        file = self.get_object()
        folder_id = request.data.get('folder_id')
        
        if not folder_id:
            return Response({'error': 'folder_id is required'}, status=status.HTTP_400_BAD_REQUEST)
        
        try:
            folder = Folder.objects.get(id=folder_id)
            file.add_to_folder(folder)
            serializer = FileDetailSerializer(file, context={'request': request})
            return Response(serializer.data)
        except Folder.DoesNotExist:
            return Response({'error': 'Folder not found'}, status=status.HTTP_404_NOT_FOUND)
    
    @action(detail=True, methods=['post'])
    def remove_from_folder(self, request, pk=None):
        """フォルダから削除"""
        file = self.get_object()
        folder_id = request.data.get('folder_id')
        
        if not folder_id:
            return Response({'error': 'folder_id is required'}, status=status.HTTP_400_BAD_REQUEST)
        
        try:
            folder = Folder.objects.get(id=folder_id)
            file.remove_from_folder(folder)
            serializer = FileDetailSerializer(file, context={'request': request})
            return Response(serializer.data)
        except Folder.DoesNotExist:
            return Response({'error': 'Folder not found'}, status=status.HTTP_404_NOT_FOUND)
    
    @action(detail=True, methods=['post'])
    def add_tags(self, request, pk=None):
        """タグを追加"""
        file = self.get_object()
        tag_names = request.data.get('tag_names', [])
        
        for tag_name in tag_names:
            file.add_tag(tag_name)
        
        serializer = FileDetailSerializer(file, context={'request': request})
        return Response(serializer.data)
    
    @action(detail=True, methods=['post'])
    def remove_tags(self, request, pk=None):
        """タグを削除"""
        file = self.get_object()
        tag_names = request.data.get('tag_names', [])
        
        for tag_name in tag_names:
            file.remove_tag(tag_name)
        
        serializer = FileDetailSerializer(file, context={'request': request})
        return Response(serializer.data)
    
    @action(detail=False, methods=['post'])
    def bulk_action(self, request):
        """一括操作"""
        serializer = FileBulkActionSerializer(data=request.data)
        
        if not serializer.is_valid():
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
        
        data = serializer.validated_data
        file_ids = data['file_ids']
        action = data['action']
        
        files = File.objects.filter(id__in=file_ids)
        
        if action == 'delete':
            files.update(delete_flag=True, updated_at=timezone.now())
        elif action == 'restore':
            files.update(delete_flag=False, updated_at=timezone.now())
        elif action == 'add_to_folder':
            folder_id = data.get('folder_id')
            if folder_id:
                try:
                    folder = Folder.objects.get(id=folder_id)
                    for file in files:
                        file.add_to_folder(folder)
                except Folder.DoesNotExist:
                    return Response({'error': 'Folder not found'}, status=status.HTTP_404_NOT_FOUND)
        elif action == 'remove_from_folder':
            folder_id = data.get('folder_id')
            if folder_id:
                try:
                    folder = Folder.objects.get(id=folder_id)
                    for file in files:
                        file.remove_from_folder(folder)
                except Folder.DoesNotExist:
                    return Response({'error': 'Folder not found'}, status=status.HTTP_404_NOT_FOUND)
        elif action == 'add_tags':
            tag_names = data.get('tag_names', [])
            for file in files:
                for tag_name in tag_names:
                    file.add_tag(tag_name)
        elif action == 'remove_tags':
            tag_names = data.get('tag_names', [])
            for file in files:
                for tag_name in tag_names:
                    file.remove_tag(tag_name)
        
        return Response({'success': True, 'files_affected': files.count()})
    
    def retrieve(self, request, *args, **kwargs):
        """ファイル詳細取得時に最終アクセス時刻を更新"""
        instance = self.get_object()
        instance.last_accessed = timezone.now()
        instance.save(update_fields=['last_accessed'])
        serializer = self.get_serializer(instance)
        return Response(serializer.data)


class FolderViewSet(viewsets.ModelViewSet):
    """フォルダビューセット"""
    queryset = Folder.objects.all()
    serializer_class = FolderSerializer
    
    def get_queryset(self):
        queryset = super().get_queryset()
        
        # 親フォルダでフィルタ
        parent_id = self.request.query_params.get('parent_id')
        if parent_id == 'null':
            queryset = queryset.filter(parent__isnull=True)
        elif parent_id:
            queryset = queryset.filter(parent_id=parent_id)
        
        return queryset
    
    @action(detail=False, methods=['get'])
    def tree(self, request):
        """フォルダツリー構造を取得"""
        def build_tree(parent=None):
            folders = []
            for folder in Folder.objects.filter(parent=parent):
                folder_data = FolderSerializer(folder).data
                folder_data['children'] = build_tree(folder)
                folders.append(folder_data)
            return folders
        
        tree = build_tree()
        return Response(tree)


class TagViewSet(viewsets.ModelViewSet):
    """タグビューセット"""
    queryset = Tag.objects.all()
    serializer_class = TagSerializer
    
    @action(detail=False, methods=['get'])
    def popular(self, request):
        """人気のタグを取得"""
        limit = int(request.query_params.get('limit', 20))
        tags = self.queryset.order_by('-usage_count')[:limit]
        serializer = self.get_serializer(tags, many=True)
        return Response(serializer.data)
    
    @action(detail=False, methods=['get'])
    def search(self, request):
        """タグを検索"""
        query = request.query_params.get('q', '')
        if query:
            tags = self.queryset.filter(tag_name__icontains=query)
        else:
            tags = self.queryset.all()
        
        serializer = self.get_serializer(tags, many=True)
        return Response(serializer.data)


class GroupViewSet(viewsets.ModelViewSet):
    """タググループビューセット"""
    queryset = Group.objects.all()
    serializer_class = GroupSerializer


class ScanView(APIView):
    """ファイルスキャンビュー"""
    
    def get(self, request, format=None):
        """強制スキャンを実行"""
        logger.info("Starting forced file scan...")
        scan_history = scan_video_directory()
        
        # 重複チェック
        check_and_mark_duplicates()
        
        serializer = ScanHistorySerializer(scan_history)
        return Response(serializer.data)


class ScanHistoryViewSet(viewsets.ReadOnlyModelViewSet):
    """スキャン履歴ビューセット"""
    queryset = ScanHistory.objects.all()
    serializer_class = ScanHistorySerializer
    
    @action(detail=False, methods=['get'])
    def latest(self, request):
        """最新のスキャン履歴を取得"""
        latest = self.queryset.first()
        if latest:
            serializer = self.get_serializer(latest)
            return Response(serializer.data)
        return Response({'message': 'No scan history found'}, status=status.HTTP_404_NOT_FOUND)
```

```complete_setup.bat
@echo off
echo ========================================
echo Video Streaming Complete Setup
echo ========================================
echo.

echo This script will set up the complete video streaming system.
echo Make sure you have the following installed:
echo - Python 3.10+
echo - Node.js 18+
echo - MySQL 8.0+
echo - FFmpeg
echo.
pause

:: バックエンドセットアップ
echo.
echo [Step 1/3] Setting up Backend...
echo ========================================
call install.bat
if errorlevel 1 (
    echo Backend setup failed!
    pause
    exit /b 1
)

:: フロントエンドセットアップ
echo.
echo [Step 2/3] Setting up Frontend...
echo ========================================
call frontend_install.bat
if errorlevel 1 (
    echo Frontend setup failed!
    pause
    exit /b 1
)

:: 初期データ作成
echo.
echo [Step 3/3] Creating initial data...
echo ========================================
cd backend
call ..\venv\Scripts\activate.bat

:: スーパーユーザーが作成されていない場合のみ作成
python manage.py shell -c "from django.contrib.auth import get_user_model; User = get_user_model(); exit(0 if User.objects.filter(is_superuser=True).exists() else 1)"
if errorlevel 1 (
    echo Creating superuser account...
    python manage.py createsuperuser --username admin --email admin@localhost
)

:: 初期フォルダ作成
python manage.py shell -c "from videos.models import Folder; Folder.objects.get_or_create(folder_name='お気に入り', parent=None); Folder.objects.get_or_create(folder_name='未分類', parent=None)"

cd ..

echo.
echo ========================================
echo Setup completed successfully!
echo ========================================
echo.
echo To start the system, run: start_all.bat
echo.
echo Default URLs:
echo - Frontend: http://localhost:3000
echo - Backend API: http://localhost:8000/api
echo - Admin Panel: http://localhost:8000/admin
echo.
echo Default admin credentials:
echo - Username: admin
echo - Password: (the one you just created)
echo.
echo Place your video files in: media\videos\
echo.
pause
```

```Django Video Streaming Backend Setup - Claude.url
[InternetShortcut]
URL=https://claude.ai/chat/976505d8-44b8-48af-bf93-41ef21bbabcc

```

```frontend_install.bat
@echo off
echo ========================================
echo Video Streaming Frontend Installation
echo ========================================
echo.

:: Node.jsがインストールされているか確認
where node >nul 2>nul
if errorlevel 1 (
    echo Error: Node.js is not installed.
    echo Please install Node.js from https://nodejs.org/
    pause
    exit /b 1
)

:: npmがインストールされているか確認
where npm >nul 2>nul
if errorlevel 1 (
    echo Error: npm is not installed.
    echo Please install Node.js with npm from https://nodejs.org/
    pause
    exit /b 1
)

echo [1/4] Node.js version:
node --version
echo.
echo [2/4] npm version:
npm --version
echo.

:: フロントエンドディレクトリに移動
echo [3/4] Navigating to frontend directory...
cd frontend
if errorlevel 1 (
    echo Error: frontend directory not found.
    echo Please ensure the frontend folder exists.
    pause
    exit /b 1
)

:: 依存関係のインストール
echo [4/4] Installing dependencies...
echo This may take a few minutes...
npm install
if errorlevel 1 (
    echo Error: Failed to install dependencies.
    pause
    exit /b 1
)

echo.
echo ========================================
echo Frontend installation completed!
echo ========================================
echo.
echo To start the development server:
echo   cd frontend
echo   npm run dev
echo.
echo The frontend will be available at:
echo   http://localhost:3000
echo.
pause
```

```frontend/.env
VITE_API_URL=http://localhost:8000
VITE_API_BASE_URL=http://localhost:8000/api
VITE_MEDIA_URL=http://localhost:8000/media
```

```frontend/.gitignore
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

```

```frontend/eslint.config.js
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'

export default [
  { ignores: ['dist'] },
  {
    files: ['**/*.{js,jsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        ecmaVersion: 'latest',
        ecmaFeatures: { jsx: true },
        sourceType: 'module',
      },
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...js.configs.recommended.rules,
      ...reactHooks.configs.recommended.rules,
      'no-unused-vars': ['error', { varsIgnorePattern: '^[A-Z_]' }],
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
]

```

```frontend/index.html
<!DOCTYPE html>
<html lang="ja">

<head>
  <meta charset="UTF-8" />
  <link rel="icon" type="image/svg+xml" href="/vite.svg" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Video Streaming</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&display=swap" />
  <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons" />
</head>

<body>
  <div id="root"></div>
  <script type="module" src="/src/main.jsx"></script>
</body>

</html>
```

```frontend/package.json
{
  "name": "video-streaming-frontend",
  "private": true,
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview",
    "start": "vite --host"
  },
  "dependencies": {
    "@emotion/react": "^11.11.3",
    "@emotion/styled": "^11.11.0",
    "@mui/icons-material": "^5.15.3",
    "@mui/material": "^5.15.3",
    "@mui/x-data-grid": "^6.18.7",
    "@mui/x-date-pickers": "^8.11.3",
    "@tanstack/react-virtual": "^3.0.1",
    "axios": "^1.6.5",
    "date-fns": "^3.2.0",
    "framer-motion": "^10.18.0",
    "jotai": "^2.6.2",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-draggable": "^4.4.6",
    "react-intersection-observer": "^9.5.3",
    "react-player": "^2.14.1",
    "react-resizable": "^3.0.5",
    "react-resizable-panels": "^1.0.8",
    "react-router-dom": "^6.21.2",
    "react-use": "^17.4.2",
    "react-window": "^1.8.10",
    "use-long-press": "^3.2.0",
    "zustand": "^4.4.7"
  },
  "devDependencies": {
    "@types/react": "^18.2.48",
    "@types/react-dom": "^18.2.18",
    "@vitejs/plugin-react": "^4.2.1",
    "vite": "^5.0.11"
  }
}

```

```frontend/public/vite.svg
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>
```

```frontend/README.md
# React + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react) uses [Babel](https://babeljs.io/) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## Expanding the ESLint configuration

If you are developing a production application, we recommend using TypeScript with type-aware lint rules enabled. Check out the [TS template](https://github.com/vitejs/vite/tree/main/packages/create-vite/template-react-ts) for information on how to integrate TypeScript and [`typescript-eslint`](https://typescript-eslint.io) in your project.

```

```frontend/src/App.css
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}

```

```frontend/src/App.jsx
import React, { useEffect } from "react";
import { Routes, Route, Navigate } from "react-router-dom";
import { useAtom } from "jotai";
import { Box } from "@mui/material";

// レイアウト
import MainLayout from "@components/layout/MainLayout";

// ページ
import AllFilesPage from "@pages/AllFilesPage";
import NoFolderFilesPage from "@pages/NoFolderFilesPage";
import FoldersPage from "@pages/FoldersPage";
import DeletedFilesPage from "@pages/DeletedFilesPage";
import DuplicateFilesPage from "@pages/DuplicateFilesPage";

// コンポーネント
import VideoPlayer from "@components/player/VideoPlayer";
import MultiPlayerContainer from "@components/player/MultiPlayerContainer";
import ContextMenu from "@components/common/ContextMenu";
import NotificationSnackbar from "@components/common/NotificationSnackbar";
import LoadingOverlay from "@components/common/LoadingOverlay";

// ストア
import { windowSizeAtom, openPlayersAtom } from "@store/atoms";

// ユーティリティ
import { setupKeyboardShortcuts } from "@utils/keyboard";

function App() {
    const [, setWindowSize] = useAtom(windowSizeAtom);
    const [openPlayers] = useAtom(openPlayersAtom);

    // ウィンドウサイズの監視
    useEffect(() => {
        const handleResize = () => {
            setWindowSize({
                width: window.innerWidth,
                height: window.innerHeight,
            });
        };

        window.addEventListener("resize", handleResize);
        return () => window.removeEventListener("resize", handleResize);
    }, [setWindowSize]);

    // キーボードショートカットのセットアップ
    useEffect(() => {
        const cleanup = setupKeyboardShortcuts();
        return cleanup;
    }, []);

    // コンテキストメニューの無効化
    useEffect(() => {
        const handleContextMenu = (e) => {
            // カスタムコンテキストメニューを使用するため、デフォルトを無効化
            if (e.target.closest(".enable-context-menu")) {
                return;
            }
            e.preventDefault();
        };

        document.addEventListener("contextmenu", handleContextMenu);
        return () =>
            document.removeEventListener("contextmenu", handleContextMenu);
    }, []);

    return (
        <Box sx={{ height: "100vh", display: "flex", flexDirection: "column" }}>
            <MainLayout>
                <Routes>
                    <Route
                        path="/"
                        element={<Navigate to="/all-files" replace />}
                    />
                    <Route path="/all-files" element={<AllFilesPage />} />
                    <Route path="/no-folder" element={<NoFolderFilesPage />} />
                    <Route path="/folders" element={<FoldersPage />} />
                    <Route
                        path="/folders/:folderId"
                        element={<FoldersPage />}
                    />
                    <Route path="/deleted" element={<DeletedFilesPage />} />
                    <Route
                        path="/duplicates"
                        element={<DuplicateFilesPage />}
                    />
                </Routes>
            </MainLayout>

            {/* 複数プレイヤーコンテナ */}
            {openPlayers.length > 0 && (
                <MultiPlayerContainer players={openPlayers} />
            )}

            {/* グローバルコンポーネント */}
            <ContextMenu />
            <NotificationSnackbar />
            <LoadingOverlay />
        </Box>
    );
}

export default App;

```

```frontend/src/assets/react.svg
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="35.93" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 228"><path fill="#00D8FF" d="M210.483 73.824a171.49 171.49 0 0 0-8.24-2.597c.465-1.9.893-3.777 1.273-5.621c6.238-30.281 2.16-54.676-11.769-62.708c-13.355-7.7-35.196.329-57.254 19.526a171.23 171.23 0 0 0-6.375 5.848a155.866 155.866 0 0 0-4.241-3.917C100.759 3.829 77.587-4.822 63.673 3.233C50.33 10.957 46.379 33.89 51.995 62.588a170.974 170.974 0 0 0 1.892 8.48c-3.28.932-6.445 1.924-9.474 2.98C17.309 83.498 0 98.307 0 113.668c0 15.865 18.582 31.778 46.812 41.427a145.52 145.52 0 0 0 6.921 2.165a167.467 167.467 0 0 0-2.01 9.138c-5.354 28.2-1.173 50.591 12.134 58.266c13.744 7.926 36.812-.22 59.273-19.855a145.567 145.567 0 0 0 5.342-4.923a168.064 168.064 0 0 0 6.92 6.314c21.758 18.722 43.246 26.282 56.54 18.586c13.731-7.949 18.194-32.003 12.4-61.268a145.016 145.016 0 0 0-1.535-6.842c1.62-.48 3.21-.974 4.76-1.488c29.348-9.723 48.443-25.443 48.443-41.52c0-15.417-17.868-30.326-45.517-39.844Zm-6.365 70.984c-1.4.463-2.836.91-4.3 1.345c-3.24-10.257-7.612-21.163-12.963-32.432c5.106-11 9.31-21.767 12.459-31.957c2.619.758 5.16 1.557 7.61 2.4c23.69 8.156 38.14 20.213 38.14 29.504c0 9.896-15.606 22.743-40.946 31.14Zm-10.514 20.834c2.562 12.94 2.927 24.64 1.23 33.787c-1.524 8.219-4.59 13.698-8.382 15.893c-8.067 4.67-25.32-1.4-43.927-17.412a156.726 156.726 0 0 1-6.437-5.87c7.214-7.889 14.423-17.06 21.459-27.246c12.376-1.098 24.068-2.894 34.671-5.345a134.17 134.17 0 0 1 1.386 6.193ZM87.276 214.515c-7.882 2.783-14.16 2.863-17.955.675c-8.075-4.657-11.432-22.636-6.853-46.752a156.923 156.923 0 0 1 1.869-8.499c10.486 2.32 22.093 3.988 34.498 4.994c7.084 9.967 14.501 19.128 21.976 27.15a134.668 134.668 0 0 1-4.877 4.492c-9.933 8.682-19.886 14.842-28.658 17.94ZM50.35 144.747c-12.483-4.267-22.792-9.812-29.858-15.863c-6.35-5.437-9.555-10.836-9.555-15.216c0-9.322 13.897-21.212 37.076-29.293c2.813-.98 5.757-1.905 8.812-2.773c3.204 10.42 7.406 21.315 12.477 32.332c-5.137 11.18-9.399 22.249-12.634 32.792a134.718 134.718 0 0 1-6.318-1.979Zm12.378-84.26c-4.811-24.587-1.616-43.134 6.425-47.789c8.564-4.958 27.502 2.111 47.463 19.835a144.318 144.318 0 0 1 3.841 3.545c-7.438 7.987-14.787 17.08-21.808 26.988c-12.04 1.116-23.565 2.908-34.161 5.309a160.342 160.342 0 0 1-1.76-7.887Zm110.427 27.268a347.8 347.8 0 0 0-7.785-12.803c8.168 1.033 15.994 2.404 23.343 4.08c-2.206 7.072-4.956 14.465-8.193 22.045a381.151 381.151 0 0 0-7.365-13.322Zm-45.032-43.861c5.044 5.465 10.096 11.566 15.065 18.186a322.04 322.04 0 0 0-30.257-.006c4.974-6.559 10.069-12.652 15.192-18.18ZM82.802 87.83a323.167 323.167 0 0 0-7.227 13.238c-3.184-7.553-5.909-14.98-8.134-22.152c7.304-1.634 15.093-2.97 23.209-3.984a321.524 321.524 0 0 0-7.848 12.897Zm8.081 65.352c-8.385-.936-16.291-2.203-23.593-3.793c2.26-7.3 5.045-14.885 8.298-22.6a321.187 321.187 0 0 0 7.257 13.246c2.594 4.48 5.28 8.868 8.038 13.147Zm37.542 31.03c-5.184-5.592-10.354-11.779-15.403-18.433c4.902.192 9.899.29 14.978.29c5.218 0 10.376-.117 15.453-.343c-4.985 6.774-10.018 12.97-15.028 18.486Zm52.198-57.817c3.422 7.8 6.306 15.345 8.596 22.52c-7.422 1.694-15.436 3.058-23.88 4.071a382.417 382.417 0 0 0 7.859-13.026a347.403 347.403 0 0 0 7.425-13.565Zm-16.898 8.101a358.557 358.557 0 0 1-12.281 19.815a329.4 329.4 0 0 1-23.444.823c-7.967 0-15.716-.248-23.178-.732a310.202 310.202 0 0 1-12.513-19.846h.001a307.41 307.41 0 0 1-10.923-20.627a310.278 310.278 0 0 1 10.89-20.637l-.001.001a307.318 307.318 0 0 1 12.413-19.761c7.613-.576 15.42-.876 23.31-.876H128c7.926 0 15.743.303 23.354.883a329.357 329.357 0 0 1 12.335 19.695a358.489 358.489 0 0 1 11.036 20.54a329.472 329.472 0 0 1-11 20.722Zm22.56-122.124c8.572 4.944 11.906 24.881 6.52 51.026c-.344 1.668-.73 3.367-1.15 5.09c-10.622-2.452-22.155-4.275-34.23-5.408c-7.034-10.017-14.323-19.124-21.64-27.008a160.789 160.789 0 0 1 5.888-5.4c18.9-16.447 36.564-22.941 44.612-18.3ZM128 90.808c12.625 0 22.86 10.235 22.86 22.86s-10.235 22.86-22.86 22.86s-22.86-10.235-22.86-22.86s10.235-22.86 22.86-22.86Z"></path></svg>
```

```frontend/src/components/common/ContextMenu.jsx
import React, { useState } from "react";
import { useAtom } from "jotai";
import { useLocation } from "react-router-dom";
import {
    Menu,
    MenuItem,
    ListItemIcon,
    ListItemText,
    Divider,
    Dialog,
    DialogTitle,
    DialogContent,
    DialogActions,
    Button,
    List,
    ListItem,
    ListItemButton,
    Checkbox,
    Typography,
} from "@mui/material";
import {
    DriveFileMove as MoveIcon,
    FileCopy as CopyIcon,
    Delete as DeleteIcon,
    DeleteForever as DeleteForeverIcon,
    Restore as RestoreIcon,
    Label as TagIcon,
    Folder as FolderIcon,
    Edit as EditIcon,
    Info as InfoIcon,
} from "@mui/icons-material";

import {
    contextMenuAtom,
    notificationAtom,
    folderActionModeAtom,
    selectedFilesAtom,
} from "@store/atoms";
import { fileAPI, folderAPI } from "@services/api";

function ContextMenu() {
    const location = useLocation();
    const [contextMenu, setContextMenu] = useAtom(contextMenuAtom);
    const [, setNotification] = useAtom(notificationAtom);
    const [, setFolderActionMode] = useAtom(folderActionModeAtom);
    const [selectedFiles] = useAtom(selectedFilesAtom);

    const [folderSelectDialog, setFolderSelectDialog] = useState(false);
    const [tagDialog, setTagDialog] = useState(false);
    const [selectedFolderId, setSelectedFolderId] = useState(null);
    const [folders, setFolders] = useState([]);
    const [actionType, setActionType] = useState(null);

    const handleClose = () => {
        setContextMenu({ open: false, x: 0, y: 0, file: null, type: null });
    };

    // フォルダへ移動/コピー
    const handleFolderAction = async (action) => {
        setActionType(action);

        // フォルダ一覧を取得
        try {
            const response = await folderAPI.getFolderTree();
            setFolders(response);
            setFolderSelectDialog(true);
        } catch (error) {
            setNotification({
                open: true,
                message: "フォルダの取得に失敗しました",
                severity: "error",
            });
        }
        handleClose();
    };

    // フォルダ選択確定
    const handleFolderSelect = async () => {
        if (!selectedFolderId) return;

        const targetFiles =
            selectedFiles.length > 0 ? selectedFiles : [contextMenu.file];

        if (actionType === "move" || actionType === "copy") {
            setFolderActionMode({
                active: true,
                action: actionType,
                files: targetFiles,
            });

            // フォルダページへ遷移
            window.location.href = `/folders/${selectedFolderId}`;
        }

        setFolderSelectDialog(false);
        setSelectedFolderId(null);
    };

    // ファイル削除（フォルダから）
    const handleRemoveFromFolder = async () => {
        const targetFiles =
            selectedFiles.length > 0 ? selectedFiles : [contextMenu.file];
        const currentFolderId = location.pathname.split("/").pop();

        try {
            for (const file of targetFiles) {
                await fileAPI.removeFromFolder(file.id, currentFolderId);
            }

            setNotification({
                open: true,
                message: `${targetFiles.length}個のファイルをフォルダから削除しました`,
                severity: "success",
            });

            // ページをリロード
            window.location.reload();
        } catch (error) {
            setNotification({
                open: true,
                message: "フォルダからの削除に失敗しました",
                severity: "error",
            });
        }
        handleClose();
    };

    // delete_flagを付与
    const handleMarkAsDeleted = async () => {
        const targetFiles =
            selectedFiles.length > 0 ? selectedFiles : [contextMenu.file];

        try {
            await fileAPI.bulkAction({
                file_ids: targetFiles.map((f) => f.id),
                action: "delete",
            });

            setNotification({
                open: true,
                message: `${targetFiles.length}個のファイルを削除しました`,
                severity: "success",
            });

            // ページをリロード
            window.location.reload();
        } catch (error) {
            setNotification({
                open: true,
                message: "削除に失敗しました",
                severity: "error",
            });
        }
        handleClose();
    };

    // ファイル復元
    const handleRestore = async () => {
        const targetFiles =
            selectedFiles.length > 0 ? selectedFiles : [contextMenu.file];

        try {
            await fileAPI.bulkAction({
                file_ids: targetFiles.map((f) => f.id),
                action: "restore",
            });

            setNotification({
                open: true,
                message: `${targetFiles.length}個のファイルを復元しました`,
                severity: "success",
            });

            // ページをリロード
            window.location.reload();
        } catch (error) {
            setNotification({
                open: true,
                message: "復元に失敗しました",
                severity: "error",
            });
        }
        handleClose();
    };

    // タグ追加
    const handleAddTags = () => {
        setTagDialog(true);
        handleClose();
    };

    // メニュー項目の判定
    const getMenuItems = () => {
        const items = [];
        const isDeletedPage = location.pathname === "/deleted";
        const isFolderPage = location.pathname.startsWith("/folders");

        if (isFolderPage && location.pathname !== "/folders") {
            items.push({
                icon: <MoveIcon />,
                text: "フォルダへ移動",
                onClick: () => handleFolderAction("move"),
            });
        }

        if (!isDeletedPage) {
            items.push({
                icon: <CopyIcon />,
                text: "フォルダへコピー",
                onClick: () => handleFolderAction("copy"),
            });
        }

        if (isFolderPage && location.pathname !== "/folders") {
            items.push({
                icon: <DeleteIcon />,
                text: "フォルダから削除",
                onClick: handleRemoveFromFolder,
            });
        }

        if (!isDeletedPage) {
            items.push(
                { divider: true },
                {
                    icon: <DeleteIcon />,
                    text: "ファイルを削除",
                    onClick: handleMarkAsDeleted,
                }
            );
        }

        items.push({
            icon: <TagIcon />,
            text: "タグを追加",
            onClick: handleAddTags,
        });

        if (isDeletedPage) {
            items.push(
                { divider: true },
                {
                    icon: <RestoreIcon />,
                    text: "ファイルを復元",
                    onClick: handleRestore,
                }
            );
        }

        return items;
    };

    return (
        <>
            <Menu
                open={contextMenu.open}
                onClose={handleClose}
                anchorReference="anchorPosition"
                anchorPosition={
                    contextMenu.open
                        ? { top: contextMenu.y, left: contextMenu.x }
                        : undefined
                }
            >
                {getMenuItems().map((item, index) => {
                    if (item.divider) {
                        return <Divider key={`divider-${index}`} />;
                    }
                    return (
                        <MenuItem key={index} onClick={item.onClick}>
                            <ListItemIcon>{item.icon}</ListItemIcon>
                            <ListItemText>{item.text}</ListItemText>
                        </MenuItem>
                    );
                })}
            </Menu>

            {/* フォルダ選択ダイアログ */}
            <Dialog
                open={folderSelectDialog}
                onClose={() => setFolderSelectDialog(false)}
                maxWidth="sm"
                fullWidth
            >
                <DialogTitle>
                    {actionType === "move"
                        ? "フォルダへ移動"
                        : "フォルダへコピー"}
                </DialogTitle>
                <DialogContent>
                    <List>
                        {folders.map((folder) => (
                            <ListItem key={folder.id} disablePadding>
                                <ListItemButton
                                    selected={selectedFolderId === folder.id}
                                    onClick={() =>
                                        setSelectedFolderId(folder.id)
                                    }
                                >
                                    <ListItemIcon>
                                        <FolderIcon />
                                    </ListItemIcon>
                                    <ListItemText
                                        primary={folder.folder_name}
                                        secondary={`${
                                            folder.files_count || 0
                                        } ファイル`}
                                    />
                                </ListItemButton>
                            </ListItem>
                        ))}
                    </List>
                </DialogContent>
                <DialogActions>
                    <Button onClick={() => setFolderSelectDialog(false)}>
                        キャンセル
                    </Button>
                    <Button
                        onClick={handleFolderSelect}
                        variant="contained"
                        disabled={!selectedFolderId}
                    >
                        {actionType === "move" ? "移動" : "コピー"}
                    </Button>
                </DialogActions>
            </Dialog>

            {/* タグ追加ダイアログ（簡略版） */}
            <Dialog
                open={tagDialog}
                onClose={() => setTagDialog(false)}
                maxWidth="sm"
                fullWidth
            >
                <DialogTitle>タグを追加</DialogTitle>
                <DialogContent>
                    {/* タグ追加UIを実装 */}
                    <Typography>タグ追加機能は後で実装します</Typography>
                </DialogContent>
                <DialogActions>
                    <Button onClick={() => setTagDialog(false)}>閉じる</Button>
                </DialogActions>
            </Dialog>
        </>
    );
}

export default ContextMenu;

```

```frontend/src/components/common/LoadingOverlay.jsx
import React from "react";
import { useAtom } from "jotai";
import { Backdrop, CircularProgress, Box, Typography } from "@mui/material";

import { loadingAtom } from "@store/atoms";

function LoadingOverlay() {
    const [loading] = useAtom(loadingAtom);

    return (
        <Backdrop
            sx={{
                color: "#fff",
                zIndex: (theme) => theme.zIndex.drawer + 1000,
                backdropFilter: "blur(3px)",
            }}
            open={loading}
        >
            <Box sx={{ textAlign: "center" }}>
                <CircularProgress color="inherit" size={60} />
                <Typography variant="h6" sx={{ mt: 2 }}>
                    処理中...
                </Typography>
            </Box>
        </Backdrop>
    );
}

export default LoadingOverlay;

```

```frontend/src/components/common/MultiSelectToggle.jsx
import React from "react";
import { useAtom } from "jotai";
import { IconButton, Tooltip, Badge } from "@mui/material";
import {
    CheckBox as SelectIcon,
    CheckBoxOutlineBlank as UnselectIcon,
} from "@mui/icons-material";

import { multiSelectModeAtom, selectedFilesAtom } from "@store/atoms";

function MultiSelectToggle() {
    const [multiSelectMode, setMultiSelectMode] = useAtom(multiSelectModeAtom);
    const [selectedFiles, setSelectedFiles] = useAtom(selectedFilesAtom);

    const handleToggle = () => {
        setMultiSelectMode(!multiSelectMode);
        if (multiSelectMode) {
            // 複数選択モードを解除する時は選択もクリア
            setSelectedFiles([]);
        }
    };

    return (
        <Tooltip
            title={multiSelectMode ? "複数選択モードを解除" : "複数選択モード"}
        >
            <IconButton
                onClick={handleToggle}
                color={multiSelectMode ? "primary" : "inherit"}
                sx={{
                    bgcolor: multiSelectMode
                        ? "action.selected"
                        : "transparent",
                }}
            >
                <Badge badgeContent={selectedFiles.length} color="error">
                    {multiSelectMode ? <SelectIcon /> : <UnselectIcon />}
                </Badge>
            </IconButton>
        </Tooltip>
    );
}

export default MultiSelectToggle;

```

```frontend/src/components/common/NotificationSnackbar.jsx
import React from "react";
import { useAtom } from "jotai";
import { Snackbar, Alert, Slide } from "@mui/material";

import { notificationAtom } from "@store/atoms";

function SlideTransition(props) {
    return <Slide {...props} direction="up" />;
}

function NotificationSnackbar() {
    const [notification, setNotification] = useAtom(notificationAtom);

    const handleClose = (event, reason) => {
        if (reason === "clickaway") {
            return;
        }
        setNotification((prev) => ({ ...prev, open: false }));
    };

    return (
        <Snackbar
            open={notification.open}
            autoHideDuration={6000}
            onClose={handleClose}
            TransitionComponent={SlideTransition}
            anchorOrigin={{ vertical: "bottom", horizontal: "center" }}
        >
            <Alert
                onClose={handleClose}
                severity={notification.severity}
                variant="filled"
                sx={{ width: "100%" }}
            >
                {notification.message}
            </Alert>
        </Snackbar>
    );
}

export default NotificationSnackbar;

```

```frontend/src/components/common/SearchBar.jsx
import React, { useState, useRef, useEffect } from "react";
import { useAtom } from "jotai";
import {
    Box,
    TextField,
    InputAdornment,
    IconButton,
    Chip,
    Autocomplete,
    Paper,
    Popper,
} from "@mui/material";
import {
    Search as SearchIcon,
    Close as CloseIcon,
    Clear as ClearIcon,
} from "@mui/icons-material";

import { searchQueryAtom, tagsListAtom } from "@store/atoms";
import { tagAPI } from "@services/api";

function SearchBar({ onClose }) {
    const [searchQuery, setSearchQuery] = useAtom(searchQueryAtom);
    const [tagsList, setTagsList] = useAtom(tagsListAtom);

    const [inputValue, setInputValue] = useState(searchQuery);
    const [suggestions, setSuggestions] = useState([]);
    const [showSuggestions, setShowSuggestions] = useState(false);
    const inputRef = useRef(null);

    // 初回フォーカス
    useEffect(() => {
        inputRef.current?.focus();
    }, []);

    // タグ候補の取得
    useEffect(() => {
        const fetchTags = async () => {
            try {
                const tags = await tagAPI.getPopularTags(20);
                setTagsList(tags);
            } catch (error) {
                console.error("Failed to fetch tags:", error);
            }
        };

        if (tagsList.length === 0) {
            fetchTags();
        }
    }, [tagsList.length, setTagsList]);

    // 検索実行
    const handleSearch = () => {
        setSearchQuery(inputValue);
        setShowSuggestions(false);
    };

    // クリア
    const handleClear = () => {
        setInputValue("");
        setSearchQuery("");
        inputRef.current?.focus();
    };

    // キーボードショートカット
    const handleKeyDown = (e) => {
        if (e.key === "Enter") {
            handleSearch();
        } else if (e.key === "Escape") {
            if (inputValue) {
                handleClear();
            } else {
                onClose?.();
            }
        }
    };

    // 検索候補の生成
    const generateSuggestions = (value) => {
        if (!value) {
            setSuggestions([]);
            return;
        }

        const lowerValue = value.toLowerCase();
        const tagSuggestions = tagsList
            .filter((tag) => tag.tag_name.toLowerCase().includes(lowerValue))
            .slice(0, 5)
            .map((tag) => ({
                type: "tag",
                label: tag.tag_name,
                value: `tag:${tag.tag_name}`,
            }));

        const searchSuggestions = [
            { type: "search", label: `"${value}"を検索`, value },
        ];

        setSuggestions([...searchSuggestions, ...tagSuggestions]);
    };

    // 入力変更
    const handleInputChange = (e) => {
        const value = e.target.value;
        setInputValue(value);
        generateSuggestions(value);
        setShowSuggestions(true);
    };

    // 候補選択
    const handleSuggestionClick = (suggestion) => {
        setInputValue(suggestion.value);
        setSearchQuery(suggestion.value);
        setShowSuggestions(false);
    };

    return (
        <Box sx={{ position: "relative", width: "100%", maxWidth: 600 }}>
            <TextField
                ref={inputRef}
                fullWidth
                value={inputValue}
                onChange={handleInputChange}
                onKeyDown={handleKeyDown}
                onFocus={() => setShowSuggestions(true)}
                placeholder="ファイル名やタグで検索..."
                variant="outlined"
                size="small"
                sx={{
                    bgcolor: "background.paper",
                    "& .MuiOutlinedInput-root": {
                        "& fieldset": {
                            borderColor: "primary.main",
                        },
                    },
                }}
                InputProps={{
                    startAdornment: (
                        <InputAdornment position="start">
                            <SearchIcon />
                        </InputAdornment>
                    ),
                    endAdornment: (
                        <InputAdornment position="end">
                            {inputValue && (
                                <IconButton size="small" onClick={handleClear}>
                                    <ClearIcon />
                                </IconButton>
                            )}
                            {onClose && (
                                <IconButton size="small" onClick={onClose}>
                                    <CloseIcon />
                                </IconButton>
                            )}
                        </InputAdornment>
                    ),
                }}
            />

            {/* 検索候補 */}
            {showSuggestions && suggestions.length > 0 && (
                <Paper
                    sx={{
                        position: "absolute",
                        top: "100%",
                        left: 0,
                        right: 0,
                        mt: 0.5,
                        maxHeight: 300,
                        overflow: "auto",
                        zIndex: 1300,
                    }}
                    elevation={3}
                >
                    {suggestions.map((suggestion, index) => (
                        <Box
                            key={index}
                            sx={{
                                p: 1.5,
                                cursor: "pointer",
                                "&:hover": {
                                    bgcolor: "action.hover",
                                },
                                display: "flex",
                                alignItems: "center",
                                gap: 1,
                            }}
                            onClick={() => handleSuggestionClick(suggestion)}
                        >
                            {suggestion.type === "tag" && (
                                <Chip
                                    label="タグ"
                                    size="small"
                                    color="primary"
                                    variant="outlined"
                                />
                            )}
                            {suggestion.label}
                        </Box>
                    ))}
                </Paper>
            )}
        </Box>
    );
}

export default SearchBar;

```

```frontend/src/components/common/ViewToggle.jsx
import React from "react";
import { useAtom } from "jotai";
import { ToggleButton, ToggleButtonGroup, Tooltip } from "@mui/material";
import {
    ViewModule as ThumbnailIcon,
    ViewList as ListIcon,
} from "@mui/icons-material";

import { viewModeAtom } from "@store/atoms";

function ViewToggle() {
    const [viewMode, setViewMode] = useAtom(viewModeAtom);

    const handleChange = (event, newMode) => {
        if (newMode !== null) {
            setViewMode(newMode);
        }
    };

    return (
        <ToggleButtonGroup
            value={viewMode}
            exclusive
            onChange={handleChange}
            size="small"
            sx={{
                bgcolor: "background.paper",
                "& .MuiToggleButton-root": {
                    color: "text.secondary",
                    "&.Mui-selected": {
                        color: "primary.main",
                        bgcolor: "action.selected",
                    },
                },
            }}
        >
            <ToggleButton value="thumbnail">
                <Tooltip title="サムネイル表示">
                    <ThumbnailIcon />
                </Tooltip>
            </ToggleButton>
            <ToggleButton value="list">
                <Tooltip title="詳細表示">
                    <ListIcon />
                </Tooltip>
            </ToggleButton>
        </ToggleButtonGroup>
    );
}

export default ViewToggle;

```

```frontend/src/components/dialogs/SettingsDialog.jsx
import React, { useState } from "react";
import { useAtom } from "jotai";
import {
    Dialog,
    DialogTitle,
    DialogContent,
    DialogActions,
    Button,
    Tabs,
    Tab,
    Box,
    FormControl,
    FormLabel,
    RadioGroup,
    FormControlLabel,
    Radio,
    Slider,
    Switch,
    TextField,
    Typography,
    Divider,
    List,
    ListItem,
    ListItemText,
    ListItemSecondaryAction,
    Select,
    MenuItem,
    InputLabel,
} from "@mui/material";

import {
    displaySettingsAtom,
    playerSettingsAtom,
    keyboardShortcutsAtom,
} from "@store/atoms";
import { getShortcutHelp } from "@utils/keyboard";

function TabPanel({ children, value, index, ...other }) {
    return (
        <div
            role="tabpanel"
            hidden={value !== index}
            id={`settings-tabpanel-${index}`}
            aria-labelledby={`settings-tab-${index}`}
            {...other}
        >
            {value === index && <Box sx={{ p: 3 }}>{children}</Box>}
        </div>
    );
}

function SettingsDialog({ open, onClose }) {
    const [tabValue, setTabValue] = useState(0);
    const [displaySettings, setDisplaySettings] = useAtom(displaySettingsAtom);
    const [playerSettings, setPlayerSettings] = useAtom(playerSettingsAtom);
    const [keyboardShortcuts, setKeyboardShortcuts] = useAtom(
        keyboardShortcutsAtom
    );

    const handleTabChange = (event, newValue) => {
        setTabValue(newValue);
    };

    const handleDisplaySettingChange = (key, value) => {
        setDisplaySettings((prev) => ({ ...prev, [key]: value }));
    };

    const handlePlayerSettingChange = (key, value) => {
        setPlayerSettings((prev) => ({ ...prev, [key]: value }));
    };

    const handleKeyboardShortcutChange = (key, value) => {
        setKeyboardShortcuts((prev) => ({ ...prev, [key]: value }));
    };

    const shortcuts = getShortcutHelp();

    return (
        <Dialog
            open={open}
            onClose={onClose}
            maxWidth="md"
            fullWidth
            PaperProps={{
                sx: { height: "80vh" },
            }}
        >
            <DialogTitle>設定</DialogTitle>
            <DialogContent dividers>
                <Tabs value={tabValue} onChange={handleTabChange}>
                    <Tab label="表示" />
                    <Tab label="プレイヤー" />
                    <Tab label="キーボード" />
                    <Tab label="詳細" />
                </Tabs>

                {/* 表示設定 */}
                <TabPanel value={tabValue} index={0}>
                    <List>
                        <ListItem>
                            <ListItemText
                                primary="サムネイルサイズ"
                                secondary="グリッド表示時のサムネイルサイズ"
                            />
                            <ListItemSecondaryAction>
                                <FormControl
                                    variant="outlined"
                                    size="small"
                                    sx={{ minWidth: 120 }}
                                >
                                    <Select
                                        value={displaySettings.thumbnailSize}
                                        onChange={(e) =>
                                            handleDisplaySettingChange(
                                                "thumbnailSize",
                                                e.target.value
                                            )
                                        }
                                    >
                                        <MenuItem value="small">小</MenuItem>
                                        <MenuItem value="medium">中</MenuItem>
                                        <MenuItem value="large">大</MenuItem>
                                    </Select>
                                </FormControl>
                            </ListItemSecondaryAction>
                        </ListItem>

                        <ListItem>
                            <ListItemText
                                primary="ファイル情報表示"
                                secondary="サムネイル下にファイル名とサイズを表示"
                            />
                            <ListItemSecondaryAction>
                                <Switch
                                    checked={displaySettings.showFileInfo}
                                    onChange={(e) =>
                                        handleDisplaySettingChange(
                                            "showFileInfo",
                                            e.target.checked
                                        )
                                    }
                                />
                            </ListItemSecondaryAction>
                        </ListItem>

                        <ListItem>
                            <ListItemText
                                primary="アニメーションサムネイル"
                                secondary="GIFサムネイルをアニメーション表示"
                            />
                            <ListItemSecondaryAction>
                                <Switch
                                    checked={displaySettings.animatedThumbnails}
                                    onChange={(e) =>
                                        handleDisplaySettingChange(
                                            "animatedThumbnails",
                                            e.target.checked
                                        )
                                    }
                                />
                            </ListItemSecondaryAction>
                        </ListItem>

                        <ListItem>
                            <ListItemText
                                primary="グリッド列数"
                                secondary="グリッド表示の列数"
                            />
                            <ListItemSecondaryAction>
                                <FormControl
                                    variant="outlined"
                                    size="small"
                                    sx={{ minWidth: 120 }}
                                >
                                    <Select
                                        value={displaySettings.gridColumns}
                                        onChange={(e) =>
                                            handleDisplaySettingChange(
                                                "gridColumns",
                                                e.target.value
                                            )
                                        }
                                    >
                                        <MenuItem value="auto">自動</MenuItem>
                                        <MenuItem value={2}>2列</MenuItem>
                                        <MenuItem value={3}>3列</MenuItem>
                                        <MenuItem value={4}>4列</MenuItem>
                                        <MenuItem value={5}>5列</MenuItem>
                                        <MenuItem value={6}>6列</MenuItem>
                                    </Select>
                                </FormControl>
                            </ListItemSecondaryAction>
                        </ListItem>
                    </List>
                </TabPanel>

                {/* プレイヤー設定 */}
                <TabPanel value={tabValue} index={1}>
                    <List>
                        <ListItem>
                            <ListItemText
                                primary="デフォルト再生速度"
                                secondary={`${playerSettings.playbackSpeed}倍速`}
                            />
                            <Box sx={{ width: 200, ml: 2 }}>
                                <Slider
                                    value={playerSettings.playbackSpeed}
                                    onChange={(e, value) =>
                                        handlePlayerSettingChange(
                                            "playbackSpeed",
                                            value
                                        )
                                    }
                                    min={0.25}
                                    max={5}
                                    step={0.25}
                                    marks
                                    valueLabelDisplay="auto"
                                />
                            </Box>
                        </ListItem>

                        <ListItem>
                            <ListItemText
                                primary="デフォルト音量"
                                secondary={`${Math.round(
                                    playerSettings.volume * 100
                                )}%`}
                            />
                            <Box sx={{ width: 200, ml: 2 }}>
                                <Slider
                                    value={playerSettings.volume}
                                    onChange={(e, value) =>
                                        handlePlayerSettingChange(
                                            "volume",
                                            value
                                        )
                                    }
                                    min={0}
                                    max={1}
                                    step={0.1}
                                    valueLabelDisplay="auto"
                                    valueLabelFormat={(value) =>
                                        `${Math.round(value * 100)}%`
                                    }
                                />
                            </Box>
                        </ListItem>

                        <ListItem>
                            <ListItemText
                                primary="スキップ秒数"
                                secondary="ダブルタップでスキップする秒数"
                            />
                            <Box sx={{ width: 200, ml: 2 }}>
                                <Slider
                                    value={playerSettings.skipSeconds}
                                    onChange={(e, value) =>
                                        handlePlayerSettingChange(
                                            "skipSeconds",
                                            value
                                        )
                                    }
                                    min={5}
                                    max={30}
                                    step={5}
                                    marks
                                    valueLabelDisplay="auto"
                                    valueLabelFormat={(value) => `${value}秒`}
                                />
                            </Box>
                        </ListItem>

                        <ListItem>
                            <ListItemText
                                primary="長押し倍速"
                                secondary="長押し時の再生速度"
                            />
                            <Box sx={{ width: 200, ml: 2 }}>
                                <Slider
                                    value={playerSettings.longPressSpeed}
                                    onChange={(e, value) =>
                                        handlePlayerSettingChange(
                                            "longPressSpeed",
                                            value
                                        )
                                    }
                                    min={1.5}
                                    max={5}
                                    step={0.5}
                                    marks
                                    valueLabelDisplay="auto"
                                    valueLabelFormat={(value) => `${value}倍速`}
                                />
                            </Box>
                        </ListItem>

                        <ListItem>
                            <ListItemText
                                primary="自動再生"
                                secondary="動画を開いた時に自動で再生"
                            />
                            <ListItemSecondaryAction>
                                <Switch
                                    checked={playerSettings.autoPlay}
                                    onChange={(e) =>
                                        handlePlayerSettingChange(
                                            "autoPlay",
                                            e.target.checked
                                        )
                                    }
                                />
                            </ListItemSecondaryAction>
                        </ListItem>

                        <ListItem>
                            <ListItemText
                                primary="ループ再生"
                                secondary="動画を繰り返し再生"
                            />
                            <ListItemSecondaryAction>
                                <Switch
                                    checked={playerSettings.loop}
                                    onChange={(e) =>
                                        handlePlayerSettingChange(
                                            "loop",
                                            e.target.checked
                                        )
                                    }
                                />
                            </ListItemSecondaryAction>
                        </ListItem>

                        <ListItem>
                            <ListItemText
                                primary="アスペクト比"
                                secondary="動画の表示方法"
                            />
                            <ListItemSecondaryAction>
                                <FormControl
                                    variant="outlined"
                                    size="small"
                                    sx={{ minWidth: 120 }}
                                >
                                    <Select
                                        value={playerSettings.aspectRatioFit}
                                        onChange={(e) =>
                                            handlePlayerSettingChange(
                                                "aspectRatioFit",
                                                e.target.value
                                            )
                                        }
                                    >
                                        <MenuItem value="contain">
                                            全体表示
                                        </MenuItem>
                                        <MenuItem value="cover">
                                            画面いっぱい
                                        </MenuItem>
                                    </Select>
                                </FormControl>
                            </ListItemSecondaryAction>
                        </ListItem>
                    </List>
                </TabPanel>

                {/* キーボードショートカット */}
                <TabPanel value={tabValue} index={2}>
                    <Typography variant="h6" gutterBottom>
                        キーボードショートカット一覧
                    </Typography>
                    <List dense>
                        {shortcuts.map((shortcut, index) => (
                            <React.Fragment key={index}>
                                {index > 0 &&
                                    shortcuts[index - 1].category !==
                                        shortcut.category && (
                                        <>
                                            <Divider sx={{ my: 1 }} />
                                            <Typography
                                                variant="subtitle2"
                                                color="text.secondary"
                                                sx={{ mt: 2, mb: 1 }}
                                            >
                                                {shortcut.category}
                                            </Typography>
                                        </>
                                    )}
                                {index === 0 && (
                                    <Typography
                                        variant="subtitle2"
                                        color="text.secondary"
                                        sx={{ mb: 1 }}
                                    >
                                        {shortcut.category}
                                    </Typography>
                                )}
                                <ListItem>
                                    <ListItemText
                                        primary={shortcut.description}
                                        secondary={shortcut.key}
                                        secondaryTypographyProps={{
                                            component: "span",
                                            sx: {
                                                fontFamily: "monospace",
                                                bgcolor: "action.hover",
                                                px: 1,
                                                py: 0.5,
                                                borderRadius: 1,
                                                display: "inline-block",
                                            },
                                        }}
                                    />
                                </ListItem>
                            </React.Fragment>
                        ))}
                    </List>
                </TabPanel>

                {/* 詳細設定 */}
                <TabPanel value={tabValue} index={3}>
                    <Typography variant="h6" gutterBottom>
                        システム情報
                    </Typography>
                    <List>
                        <ListItem>
                            <ListItemText
                                primary="バージョン"
                                secondary="1.0.0"
                            />
                        </ListItem>
                        <ListItem>
                            <ListItemText
                                primary="バックエンドURL"
                                secondary={import.meta.env.VITE_API_URL}
                            />
                        </ListItem>
                        <ListItem>
                            <ListItemText
                                primary="メディアURL"
                                secondary={import.meta.env.VITE_MEDIA_URL}
                            />
                        </ListItem>
                    </List>

                    <Divider sx={{ my: 3 }} />

                    <Typography variant="h6" gutterBottom>
                        データ管理
                    </Typography>
                    <Box sx={{ mt: 2 }}>
                        <Button
                            variant="outlined"
                            onClick={() => {
                                if (
                                    confirm("すべての設定をリセットしますか？")
                                ) {
                                    localStorage.clear();
                                    window.location.reload();
                                }
                            }}
                            color="error"
                        >
                            設定をリセット
                        </Button>
                    </Box>
                </TabPanel>
            </DialogContent>
            <DialogActions>
                <Button onClick={onClose}>閉じる</Button>
            </DialogActions>
        </Dialog>
    );
}

export default SettingsDialog;

```

```frontend/src/components/files/FileGrid.jsx
import React, { useRef, useEffect, useCallback } from "react";
import { useAtom } from "jotai";
import { useInView } from "react-intersection-observer";
import {
    Box,
    Card,
    CardMedia,
    CardContent,
    Typography,
    Checkbox,
    IconButton,
    Skeleton,
    Tooltip,
    Chip,
} from "@mui/material";
import {
    PlayArrow as PlayIcon,
    MoreVert as MoreIcon,
    FileCopy as DuplicateIcon,
} from "@mui/icons-material";

import {
    multiSelectModeAtom,
    displaySettingsAtom,
    isTouchDeviceAtom,
} from "@store/atoms";
import { getThumbnailUrl } from "@services/api";
import { formatFileSize, formatTime, truncateFileName } from "@utils/format";
import { useLongPress } from "use-long-press";

const THUMBNAIL_SIZES = {
    small: { width: 160, height: 90 },
    medium: { width: 240, height: 135 },
    large: { width: 320, height: 180 },
};

function FileGridItem({
    file,
    isSelected,
    onSelect,
    onContextMenu,
    onLongPress,
}) {
    const [multiSelectMode] = useAtom(multiSelectModeAtom);
    const [displaySettings] = useAtom(displaySettingsAtom);
    const [isTouchDevice] = useAtom(isTouchDeviceAtom);

    const thumbnailUrl = getThumbnailUrl(file);
    const size = THUMBNAIL_SIZES[displaySettings.thumbnailSize];

    // 長押し処理
    const bindLongPress = useLongPress(
        (event) => {
            if (onLongPress) {
                onLongPress(event, file);
            }
        },
        {
            threshold: 500,
            captureEvent: true,
            cancelOnMovement: 25,
        }
    );

    const handleClick = useCallback(
        (e) => {
            if (multiSelectMode) {
                e.preventDefault();
                e.stopPropagation();
            }
            onSelect(file);
        },
        [multiSelectMode, file, onSelect]
    );

    const handleContextMenu = useCallback(
        (e) => {
            e.preventDefault();
            onContextMenu(e, file);
        },
        [file, onContextMenu]
    );

    return (
        <Card
            sx={{
                position: "relative",
                cursor: "pointer",
                transition: "all 0.2s",
                "&:hover": {
                    transform: "scale(1.05)",
                    boxShadow: 4,
                    "& .hover-overlay": {
                        opacity: 1,
                    },
                },
                ...(isSelected && {
                    borderColor: "primary.main",
                    borderWidth: 2,
                    borderStyle: "solid",
                }),
            }}
            onClick={handleClick}
            onContextMenu={handleContextMenu}
            {...(isTouchDevice ? bindLongPress() : {})}
        >
            {/* サムネイル */}
            <Box sx={{ position: "relative", paddingTop: "56.25%" }}>
                {thumbnailUrl ? (
                    <CardMedia
                        component={
                            displaySettings.animatedThumbnails ? "img" : "img"
                        }
                        image={thumbnailUrl}
                        alt={file.file_name}
                        sx={{
                            position: "absolute",
                            top: 0,
                            left: 0,
                            width: "100%",
                            height: "100%",
                            objectFit: "cover",
                        }}
                    />
                ) : (
                    <Box
                        sx={{
                            position: "absolute",
                            top: 0,
                            left: 0,
                            width: "100%",
                            height: "100%",
                            bgcolor: "grey.800",
                            display: "flex",
                            alignItems: "center",
                            justifyContent: "center",
                        }}
                    >
                        <PlayIcon sx={{ fontSize: 48, color: "grey.600" }} />
                    </Box>
                )}

                {/* オーバーレイ */}
                <Box
                    className="hover-overlay"
                    sx={{
                        position: "absolute",
                        top: 0,
                        left: 0,
                        right: 0,
                        bottom: 0,
                        background:
                            "linear-gradient(to bottom, transparent 60%, rgba(0,0,0,0.8))",
                        opacity: 0,
                        transition: "opacity 0.2s",
                        display: "flex",
                        alignItems: "flex-end",
                        p: 1,
                    }}
                >
                    {/* 動画時間 */}
                    {file.video_duration && (
                        <Chip
                            label={formatTime(file.video_duration)}
                            size="small"
                            sx={{
                                position: "absolute",
                                bottom: 8,
                                right: 8,
                                bgcolor: "rgba(0,0,0,0.7)",
                                color: "white",
                            }}
                        />
                    )}
                </Box>

                {/* 選択チェックボックス */}
                {multiSelectMode && (
                    <Checkbox
                        checked={isSelected}
                        onClick={(e) => {
                            e.stopPropagation();
                            onSelect(file);
                        }}
                        sx={{
                            position: "absolute",
                            top: 4,
                            left: 4,
                            bgcolor: "rgba(0,0,0,0.5)",
                            "&:hover": {
                                bgcolor: "rgba(0,0,0,0.7)",
                            },
                        }}
                    />
                )}

                {/* フラグ表示 */}
                {file.duplicate_flag && (
                    <Tooltip title="重複ファイル">
                        <DuplicateIcon
                            sx={{
                                position: "absolute",
                                top: 8,
                                right: 8,
                                color: "warning.main",
                                bgcolor: "rgba(0,0,0,0.5)",
                                borderRadius: 1,
                                p: 0.5,
                            }}
                        />
                    </Tooltip>
                )}
            </Box>

            {/* ファイル情報 */}
            {displaySettings.showFileInfo && (
                <CardContent sx={{ p: 1, "&:last-child": { pb: 1 } }}>
                    <Typography variant="body2" noWrap title={file.file_name}>
                        {truncateFileName(file.file_name, 30)}
                    </Typography>
                    <Typography variant="caption" color="text.secondary">
                        {formatFileSize(file.file_size)}
                    </Typography>
                </CardContent>
            )}
        </Card>
    );
}

function FileGrid({
    files,
    selectedFiles,
    onFileSelect,
    onContextMenu,
    onLoadMore,
    hasMore,
    loading,
}) {
    const [displaySettings] = useAtom(displaySettingsAtom);
    const { ref: loadMoreRef, inView } = useInView({
        threshold: 0,
        rootMargin: "100px",
    });

    // 無限スクロール
    useEffect(() => {
        if (inView && hasMore && !loading) {
            onLoadMore();
        }
    }, [inView, hasMore, loading, onLoadMore]);

    // グリッドカラム数の計算
    const getGridColumns = () => {
        if (displaySettings.gridColumns === "auto") {
            const size = THUMBNAIL_SIZES[displaySettings.thumbnailSize];
            return `repeat(auto-fill, minmax(${size.width}px, 1fr))`;
        }
        return `repeat(${displaySettings.gridColumns}, 1fr)`;
    };

    return (
        <Box>
            <Box
                sx={{
                    display: "grid",
                    gridTemplateColumns: getGridColumns(),
                    gap: 2,
                    pb: 2,
                }}
            >
                {files.map((file) => (
                    <FileGridItem
                        key={file.id}
                        file={file}
                        isSelected={selectedFiles.some((f) => f.id === file.id)}
                        onSelect={onFileSelect}
                        onContextMenu={onContextMenu}
                        onLongPress={onContextMenu}
                    />
                ))}
            </Box>

            {/* ローディング表示 */}
            {loading && (
                <Box
                    sx={{
                        display: "grid",
                        gridTemplateColumns: getGridColumns(),
                        gap: 2,
                        mt: 2,
                    }}
                >
                    {[...Array(8)].map((_, index) => (
                        <Card key={`skeleton-${index}`}>
                            <Skeleton
                                variant="rectangular"
                                sx={{ paddingTop: "56.25%" }}
                            />
                            {displaySettings.showFileInfo && (
                                <CardContent sx={{ p: 1 }}>
                                    <Skeleton variant="text" />
                                    <Skeleton variant="text" width="60%" />
                                </CardContent>
                            )}
                        </Card>
                    ))}
                </Box>
            )}

            {/* 無限スクロール用のトリガー */}
            {hasMore && <div ref={loadMoreRef} style={{ height: 1 }} />}
        </Box>
    );
}

export default FileGrid;

```

```frontend/src/components/files/FileList.jsx
import React, { useEffect, useCallback } from "react";
import { useAtom } from "jotai";
import { useInView } from "react-intersection-observer";
import {
    Table,
    TableBody,
    TableCell,
    TableContainer,
    TableHead,
    TableRow,
    Paper,
    Checkbox,
    IconButton,
    Chip,
    Box,
    Skeleton,
    Typography,
} from "@mui/material";
import {
    PlayArrow as PlayIcon,
    Folder as FolderIcon,
    Label as TagIcon,
    FileCopy as DuplicateIcon,
} from "@mui/icons-material";

import { multiSelectModeAtom, sortSettingsAtom } from "@store/atoms";
import { getThumbnailUrl } from "@services/api";
import {
    formatFileSize,
    formatTime,
    formatDateTime,
    truncateFileName,
} from "@utils/format";

function FileListRow({ file, isSelected, onSelect, onContextMenu }) {
    const [multiSelectMode] = useAtom(multiSelectModeAtom);
    const thumbnailUrl = getThumbnailUrl(file);

    const handleClick = useCallback(
        (e) => {
            if (multiSelectMode) {
                e.preventDefault();
                e.stopPropagation();
            }
            onSelect(file);
        },
        [multiSelectMode, file, onSelect]
    );

    const handleContextMenu = useCallback(
        (e) => {
            e.preventDefault();
            onContextMenu(e, file);
        },
        [file, onContextMenu]
    );

    return (
        <TableRow
            hover
            selected={isSelected}
            onClick={handleClick}
            onContextMenu={handleContextMenu}
            sx={{
                cursor: "pointer",
                "&:hover": {
                    bgcolor: "action.hover",
                },
            }}
        >
            {/* 選択チェックボックス */}
            {multiSelectMode && (
                <TableCell padding="checkbox">
                    <Checkbox
                        checked={isSelected}
                        onClick={(e) => {
                            e.stopPropagation();
                            onSelect(file);
                        }}
                    />
                </TableCell>
            )}

            {/* サムネイル */}
            <TableCell sx={{ width: 100, p: 1 }}>
                <Box
                    sx={{
                        width: 80,
                        height: 45,
                        position: "relative",
                        bgcolor: "grey.800",
                        borderRadius: 1,
                        overflow: "hidden",
                    }}
                >
                    {thumbnailUrl ? (
                        <img
                            src={thumbnailUrl}
                            alt={file.file_name}
                            style={{
                                width: "100%",
                                height: "100%",
                                objectFit: "cover",
                            }}
                        />
                    ) : (
                        <Box
                            sx={{
                                width: "100%",
                                height: "100%",
                                display: "flex",
                                alignItems: "center",
                                justifyContent: "center",
                            }}
                        >
                            <PlayIcon sx={{ color: "grey.600" }} />
                        </Box>
                    )}
                </Box>
            </TableCell>

            {/* ファイル名 */}
            <TableCell>
                <Box sx={{ display: "flex", alignItems: "center", gap: 1 }}>
                    <Typography variant="body2" title={file.file_name}>
                        {truncateFileName(file.file_name, 50)}
                    </Typography>
                    {file.duplicate_flag && (
                        <Chip
                            icon={<DuplicateIcon />}
                            label="重複"
                            size="small"
                            color="warning"
                            variant="outlined"
                        />
                    )}
                </Box>
            </TableCell>

            {/* サイズ */}
            <TableCell align="right" sx={{ width: 100 }}>
                {formatFileSize(file.file_size)}
            </TableCell>

            {/* 動画時間 */}
            <TableCell align="right" sx={{ width: 80 }}>
                {file.video_duration ? formatTime(file.video_duration) : "-"}
            </TableCell>

            {/* フォルダ */}
            <TableCell sx={{ width: 150 }}>
                {file.folder_ids && file.folder_ids.length > 0 ? (
                    <Box sx={{ display: "flex", gap: 0.5 }}>
                        <FolderIcon fontSize="small" color="action" />
                        <Typography variant="caption">
                            {file.folder_ids.length}個
                        </Typography>
                    </Box>
                ) : (
                    <Typography variant="caption" color="text.secondary">
                        なし
                    </Typography>
                )}
            </TableCell>

            {/* タグ */}
            <TableCell sx={{ width: 200 }}>
                {file.tag_names && file.tag_names.length > 0 ? (
                    <Box sx={{ display: "flex", gap: 0.5, flexWrap: "wrap" }}>
                        {file.tag_names.slice(0, 3).map((tag, index) => (
                            <Chip
                                key={index}
                                label={tag}
                                size="small"
                                variant="outlined"
                            />
                        ))}
                        {file.tag_names.length > 3 && (
                            <Chip
                                label={`+${file.tag_names.length - 3}`}
                                size="small"
                                variant="outlined"
                            />
                        )}
                    </Box>
                ) : (
                    <Typography variant="caption" color="text.secondary">
                        なし
                    </Typography>
                )}
            </TableCell>

            {/* 作成日時 */}
            <TableCell align="right" sx={{ width: 150 }}>
                <Typography variant="caption">
                    {formatDateTime(file.created_at)}
                </Typography>
            </TableCell>
        </TableRow>
    );
}

function FileList({
    files,
    selectedFiles,
    onFileSelect,
    onContextMenu,
    onLoadMore,
    hasMore,
    loading,
}) {
    const [multiSelectMode] = useAtom(multiSelectModeAtom);
    const [sortSettings, setSortSettings] = useAtom(sortSettingsAtom);
    const { ref: loadMoreRef, inView } = useInView({
        threshold: 0,
        rootMargin: "100px",
    });

    // 無限スクロール
    useEffect(() => {
        if (inView && hasMore && !loading) {
            onLoadMore();
        }
    }, [inView, hasMore, loading, onLoadMore]);

    // ソート処理
    const handleSort = (field) => {
        setSortSettings((prev) => ({
            field,
            order:
                prev.field === field && prev.order === "asc" ? "desc" : "asc",
        }));
    };

    // 全選択
    const handleSelectAll = () => {
        if (selectedFiles.length === files.length) {
            onFileSelect([]);
        } else {
            files.forEach((file) => onFileSelect(file));
        }
    };

    return (
        <TableContainer component={Paper}>
            <Table stickyHeader>
                <TableHead>
                    <TableRow>
                        {multiSelectMode && (
                            <TableCell padding="checkbox">
                                <Checkbox
                                    indeterminate={
                                        selectedFiles.length > 0 &&
                                        selectedFiles.length < files.length
                                    }
                                    checked={
                                        files.length > 0 &&
                                        selectedFiles.length === files.length
                                    }
                                    onChange={handleSelectAll}
                                />
                            </TableCell>
                        )}
                        <TableCell>サムネイル</TableCell>
                        <TableCell
                            onClick={() => handleSort("file_name")}
                            sx={{
                                cursor: "pointer",
                                "&:hover": { bgcolor: "action.hover" },
                            }}
                        >
                            ファイル名
                            {sortSettings.field === "file_name" && (
                                <span>
                                    {sortSettings.order === "asc" ? " ▲" : " ▼"}
                                </span>
                            )}
                        </TableCell>
                        <TableCell
                            align="right"
                            onClick={() => handleSort("file_size")}
                            sx={{
                                cursor: "pointer",
                                "&:hover": { bgcolor: "action.hover" },
                            }}
                        >
                            サイズ
                            {sortSettings.field === "file_size" && (
                                <span>
                                    {sortSettings.order === "asc" ? " ▲" : " ▼"}
                                </span>
                            )}
                        </TableCell>
                        <TableCell
                            align="right"
                            onClick={() => handleSort("video_duration")}
                            sx={{
                                cursor: "pointer",
                                "&:hover": { bgcolor: "action.hover" },
                            }}
                        >
                            時間
                            {sortSettings.field === "video_duration" && (
                                <span>
                                    {sortSettings.order === "asc" ? " ▲" : " ▼"}
                                </span>
                            )}
                        </TableCell>
                        <TableCell>フォルダ</TableCell>
                        <TableCell>タグ</TableCell>
                        <TableCell
                            align="right"
                            onClick={() => handleSort("created_at")}
                            sx={{
                                cursor: "pointer",
                                "&:hover": { bgcolor: "action.hover" },
                            }}
                        >
                            作成日時
                            {sortSettings.field === "created_at" && (
                                <span>
                                    {sortSettings.order === "asc" ? " ▲" : " ▼"}
                                </span>
                            )}
                        </TableCell>
                    </TableRow>
                </TableHead>
                <TableBody>
                    {files.map((file) => (
                        <FileListRow
                            key={file.id}
                            file={file}
                            isSelected={selectedFiles.some(
                                (f) => f.id === file.id
                            )}
                            onSelect={onFileSelect}
                            onContextMenu={onContextMenu}
                        />
                    ))}

                    {/* ローディング表示 */}
                    {loading && (
                        <>
                            {[...Array(5)].map((_, index) => (
                                <TableRow key={`skeleton-${index}`}>
                                    {multiSelectMode && (
                                        <TableCell padding="checkbox" />
                                    )}
                                    <TableCell>
                                        <Skeleton
                                            variant="rectangular"
                                            width={80}
                                            height={45}
                                        />
                                    </TableCell>
                                    <TableCell>
                                        <Skeleton />
                                    </TableCell>
                                    <TableCell>
                                        <Skeleton />
                                    </TableCell>
                                    <TableCell>
                                        <Skeleton />
                                    </TableCell>
                                    <TableCell>
                                        <Skeleton />
                                    </TableCell>
                                    <TableCell>
                                        <Skeleton />
                                    </TableCell>
                                    <TableCell>
                                        <Skeleton />
                                    </TableCell>
                                </TableRow>
                            ))}
                        </>
                    )}
                </TableBody>
            </Table>

            {/* 無限スクロール用のトリガー */}
            {hasMore && <div ref={loadMoreRef} style={{ height: 1 }} />}
        </TableContainer>
    );
}

export default FileList;

```

```frontend/src/components/files/FileSelectionBar.jsx
import React, { useState } from "react";
import {
    Box,
    Paper,
    Typography,
    Button,
    IconButton,
    Divider,
    Chip,
    Menu,
    MenuItem,
    ListItemIcon,
    ListItemText,
} from "@mui/material";
import {
    Close as CloseIcon,
    SelectAll as SelectAllIcon,
    DriveFileMove as MoveIcon,
    FileCopy as CopyIcon,
    Delete as DeleteIcon,
    Restore as RestoreIcon,
    Label as TagIcon,
    Folder as FolderIcon,
    MoreVert as MoreIcon,
} from "@mui/icons-material";
import { useAtom } from "jotai";
import { useLocation } from "react-router-dom";

import { selectedFilesAtom, multiSelectModeAtom } from "@store/atoms";

function FileSelectionBar({
    selectedCount,
    totalCount,
    onSelectAll,
    onAction,
}) {
    const location = useLocation();
    const [selectedFiles, setSelectedFiles] = useAtom(selectedFilesAtom);
    const [, setMultiSelectMode] = useAtom(multiSelectModeAtom);
    const [anchorEl, setAnchorEl] = useState(null);

    const isDeletedPage = location.pathname === "/deleted";
    const isFolderPage = location.pathname.startsWith("/folders");

    const handleClose = () => {
        setSelectedFiles([]);
        setMultiSelectMode(false);
    };

    const handleAction = (action) => {
        onAction(action);
        setAnchorEl(null);
    };

    const handleMoreClick = (event) => {
        setAnchorEl(event.currentTarget);
    };

    const handleMenuClose = () => {
        setAnchorEl(null);
    };

    return (
        <Paper
            elevation={8}
            sx={{
                position: "fixed",
                bottom: 0,
                left: 0,
                right: 0,
                p: 2,
                borderRadius: 0,
                borderTop: 2,
                borderColor: "primary.main",
                bgcolor: "background.paper",
                zIndex: 1200,
            }}
        >
            <Box sx={{ display: "flex", alignItems: "center", gap: 2 }}>
                {/* 選択数表示 */}
                <Chip
                    label={`${selectedCount}個選択中`}
                    color="primary"
                    onDelete={handleClose}
                    deleteIcon={<CloseIcon />}
                />

                {/* 全選択ボタン */}
                <Button
                    size="small"
                    startIcon={<SelectAllIcon />}
                    onClick={onSelectAll}
                    disabled={selectedCount === totalCount}
                >
                    全選択
                </Button>

                <Divider orientation="vertical" flexItem />

                {/* アクションボタン */}
                {!isDeletedPage && (
                    <>
                        {isFolderPage && (
                            <Button
                                size="small"
                                startIcon={<MoveIcon />}
                                onClick={() => handleAction("move")}
                            >
                                移動
                            </Button>
                        )}
                        <Button
                            size="small"
                            startIcon={<CopyIcon />}
                            onClick={() => handleAction("copy")}
                        >
                            コピー
                        </Button>
                    </>
                )}

                {isFolderPage && location.pathname !== "/folders" && (
                    <Button
                        size="small"
                        startIcon={<FolderIcon />}
                        onClick={() => handleAction("removeFromFolder")}
                    >
                        フォルダから削除
                    </Button>
                )}

                <Button
                    size="small"
                    startIcon={<TagIcon />}
                    onClick={() => handleAction("addTags")}
                >
                    タグ追加
                </Button>

                {!isDeletedPage ? (
                    <Button
                        size="small"
                        startIcon={<DeleteIcon />}
                        onClick={() => handleAction("delete")}
                        color="error"
                    >
                        削除
                    </Button>
                ) : (
                    <Button
                        size="small"
                        startIcon={<RestoreIcon />}
                        onClick={() => handleAction("restore")}
                        color="success"
                    >
                        復元
                    </Button>
                )}

                {/* その他メニュー */}
                <IconButton
                    size="small"
                    onClick={handleMoreClick}
                    sx={{ ml: "auto" }}
                >
                    <MoreIcon />
                </IconButton>

                <Menu
                    anchorEl={anchorEl}
                    open={Boolean(anchorEl)}
                    onClose={handleMenuClose}
                >
                    <MenuItem onClick={() => handleAction("addToPlaylist")}>
                        <ListItemIcon>
                            <FolderIcon fontSize="small" />
                        </ListItemIcon>
                        <ListItemText>プレイリストに追加</ListItemText>
                    </MenuItem>
                    <MenuItem onClick={() => handleAction("export")}>
                        <ListItemIcon>
                            <CopyIcon fontSize="small" />
                        </ListItemIcon>
                        <ListItemText>
                            ファイルリストをエクスポート
                        </ListItemText>
                    </MenuItem>
                    <Divider />
                    <MenuItem onClick={() => handleAction("properties")}>
                        <ListItemIcon>
                            <TagIcon fontSize="small" />
                        </ListItemIcon>
                        <ListItemText>プロパティを表示</ListItemText>
                    </MenuItem>
                </Menu>
            </Box>
        </Paper>
    );
}

export default FileSelectionBar;

```

```frontend/src/components/layout/MainLayout.jsx
import React, { useState } from "react";
import { useNavigate, useLocation } from "react-router-dom";
import { useAtom } from "jotai";
import {
    Box,
    AppBar,
    Toolbar,
    Typography,
    IconButton,
    Drawer,
    List,
    ListItem,
    ListItemButton,
    ListItemIcon,
    ListItemText,
    Divider,
    Badge,
    Button,
    Tooltip,
} from "@mui/material";
import {
    Menu as MenuIcon,
    VideoLibrary as VideoLibraryIcon,
    FolderOff as FolderOffIcon,
    Folder as FolderIcon,
    Delete as DeleteIcon,
    FileCopy as FileCopyIcon,
    Refresh as RefreshIcon,
    Settings as SettingsIcon,
    Search as SearchIcon,
} from "@mui/icons-material";

import SearchBar from "@components/common/SearchBar";
import ViewToggle from "@components/common/ViewToggle";
import MultiSelectToggle from "@components/common/MultiSelectToggle";
import SettingsDialog from "@components/dialogs/SettingsDialog";

import { loadingAtom, notificationAtom } from "@store/atoms";
import { systemAPI } from "@services/api";

const drawerWidth = 240;

const menuItems = [
    {
        id: "all-files",
        path: "/all-files",
        label: "全ファイル",
        icon: <VideoLibraryIcon />,
        description: "すべての有効なファイル",
    },
    {
        id: "no-folder",
        path: "/no-folder",
        label: "フォルダに存在しない",
        icon: <FolderOffIcon />,
        description: "フォルダに振り分けられていないファイル",
    },
    {
        id: "folders",
        path: "/folders",
        label: "フォルダ",
        icon: <FolderIcon />,
        description: "フォルダ管理",
    },
    {
        id: "deleted",
        path: "/deleted",
        label: "削除ファイル一覧",
        icon: <DeleteIcon />,
        description: "削除フラグが付いたファイル",
    },
    {
        id: "duplicates",
        path: "/duplicates",
        label: "重複ファイル一覧",
        icon: <FileCopyIcon />,
        description: "重複フラグが付いたファイル",
    },
];

function MainLayout({ children }) {
    const navigate = useNavigate();
    const location = useLocation();
    const [loading, setLoading] = useAtom(loadingAtom);
    const [, setNotification] = useAtom(notificationAtom);

    const [drawerOpen, setDrawerOpen] = useState(false);
    const [settingsOpen, setSettingsOpen] = useState(false);
    const [searchOpen, setSearchOpen] = useState(false);

    const handleDrawerToggle = () => {
        setDrawerOpen(!drawerOpen);
    };

    const handleNavigate = (path) => {
        navigate(path);
        setDrawerOpen(false);
    };

    const handleForceRefresh = async () => {
        setLoading(true);
        try {
            const result = await systemAPI.forceRefresh();
            setNotification({
                open: true,
                message: `スキャン完了: ${result.files_added}個のファイルを追加、${result.files_updated}個を更新`,
                severity: "success",
            });
        } catch (error) {
            setNotification({
                open: true,
                message: "スキャンに失敗しました",
                severity: "error",
            });
        } finally {
            setLoading(false);
        }
    };

    const getCurrentPageTitle = () => {
        const currentItem = menuItems.find((item) =>
            location.pathname.startsWith(item.path)
        );
        return currentItem?.label || "Video Streaming";
    };

    const drawer = (
        <Box>
            <Toolbar>
                <Typography variant="h6" noWrap component="div">
                    Video Library
                </Typography>
            </Toolbar>
            <Divider />
            <List>
                {menuItems.map((item) => {
                    const isActive = location.pathname.startsWith(item.path);
                    return (
                        <ListItem key={item.id} disablePadding>
                            <ListItemButton
                                selected={isActive}
                                onClick={() => handleNavigate(item.path)}
                            >
                                <ListItemIcon>
                                    {item.badge ? (
                                        <Badge
                                            badgeContent={item.badge}
                                            color="error"
                                        >
                                            {item.icon}
                                        </Badge>
                                    ) : (
                                        item.icon
                                    )}
                                </ListItemIcon>
                                <ListItemText
                                    primary={item.label}
                                    secondary={item.description}
                                />
                            </ListItemButton>
                        </ListItem>
                    );
                })}
            </List>
            <Divider />
            <List>
                <ListItem disablePadding>
                    <ListItemButton
                        onClick={handleForceRefresh}
                        disabled={loading}
                    >
                        <ListItemIcon>
                            <RefreshIcon />
                        </ListItemIcon>
                        <ListItemText
                            primary="強制スキャン"
                            secondary="ファイルを再スキャン"
                        />
                    </ListItemButton>
                </ListItem>
                <ListItem disablePadding>
                    <ListItemButton onClick={() => setSettingsOpen(true)}>
                        <ListItemIcon>
                            <SettingsIcon />
                        </ListItemIcon>
                        <ListItemText
                            primary="設定"
                            secondary="アプリケーション設定"
                        />
                    </ListItemButton>
                </ListItem>
            </List>
        </Box>
    );

    return (
        <Box sx={{ display: "flex", height: "100vh" }}>
            <AppBar
                position="fixed"
                sx={{
                    width: {
                        sm: `calc(100% - ${drawerOpen ? drawerWidth : 0}px)`,
                    },
                    ml: { sm: `${drawerOpen ? drawerWidth : 0}px` },
                    transition: "all 0.3s",
                }}
            >
                <Toolbar>
                    <IconButton
                        color="inherit"
                        aria-label="open drawer"
                        edge="start"
                        onClick={handleDrawerToggle}
                        sx={{ mr: 2 }}
                    >
                        <MenuIcon />
                    </IconButton>

                    <Typography
                        variant="h6"
                        noWrap
                        component="div"
                        sx={{ flexGrow: 0, mr: 3 }}
                    >
                        {getCurrentPageTitle()}
                    </Typography>

                    {/* 検索バー */}
                    <Box
                        sx={{
                            flexGrow: 1,
                            display: { xs: "none", md: "block" },
                        }}
                    >
                        {!searchOpen && (
                            <Button
                                startIcon={<SearchIcon />}
                                onClick={() => setSearchOpen(true)}
                                sx={{ color: "white" }}
                            >
                                検索...
                            </Button>
                        )}
                        {searchOpen && (
                            <SearchBar onClose={() => setSearchOpen(false)} />
                        )}
                    </Box>

                    {/* モバイル用検索ボタン */}
                    <IconButton
                        color="inherit"
                        onClick={() => setSearchOpen(!searchOpen)}
                        sx={{ display: { xs: "block", md: "none" } }}
                    >
                        <SearchIcon />
                    </IconButton>

                    {/* 右側のコントロール */}
                    <Box
                        sx={{
                            ml: "auto",
                            display: "flex",
                            alignItems: "center",
                            gap: 1,
                        }}
                    >
                        <MultiSelectToggle />
                        <ViewToggle />
                        <Tooltip title="強制スキャン">
                            <IconButton
                                color="inherit"
                                onClick={handleForceRefresh}
                                disabled={loading}
                            >
                                <RefreshIcon />
                            </IconButton>
                        </Tooltip>
                        <Tooltip title="設定">
                            <IconButton
                                color="inherit"
                                onClick={() => setSettingsOpen(true)}
                            >
                                <SettingsIcon />
                            </IconButton>
                        </Tooltip>
                    </Box>
                </Toolbar>

                {/* モバイル用検索バー */}
                {searchOpen && (
                    <Box sx={{ display: { xs: "block", md: "none" }, p: 1 }}>
                        <SearchBar onClose={() => setSearchOpen(false)} />
                    </Box>
                )}
            </AppBar>

            <Box
                component="nav"
                sx={{
                    width: { sm: drawerOpen ? drawerWidth : 0 },
                    flexShrink: { sm: 0 },
                }}
            >
                <Drawer
                    variant="temporary"
                    open={drawerOpen}
                    onClose={handleDrawerToggle}
                    ModalProps={{
                        keepMounted: true, // モバイルでのパフォーマンス向上
                    }}
                    sx={{
                        display: { xs: "block", sm: "none" },
                        "& .MuiDrawer-paper": {
                            boxSizing: "border-box",
                            width: drawerWidth,
                        },
                    }}
                >
                    {drawer}
                </Drawer>
                <Drawer
                    variant="persistent"
                    open={drawerOpen}
                    sx={{
                        display: { xs: "none", sm: "block" },
                        "& .MuiDrawer-paper": {
                            boxSizing: "border-box",
                            width: drawerWidth,
                        },
                    }}
                >
                    {drawer}
                </Drawer>
            </Box>

            <Box
                component="main"
                sx={{
                    flexGrow: 1,
                    p: 0,
                    width: {
                        sm: `calc(100% - ${drawerOpen ? drawerWidth : 0}px)`,
                    },
                    ml: { sm: drawerOpen ? `${drawerWidth}px` : 0 },
                    transition: "all 0.3s",
                    mt: { xs: 7, sm: 8 },
                    height: "calc(100vh - 64px)",
                    overflow: "hidden",
                }}
            >
                {children}
            </Box>

            {/* 設定ダイアログ */}
            <SettingsDialog
                open={settingsOpen}
                onClose={() => setSettingsOpen(false)}
            />
        </Box>
    );
}

export default MainLayout;

```

```frontend/src/components/player/MultiPlayerContainer.jsx
import React, { useState, useRef, useCallback } from "react";
import { useAtom } from "jotai";
import Draggable from "react-draggable";
import { Resizable } from "react-resizable";
import {
    Box,
    Paper,
    IconButton,
    ToggleButton,
    ToggleButtonGroup,
    Fab,
    Tooltip,
} from "@mui/material";
import {
    Close as CloseIcon,
    CloseFullscreen as CloseAllIcon,
    GridView as GridIcon,
    DragIndicator as FreeIcon,
    Fullscreen as FullscreenIcon,
    FullscreenExit as ExitFullscreenIcon,
} from "@mui/icons-material";

import VideoPlayer from "./VideoPlayer";
import { openPlayersAtom, playerLayoutModeAtom } from "@store/atoms";

// 個別のプレイヤーラッパー
function PlayerWrapper({
    player,
    index,
    layoutMode,
    onClose,
    onResize,
    onDrag,
    gridPosition,
}) {
    const [size, setSize] = useState({ width: 400, height: 300 });
    const [position, setPosition] = useState({ x: index * 50, y: index * 50 });
    const [isFullscreen, setIsFullscreen] = useState(false);
    const nodeRef = useRef(null);

    const handleResize = (event, { size: newSize }) => {
        setSize(newSize);
        if (onResize) {
            onResize(index, newSize);
        }
    };

    const handleDrag = (e, data) => {
        setPosition({ x: data.x, y: data.y });
        if (onDrag) {
            onDrag(index, { x: data.x, y: data.y });
        }
    };

    const handleClose = () => {
        onClose(index);
    };

    const toggleFullscreen = () => {
        if (!isFullscreen) {
            setSize({ width: window.innerWidth, height: window.innerHeight });
            setPosition({ x: 0, y: 0 });
        } else {
            setSize({ width: 400, height: 300 });
            setPosition({ x: index * 50, y: index * 50 });
        }
        setIsFullscreen(!isFullscreen);
    };

    // グリッドモードの場合
    if (layoutMode === "grid") {
        return (
            <Box
                sx={{
                    ...gridPosition,
                    position: "relative",
                    overflow: "hidden",
                    border: 1,
                    borderColor: "divider",
                }}
            >
                <IconButton
                    size="small"
                    onClick={handleClose}
                    sx={{
                        position: "absolute",
                        top: 4,
                        right: 4,
                        zIndex: 10,
                        bgcolor: "rgba(0,0,0,0.5)",
                        color: "white",
                        "&:hover": {
                            bgcolor: "rgba(0,0,0,0.7)",
                        },
                    }}
                >
                    <CloseIcon fontSize="small" />
                </IconButton>
                <VideoPlayer
                    file={player}
                    onClose={handleClose}
                    isMultiPlayer={true}
                />
            </Box>
        );
    }

    // フリーモードの場合
    return (
        <Draggable
            nodeRef={nodeRef}
            handle=".drag-handle"
            position={position}
            onDrag={handleDrag}
            bounds="parent"
            disabled={isFullscreen}
        >
            <div
                ref={nodeRef}
                style={{
                    position: "absolute",
                    zIndex: isFullscreen ? 9999 : 1000 + index,
                }}
            >
                <Resizable
                    width={size.width}
                    height={size.height}
                    onResize={handleResize}
                    minConstraints={[200, 150]}
                    maxConstraints={[window.innerWidth, window.innerHeight]}
                    resizeHandles={isFullscreen ? [] : ["se"]}
                >
                    <Paper
                        elevation={8}
                        sx={{
                            width: size.width,
                            height: size.height,
                            display: "flex",
                            flexDirection: "column",
                            overflow: "hidden",
                            position: "relative",
                        }}
                    >
                        {/* ヘッダーバー（ドラッグ可能） */}
                        <Box
                            className="drag-handle"
                            sx={{
                                height: 32,
                                bgcolor: "primary.dark",
                                display: "flex",
                                alignItems: "center",
                                px: 1,
                                cursor: "move",
                                position: "absolute",
                                top: 0,
                                left: 0,
                                right: 0,
                                zIndex: 1,
                                opacity: 0.9,
                            }}
                        >
                            <FreeIcon fontSize="small" sx={{ mr: 1 }} />
                            <Box sx={{ flexGrow: 1 }} />
                            <IconButton
                                size="small"
                                onClick={toggleFullscreen}
                                sx={{ color: "white" }}
                            >
                                {isFullscreen ? (
                                    <ExitFullscreenIcon fontSize="small" />
                                ) : (
                                    <FullscreenIcon fontSize="small" />
                                )}
                            </IconButton>
                            <IconButton
                                size="small"
                                onClick={handleClose}
                                sx={{ color: "white" }}
                            >
                                <CloseIcon fontSize="small" />
                            </IconButton>
                        </Box>

                        {/* プレイヤー本体 */}
                        <Box sx={{ flexGrow: 1, mt: 4 }}>
                            <VideoPlayer
                                file={player}
                                onClose={handleClose}
                                isMultiPlayer={true}
                            />
                        </Box>
                    </Paper>
                </Resizable>
            </div>
        </Draggable>
    );
}

// メインコンテナ
function MultiPlayerContainer({ players: initialPlayers = [] }) {
    const [openPlayers, setOpenPlayers] = useAtom(openPlayersAtom);
    const [layoutMode, setLayoutMode] = useAtom(playerLayoutModeAtom);
    const [gridLayout, setGridLayout] = useState({ rows: 1, cols: 1 });

    // プレイヤーを使用（propsまたはatom）
    const players = initialPlayers.length > 0 ? initialPlayers : openPlayers;

    // レイアウトモード切替
    const handleLayoutChange = (event, newMode) => {
        if (newMode !== null) {
            setLayoutMode(newMode);

            // グリッドレイアウトの計算
            if (newMode === "grid") {
                const count = players.length;
                const cols = Math.ceil(Math.sqrt(count));
                const rows = Math.ceil(count / cols);
                setGridLayout({ rows, cols });
            }
        }
    };

    // プレイヤーを閉じる
    const handleClosePlayer = (index) => {
        setOpenPlayers((prev) => prev.filter((_, i) => i !== index));
    };

    // すべて閉じる
    const handleCloseAll = () => {
        setOpenPlayers([]);
    };

    // グリッド位置計算
    const getGridPosition = (index) => {
        const { rows, cols } = gridLayout;
        const row = Math.floor(index / cols);
        const col = index % cols;

        return {
            gridRow: row + 1,
            gridColumn: col + 1,
            width: "100%",
            height: "100%",
        };
    };

    if (players.length === 0) {
        return null;
    }

    return (
        <Box
            sx={{
                position: "fixed",
                top: 0,
                left: 0,
                right: 0,
                bottom: 0,
                bgcolor: "rgba(0, 0, 0, 0.8)",
                zIndex: 1200,
                ...(layoutMode === "grid" && {
                    display: "grid",
                    gridTemplateRows: `repeat(${gridLayout.rows}, 1fr)`,
                    gridTemplateColumns: `repeat(${gridLayout.cols}, 1fr)`,
                    gap: 1,
                    p: 2,
                }),
            }}
        >
            {/* コントロールバー */}
            <Paper
                elevation={4}
                sx={{
                    position: "fixed",
                    top: 16,
                    left: "50%",
                    transform: "translateX(-50%)",
                    zIndex: 1300,
                    p: 1,
                    display: "flex",
                    alignItems: "center",
                    gap: 2,
                }}
            >
                <ToggleButtonGroup
                    value={layoutMode}
                    exclusive
                    onChange={handleLayoutChange}
                    size="small"
                >
                    <ToggleButton value="free">
                        <Tooltip title="自由配置">
                            <FreeIcon />
                        </Tooltip>
                    </ToggleButton>
                    <ToggleButton value="grid">
                        <Tooltip title="グリッド配置">
                            <GridIcon />
                        </Tooltip>
                    </ToggleButton>
                </ToggleButtonGroup>

                <IconButton onClick={handleCloseAll} color="error">
                    <Tooltip title="すべて閉じる">
                        <CloseAllIcon />
                    </Tooltip>
                </IconButton>
            </Paper>

            {/* プレイヤー */}
            {players.map((player, index) => (
                <PlayerWrapper
                    key={player.id || index}
                    player={player}
                    index={index}
                    layoutMode={layoutMode}
                    onClose={handleClosePlayer}
                    gridPosition={
                        layoutMode === "grid" ? getGridPosition(index) : null
                    }
                />
            ))}
        </Box>
    );
}

export default MultiPlayerContainer;

```

```frontend/src/components/player/VideoPlayer.jsx
import React, { useRef, useState, useEffect, useCallback } from "react";
import { useAtom } from "jotai";
import { useLongPress } from "use-long-press";
import {
    Box,
    IconButton,
    Slider,
    Typography,
    Tooltip,
    Menu,
    MenuItem,
    TextField,
    Dialog,
    DialogTitle,
    DialogContent,
    DialogActions,
    Button,
    Stack,
    Fab,
    Collapse,
} from "@mui/material";
import {
    PlayArrow as PlayIcon,
    Pause as PauseIcon,
    SkipNext as NextIcon,
    SkipPrevious as PrevIcon,
    VolumeUp as VolumeIcon,
    VolumeOff as VolumeMuteIcon,
    Loop as LoopIcon,
    Speed as SpeedIcon,
    Fullscreen as FullscreenIcon,
    FullscreenExit as FullscreenExitIcon,
    MoreVert as MoreIcon,
    AspectRatio as AspectRatioIcon,
    Repeat as RepeatIcon,
    Add as AddIcon,
    Close as CloseIcon,
} from "@mui/icons-material";

import {
    playerSettingsAtom,
    openPlayersAtom,
    notificationAtom,
} from "@store/atoms";
import { fileAPI, getVideoUrl } from "@services/api";
import { formatTime } from "@utils/format";

function VideoPlayer({ file, onClose, onNext, onPrev, isMultiPlayer = false }) {
    const videoRef = useRef(null);
    const containerRef = useRef(null);
    const [playerSettings, setPlayerSettings] = useAtom(playerSettingsAtom);
    const [, setOpenPlayers] = useAtom(openPlayersAtom);
    const [, setNotification] = useAtom(notificationAtom);

    // プレイヤー状態
    const [playing, setPlaying] = useState(false);
    const [currentTime, setCurrentTime] = useState(0);
    const [duration, setDuration] = useState(0);
    const [volume, setVolume] = useState(playerSettings.volume);
    const [muted, setMuted] = useState(playerSettings.muted);
    const [fullscreen, setFullscreen] = useState(false);
    const [showControls, setShowControls] = useState(true);
    const [buffered, setBuffered] = useState(0);

    // A-Bループ
    const [abLoop, setAbLoop] = useState(playerSettings.abLoop);
    const [settingABLoop, setSettingABLoop] = useState(false);

    // メニュー
    const [anchorEl, setAnchorEl] = useState(null);
    const [speedMenuOpen, setSpeedMenuOpen] = useState(false);
    const [abLoopDialogOpen, setAbLoopDialogOpen] = useState(false);
    const [renameDialogOpen, setRenameDialogOpen] = useState(false);
    const [newFileName, setNewFileName] = useState(file?.file_name || "");

    // タッチ制御
    const [lastTap, setLastTap] = useState(0);
    const [tapTimer, setTapTimer] = useState(null);
    const controlsTimer = useRef(null);

    // 長押し処理（2倍速）
    const bindLongPress = useLongPress(
        () => {
            if (videoRef.current) {
                videoRef.current.playbackRate = playerSettings.longPressSpeed;
            }
        },
        {
            onFinish: () => {
                if (videoRef.current) {
                    videoRef.current.playbackRate =
                        playerSettings.playbackSpeed;
                }
            },
            threshold: 500,
            captureEvent: true,
            cancelOnMovement: false,
        }
    );

    // 動画URL取得
    const videoUrl = getVideoUrl(file);

    // 初期化
    useEffect(() => {
        if (videoRef.current) {
            videoRef.current.volume = volume;
            videoRef.current.muted = muted;
            videoRef.current.playbackRate = playerSettings.playbackSpeed;

            if (playerSettings.autoPlay) {
                videoRef.current.play().catch((err) => {
                    console.error("Auto-play failed:", err);
                });
            }
        }
    }, []);

    // コントロール自動非表示
    useEffect(() => {
        const hideControls = () => {
            if (controlsTimer.current) {
                clearTimeout(controlsTimer.current);
            }
            controlsTimer.current = setTimeout(() => {
                if (playing && !isMultiPlayer) {
                    setShowControls(false);
                }
            }, 3000);
        };

        if (playing) {
            hideControls();
        } else {
            setShowControls(true);
        }

        return () => {
            if (controlsTimer.current) {
                clearTimeout(controlsTimer.current);
            }
        };
    }, [playing, isMultiPlayer]);

    // マウス移動でコントロール表示
    const handleMouseMove = useCallback(() => {
        setShowControls(true);
        if (playing && !isMultiPlayer) {
            if (controlsTimer.current) {
                clearTimeout(controlsTimer.current);
            }
            controlsTimer.current = setTimeout(() => {
                setShowControls(false);
            }, 3000);
        }
    }, [playing, isMultiPlayer]);

    // 再生/一時停止
    const togglePlay = useCallback(() => {
        if (videoRef.current) {
            if (playing) {
                videoRef.current.pause();
            } else {
                videoRef.current.play();
            }
            setPlaying(!playing);
        }
    }, [playing]);

    // シーク
    const handleSeek = useCallback((value) => {
        if (videoRef.current) {
            videoRef.current.currentTime = value;
            setCurrentTime(value);
        }
    }, []);

    // ボリューム変更
    const handleVolumeChange = useCallback(
        (value) => {
            if (videoRef.current) {
                videoRef.current.volume = value;
                setVolume(value);
                setPlayerSettings((prev) => ({ ...prev, volume: value }));
            }
        },
        [setPlayerSettings]
    );

    // ミュート切り替え
    const toggleMute = useCallback(() => {
        if (videoRef.current) {
            const newMuted = !muted;
            videoRef.current.muted = newMuted;
            setMuted(newMuted);
            setPlayerSettings((prev) => ({ ...prev, muted: newMuted }));
        }
    }, [muted, setPlayerSettings]);

    // 再生速度変更
    const handleSpeedChange = useCallback(
        (speed) => {
            if (videoRef.current) {
                videoRef.current.playbackRate = speed;
                setPlayerSettings((prev) => ({
                    ...prev,
                    playbackSpeed: speed,
                }));
            }
            setSpeedMenuOpen(false);
        },
        [setPlayerSettings]
    );

    // フルスクリーン切り替え
    const toggleFullscreen = useCallback(() => {
        if (!document.fullscreenElement) {
            containerRef.current?.requestFullscreen();
            setFullscreen(true);
        } else {
            document.exitFullscreen();
            setFullscreen(false);
        }
    }, []);

    // A-Bループ設定
    const setABLoopPoint = useCallback(
        (point) => {
            if (point === "start") {
                setAbLoop((prev) => ({
                    ...prev,
                    start: currentTime,
                    enabled: prev.end !== null,
                }));
            } else {
                setAbLoop((prev) => ({
                    ...prev,
                    end: currentTime,
                    enabled: prev.start !== null,
                }));
            }
        },
        [currentTime]
    );

    // A-Bループ処理
    useEffect(() => {
        const video = videoRef.current;
        if (!video || !abLoop.enabled) return;

        const handleTimeUpdate = () => {
            if (abLoop.start !== null && abLoop.end !== null) {
                if (video.currentTime >= abLoop.end) {
                    video.currentTime = abLoop.start;
                }
            }
        };

        video.addEventListener("timeupdate", handleTimeUpdate);
        return () => video.removeEventListener("timeupdate", handleTimeUpdate);
    }, [abLoop]);

    // タップ処理（ダブルタップでスキップ/巻き戻し）
    const handleTap = useCallback(
        (e) => {
            const rect = containerRef.current?.getBoundingClientRect();
            if (!rect) return;

            const x = e.clientX || e.touches?.[0]?.clientX;
            const relativeX = (x - rect.left) / rect.width;

            const now = Date.now();
            const DOUBLE_TAP_DELAY = 300;

            if (now - lastTap < DOUBLE_TAP_DELAY) {
                // ダブルタップ
                if (tapTimer) {
                    clearTimeout(tapTimer);
                    setTapTimer(null);
                }

                if (relativeX < 0.35) {
                    // 左側 - 巻き戻し
                    handleSeek(
                        Math.max(0, currentTime - playerSettings.skipSeconds)
                    );
                    setNotification({
                        open: true,
                        message: `${playerSettings.skipSeconds}秒巻き戻し`,
                        severity: "info",
                    });
                } else if (relativeX > 0.65) {
                    // 右側 - スキップ
                    handleSeek(
                        Math.min(
                            duration,
                            currentTime + playerSettings.skipSeconds
                        )
                    );
                    setNotification({
                        open: true,
                        message: `${playerSettings.skipSeconds}秒スキップ`,
                        severity: "info",
                    });
                } else {
                    // 中央 - 再生/一時停止
                    togglePlay();
                }
            } else {
                // シングルタップ（遅延実行）
                const timer = setTimeout(() => {
                    if (relativeX > 0.3 && relativeX < 0.7) {
                        togglePlay();
                    }
                }, DOUBLE_TAP_DELAY);
                setTapTimer(timer);
            }

            setLastTap(now);
        },
        [
            currentTime,
            duration,
            playerSettings.skipSeconds,
            handleSeek,
            togglePlay,
            lastTap,
            tapTimer,
        ]
    );

    // フリック処理（シーク）
    const handleSwipe = useCallback((e) => {
        const rect = containerRef.current?.getBoundingClientRect();
        if (!rect) return;

        const y = e.clientY || e.touches?.[0]?.clientY;
        const relativeY = (y - rect.top) / rect.height;

        // 下部40%の範囲のみ
        if (relativeY > 0.6) {
            // フリック処理のロジックを実装
            // ここでは簡略化
        }
    }, []);

    // ピンチズーム処理
    const [scale, setScale] = useState(1);
    const handlePinch = useCallback((e) => {
        if (e.touches && e.touches.length === 2) {
            const touch1 = e.touches[0];
            const touch2 = e.touches[1];
            const distance = Math.hypot(
                touch2.clientX - touch1.clientX,
                touch2.clientY - touch1.clientY
            );

            // ピンチズームの実装
            // ここでは簡略化
        }
    }, []);

    // ファイル名変更
    const handleRename = async () => {
        try {
            await fileAPI.updateFile(file.id, { file_name: newFileName });
            setNotification({
                open: true,
                message: "ファイル名を変更しました",
                severity: "success",
            });
            setRenameDialogOpen(false);
        } catch (error) {
            setNotification({
                open: true,
                message: "ファイル名の変更に失敗しました",
                severity: "error",
            });
        }
    };

    // 追加で動画を開く
    const handleAddVideo = () => {
        setOpenPlayers((prev) => [
            ...prev,
            { ...file, id: `${file.id}_${Date.now()}` },
        ]);
        // 選択モードに遷移する処理を追加
    };

    return (
        <Box
            ref={containerRef}
            className="video-player-container"
            sx={{
                position: "relative",
                width: "100%",
                height: "100%",
                backgroundColor: "black",
                overflow: "hidden",
                cursor: showControls ? "default" : "none",
            }}
            onMouseMove={handleMouseMove}
            onTouchStart={handleTap}
            {...bindLongPress()}
        >
            {/* ビデオ要素 */}
            <video
                ref={videoRef}
                src={videoUrl}
                style={{
                    width: "100%",
                    height: "100%",
                    objectFit: playerSettings.aspectRatioFit,
                    transform: `scale(${scale})`,
                }}
                loop={playerSettings.loop && !abLoop.enabled}
                onPlay={() => setPlaying(true)}
                onPause={() => setPlaying(false)}
                onTimeUpdate={(e) => setCurrentTime(e.target.currentTime)}
                onLoadedMetadata={(e) => setDuration(e.target.duration)}
                onProgress={(e) => {
                    if (e.target.buffered.length > 0) {
                        setBuffered(
                            e.target.buffered.end(e.target.buffered.length - 1)
                        );
                    }
                }}
                onEnded={() => {
                    if (!playerSettings.loop && !abLoop.enabled && onNext) {
                        onNext();
                    }
                }}
            />

            {/* コントロールオーバーレイ */}
            <Collapse in={showControls}>
                <Box
                    className="video-player-controls"
                    sx={{
                        position: "absolute",
                        bottom: 0,
                        left: 0,
                        right: 0,
                        background:
                            "linear-gradient(to top, rgba(0,0,0,0.7), transparent)",
                        p: 2,
                    }}
                >
                    {/* シークバー */}
                    <Box sx={{ px: 2, mb: 1 }}>
                        <Slider
                            value={currentTime}
                            max={duration}
                            onChange={(e, value) => handleSeek(value)}
                            sx={{
                                "& .MuiSlider-rail": {
                                    opacity: 0.28,
                                },
                                "& .MuiSlider-track": {
                                    border: "none",
                                },
                            }}
                        />
                        <Box
                            sx={{
                                display: "flex",
                                justifyContent: "space-between",
                            }}
                        >
                            <Typography variant="caption">
                                {formatTime(currentTime)}
                            </Typography>
                            <Typography variant="caption">
                                {formatTime(duration)}
                            </Typography>
                        </Box>
                    </Box>

                    {/* コントロールボタン */}
                    <Stack direction="row" spacing={1} alignItems="center">
                        {/* 前へ */}
                        {onPrev && (
                            <IconButton onClick={onPrev} color="inherit">
                                <PrevIcon />
                            </IconButton>
                        )}

                        {/* 再生/一時停止 */}
                        <IconButton onClick={togglePlay} color="inherit">
                            {playing ? <PauseIcon /> : <PlayIcon />}
                        </IconButton>

                        {/* 次へ */}
                        {onNext && (
                            <IconButton onClick={onNext} color="inherit">
                                <NextIcon />
                            </IconButton>
                        )}

                        {/* ボリューム */}
                        <IconButton onClick={toggleMute} color="inherit">
                            {muted ? <VolumeMuteIcon /> : <VolumeIcon />}
                        </IconButton>
                        <Slider
                            value={muted ? 0 : volume}
                            onChange={(e, value) => handleVolumeChange(value)}
                            max={1}
                            step={0.1}
                            sx={{ width: 100 }}
                        />

                        {/* 再生速度 */}
                        <Button
                            startIcon={<SpeedIcon />}
                            onClick={() => setSpeedMenuOpen(true)}
                            color="inherit"
                            size="small"
                        >
                            {playerSettings.playbackSpeed}x
                        </Button>

                        {/* ループ */}
                        <IconButton
                            onClick={() =>
                                setPlayerSettings((prev) => ({
                                    ...prev,
                                    loop: !prev.loop,
                                }))
                            }
                            color={playerSettings.loop ? "primary" : "inherit"}
                        >
                            <LoopIcon />
                        </IconButton>

                        {/* A-Bループ */}
                        <IconButton
                            onClick={() => setAbLoopDialogOpen(true)}
                            color={abLoop.enabled ? "primary" : "inherit"}
                        >
                            <RepeatIcon />
                        </IconButton>

                        {/* アスペクト比 */}
                        <IconButton
                            onClick={() => {
                                const newFit =
                                    playerSettings.aspectRatioFit === "contain"
                                        ? "cover"
                                        : "contain";
                                setPlayerSettings((prev) => ({
                                    ...prev,
                                    aspectRatioFit: newFit,
                                }));
                            }}
                            color="inherit"
                        >
                            <AspectRatioIcon />
                        </IconButton>

                        <Box sx={{ flexGrow: 1 }} />

                        {/* その他メニュー */}
                        <IconButton
                            onClick={(e) => setAnchorEl(e.currentTarget)}
                            color="inherit"
                        >
                            <MoreIcon />
                        </IconButton>

                        {/* フルスクリーン */}
                        <IconButton onClick={toggleFullscreen} color="inherit">
                            {fullscreen ? (
                                <FullscreenExitIcon />
                            ) : (
                                <FullscreenIcon />
                            )}
                        </IconButton>

                        {/* 閉じる */}
                        {onClose && (
                            <IconButton onClick={onClose} color="inherit">
                                <CloseIcon />
                            </IconButton>
                        )}
                    </Stack>
                </Box>
            </Collapse>

            {/* 追加で動画を開くボタン（複数プレイヤーモードでない場合） */}
            {!isMultiPlayer && (
                <Fab
                    color="primary"
                    size="small"
                    onClick={handleAddVideo}
                    sx={{
                        position: "absolute",
                        top: 16,
                        right: 16,
                        opacity: showControls ? 1 : 0,
                        transition: "opacity 0.3s",
                    }}
                >
                    <AddIcon />
                </Fab>
            )}

            {/* 再生速度メニュー */}
            <Menu
                open={speedMenuOpen}
                onClose={() => setSpeedMenuOpen(false)}
                anchorOrigin={{ vertical: "bottom", horizontal: "center" }}
            >
                {[0.25, 0.5, 0.75, 1, 1.1, 1.25, 1.5, 1.75, 2, 3, 4, 5].map(
                    (speed) => (
                        <MenuItem
                            key={speed}
                            onClick={() => handleSpeedChange(speed)}
                        >
                            {speed}x
                        </MenuItem>
                    )
                )}
            </Menu>

            {/* その他メニュー */}
            <Menu
                anchorEl={anchorEl}
                open={Boolean(anchorEl)}
                onClose={() => setAnchorEl(null)}
            >
                <MenuItem onClick={() => setRenameDialogOpen(true)}>
                    ファイル名を変更
                </MenuItem>
                <MenuItem
                    onClick={() => {
                        /* タグ付け処理 */
                    }}
                >
                    タグを追加
                </MenuItem>
                <MenuItem
                    onClick={() => {
                        /* フォルダ移動処理 */
                    }}
                >
                    フォルダへ移動
                </MenuItem>
            </Menu>

            {/* A-Bループ設定ダイアログ */}
            <Dialog
                open={abLoopDialogOpen}
                onClose={() => setAbLoopDialogOpen(false)}
            >
                <DialogTitle>A-Bループ設定</DialogTitle>
                <DialogContent>
                    <Stack spacing={2}>
                        <Button onClick={() => setABLoopPoint("start")}>
                            開始地点を設定 ({formatTime(abLoop.start || 0)})
                        </Button>
                        <Button onClick={() => setABLoopPoint("end")}>
                            終了地点を設定 ({formatTime(abLoop.end || duration)}
                            )
                        </Button>
                        <Button
                            onClick={() =>
                                setAbLoop({
                                    enabled: false,
                                    start: null,
                                    end: null,
                                })
                            }
                            disabled={!abLoop.enabled}
                        >
                            A-Bループを解除
                        </Button>
                    </Stack>
                </DialogContent>
                <DialogActions>
                    <Button onClick={() => setAbLoopDialogOpen(false)}>
                        閉じる
                    </Button>
                </DialogActions>
            </Dialog>

            {/* ファイル名変更ダイアログ */}
            <Dialog
                open={renameDialogOpen}
                onClose={() => setRenameDialogOpen(false)}
            >
                <DialogTitle>ファイル名を変更</DialogTitle>
                <DialogContent>
                    <TextField
                        fullWidth
                        value={newFileName}
                        onChange={(e) => setNewFileName(e.target.value)}
                        label="新しいファイル名"
                        margin="normal"
                    />
                </DialogContent>
                <DialogActions>
                    <Button onClick={() => setRenameDialogOpen(false)}>
                        キャンセル
                    </Button>
                    <Button onClick={handleRename} variant="contained">
                        変更
                    </Button>
                </DialogActions>
            </Dialog>
        </Box>
    );
}

export default VideoPlayer;

```

```frontend/src/components/player/VideoPlayerModal.jsx
import React, { useEffect } from "react";
import { Modal, Box, IconButton } from "@mui/material";
import { Close as CloseIcon } from "@mui/icons-material";

import VideoPlayer from "./VideoPlayer";

function VideoPlayerModal({ file, open, onClose, onNext, onPrev }) {
    // ESCキーでモーダルを閉じる
    useEffect(() => {
        const handleEsc = (event) => {
            if (event.keyCode === 27) {
                onClose();
            }
        };

        if (open) {
            document.addEventListener("keydown", handleEsc);
        }

        return () => {
            document.removeEventListener("keydown", handleEsc);
        };
    }, [open, onClose]);

    // ボディのスクロールを無効化
    useEffect(() => {
        if (open) {
            document.body.style.overflow = "hidden";
        } else {
            document.body.style.overflow = "unset";
        }

        return () => {
            document.body.style.overflow = "unset";
        };
    }, [open]);

    return (
        <Modal
            open={open}
            onClose={onClose}
            sx={{
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
            }}
        >
            <Box
                sx={{
                    position: "relative",
                    width: "90vw",
                    height: "90vh",
                    maxWidth: 1600,
                    bgcolor: "black",
                    borderRadius: 2,
                    overflow: "hidden",
                    outline: "none",
                }}
            >
                {/* 閉じるボタン */}
                <IconButton
                    onClick={onClose}
                    sx={{
                        position: "absolute",
                        top: 8,
                        right: 8,
                        color: "white",
                        bgcolor: "rgba(0,0,0,0.5)",
                        zIndex: 1,
                        "&:hover": {
                            bgcolor: "rgba(0,0,0,0.7)",
                        },
                    }}
                >
                    <CloseIcon />
                </IconButton>

                {/* ビデオプレイヤー */}
                <VideoPlayer
                    file={file}
                    onClose={onClose}
                    onNext={onNext}
                    onPrev={onPrev}
                    isMultiPlayer={false}
                />
            </Box>
        </Modal>
    );
}

export default VideoPlayerModal;

```

```frontend/src/index.css
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

html, body, #root {
  width: 100%;
  height: 100%;
  overflow: hidden;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

/* カスタムスクロールバー */
::-webkit-scrollbar {
  width: 10px;
  height: 10px;
}

::-webkit-scrollbar-track {
  background: #2b2b2b;
}

::-webkit-scrollbar-thumb {
  background: #6b6b6b;
  border-radius: 5px;
}

::-webkit-scrollbar-thumb:hover {
  background: #959595;
}

/* ビデオプレイヤーのカスタムスタイル */
.video-player-container {
  position: relative;
  width: 100%;
  height: 100%;
  background: #000;
}

.video-player-controls {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  background: linear-gradient(to top, rgba(0,0,0,0.7), transparent);
  padding: 20px;
  opacity: 0;
  transition: opacity 0.3s;
}

.video-player-container:hover .video-player-controls {
  opacity: 1;
}

/* タッチデバイス用の調整 */
@media (hover: none) {
  .video-player-controls {
    opacity: 1;
  }
}

/* コンテキストメニューの無効化 */
.no-context-menu {
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -khtml-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

/* アニメーション */
@keyframes fadeIn {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}

@keyframes slideIn {
  from {
    transform: translateY(20px);
    opacity: 0;
  }
  to {
    transform: translateY(0);
    opacity: 1;
  }
}

.fade-in {
  animation: fadeIn 0.3s ease-in;
}

.slide-in {
  animation: slideIn 0.3s ease-out;
}

/* GIFサムネイルのホバー効果 */
.thumbnail-gif {
  transition: transform 0.2s, box-shadow 0.2s;
  cursor: pointer;
}

.thumbnail-gif:hover {
  transform: scale(1.05);
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
}

/* 選択モード */
.selection-mode {
  border: 2px solid transparent;
  transition: border-color 0.2s;
}

.selection-mode.selected {
  border-color: #1976d2;
  background: rgba(25, 118, 210, 0.1);
}

/* ドラッグ&ドロップ */
.drag-over {
  background: rgba(25, 118, 210, 0.2);
  border: 2px dashed #1976d2;
}

/* リサイズハンドル */
.resize-handle {
  position: absolute;
  background: #1976d2;
  opacity: 0;
  transition: opacity 0.2s;
}

.resize-handle:hover {
  opacity: 1;
}

.resize-handle-horizontal {
  width: 100%;
  height: 4px;
  cursor: ns-resize;
}

.resize-handle-vertical {
  width: 4px;
  height: 100%;
  cursor: ew-resize;
}

/* フルスクリーンモード */
.fullscreen-container {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  z-index: 9999;
  background: #000;
}

/* ローディングスピナー */
.loading-spinner {
  display: inline-block;
  width: 40px;
  height: 40px;
  border: 4px solid rgba(255, 255, 255, 0.3);
  border-radius: 50%;
  border-top-color: #1976d2;
  animation: spin 0.8s linear infinite;
}

@keyframes spin {
  to {
    transform: rotate(360deg);
  }
}

/* バーチャルスクロール用の高さ固定 */
.virtual-list-container {
  height: 100%;
  overflow: auto;
}

/* タブレット・モバイル対応 */
@media (max-width: 768px) {
  .video-grid {
    grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
  }
  
  .video-controls {
    font-size: 14px;
  }
}

@media (max-width: 480px) {
  .video-grid {
    grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
  }
}
```

```frontend/src/main.jsx
import React from "react";
import ReactDOM from "react-dom/client";
import { BrowserRouter } from "react-router-dom";
import { ThemeProvider, createTheme } from "@mui/material/styles";
import CssBaseline from "@mui/material/CssBaseline";
import { LocalizationProvider } from "@mui/x-date-pickers";
import { AdapterDateFns } from "@mui/x-date-pickers/AdapterDateFns";
import ja from "date-fns/locale/ja";
import App from "./App";
import "./index.css";

// MUIテーマの設定
const theme = createTheme({
    palette: {
        mode: "dark",
        primary: {
            main: "#1976d2",
        },
        secondary: {
            main: "#dc004e",
        },
        background: {
            default: "#121212",
            paper: "#1e1e1e",
        },
    },
    typography: {
        fontFamily: [
            "Roboto",
            "-apple-system",
            "BlinkMacSystemFont",
            '"Segoe UI"',
            '"Helvetica Neue"',
            "Arial",
            "sans-serif",
        ].join(","),
    },
    components: {
        MuiCssBaseline: {
            styleOverrides: {
                body: {
                    scrollbarColor: "#6b6b6b #2b2b2b",
                    "&::-webkit-scrollbar, & *::-webkit-scrollbar": {
                        backgroundColor: "#2b2b2b",
                        width: "10px",
                        height: "10px",
                    },
                    "&::-webkit-scrollbar-thumb, & *::-webkit-scrollbar-thumb":
                        {
                            borderRadius: 8,
                            backgroundColor: "#6b6b6b",
                            minHeight: 24,
                            border: "2px solid #2b2b2b",
                        },
                    "&::-webkit-scrollbar-thumb:focus, & *::-webkit-scrollbar-thumb:focus":
                        {
                            backgroundColor: "#959595",
                        },
                    "&::-webkit-scrollbar-thumb:active, & *::-webkit-scrollbar-thumb:active":
                        {
                            backgroundColor: "#959595",
                        },
                    "&::-webkit-scrollbar-thumb:hover, & *::-webkit-scrollbar-thumb:hover":
                        {
                            backgroundColor: "#959595",
                        },
                },
            },
        },
    },
});

ReactDOM.createRoot(document.getElementById("root")).render(
    <React.StrictMode>
        <BrowserRouter future={{ v7_relativeSplatPath: true }}>
            <ThemeProvider theme={theme}>
                <CssBaseline />
                <LocalizationProvider
                    dateAdapter={AdapterDateFns}
                    adapterLocale={ja}
                >
                    <App />
                </LocalizationProvider>
            </ThemeProvider>
        </BrowserRouter>
    </React.StrictMode>
);

```

```frontend/src/pages/AllFilesPage.jsx
import React, { useState, useEffect, useCallback } from "react";
import { useAtom } from "jotai";
import { Box, CircularProgress, Typography } from "@mui/material";

import FileGrid from "@components/files/FileGrid";
import FileList from "@components/files/FileList";
import FileSelectionBar from "@components/files/FileSelectionBar";
import VideoPlayerModal from "@components/player/VideoPlayerModal";

import {
    viewModeAtom,
    multiSelectModeAtom,
    selectedFilesAtom,
    searchQueryAtom,
    sortSettingsAtom,
    loadingAtom,
    notificationAtom,
} from "@store/atoms";

import { fileAPI } from "@services/api";

function AllFilesPage() {
    const [viewMode] = useAtom(viewModeAtom);
    const [multiSelectMode] = useAtom(multiSelectModeAtom);
    const [selectedFiles, setSelectedFiles] = useAtom(selectedFilesAtom);
    const [searchQuery] = useAtom(searchQueryAtom);
    const [sortSettings] = useAtom(sortSettingsAtom);
    const [loading, setLoading] = useAtom(loadingAtom);
    const [, setNotification] = useAtom(notificationAtom);

    const [files, setFiles] = useState([]);
    const [page, setPage] = useState(1);
    const [hasMore, setHasMore] = useState(true);
    const [totalCount, setTotalCount] = useState(0);

    // 再生中のファイル
    const [playingFile, setPlayingFile] = useState(null);
    const [playerOpen, setPlayerOpen] = useState(false);

    // ファイル取得
    const fetchFiles = useCallback(
        async (reset = false) => {
            if (loading) return;

            setLoading(true);
            try {
                const params = {
                    page: reset ? 1 : page,
                    page_size: 100,
                    search: searchQuery,
                    sort_by: `${sortSettings.order === "desc" ? "-" : ""}${
                        sortSettings.field
                    }`,
                };

                const response = await fileAPI.getAllFiles(params);

                if (reset) {
                    setFiles(response.results || response);
                    setPage(2);
                } else {
                    setFiles((prev) => [
                        ...prev,
                        ...(response.results || response),
                    ]);
                    setPage((prev) => prev + 1);
                }

                setHasMore(response.next !== null);
                setTotalCount(response.count || response.length);
            } catch (error) {
                console.error("Failed to fetch files:", error);
                setNotification({
                    open: true,
                    message: "ファイルの取得に失敗しました",
                    severity: "error",
                });
            } finally {
                setLoading(false);
            }
        },
        [page, searchQuery, sortSettings, loading, setLoading, setNotification]
    );

    // 初回読み込み & 検索・ソート変更時
    useEffect(() => {
        fetchFiles(true);
    }, [searchQuery, sortSettings]);

    // ファイル選択
    const handleFileSelect = useCallback(
        (file) => {
            if (multiSelectMode) {
                setSelectedFiles((prev) => {
                    const isSelected = prev.some((f) => f.id === file.id);
                    if (isSelected) {
                        return prev.filter((f) => f.id !== file.id);
                    } else {
                        return [...prev, file];
                    }
                });
            } else {
                // シングルクリックで再生
                setPlayingFile(file);
                setPlayerOpen(true);
            }
        },
        [multiSelectMode, setSelectedFiles]
    );

    // 全選択/全解除
    const handleSelectAll = useCallback(() => {
        if (selectedFiles.length === files.length) {
            setSelectedFiles([]);
        } else {
            setSelectedFiles(files);
        }
    }, [files, selectedFiles, setSelectedFiles]);

    // ファイル操作
    const handleFileAction = useCallback(
        async (action, fileIds = null) => {
            const targetIds = fileIds || selectedFiles.map((f) => f.id);
            if (targetIds.length === 0) return;

            setLoading(true);
            try {
                switch (action) {
                    case "delete":
                        await fileAPI.bulkAction({
                            file_ids: targetIds,
                            action: "delete",
                        });
                        setFiles((prev) =>
                            prev.filter((f) => !targetIds.includes(f.id))
                        );
                        setNotification({
                            open: true,
                            message: `${targetIds.length}個のファイルを削除しました`,
                            severity: "success",
                        });
                        break;

                    case "addToFolder":
                        // フォルダ選択ダイアログを開く処理
                        break;

                    case "addTags":
                        // タグ追加ダイアログを開く処理
                        break;

                    default:
                        break;
                }

                setSelectedFiles([]);
            } catch (error) {
                console.error("File action failed:", error);
                setNotification({
                    open: true,
                    message: "操作に失敗しました",
                    severity: "error",
                });
            } finally {
                setLoading(false);
            }
        },
        [selectedFiles, setSelectedFiles, setLoading, setNotification]
    );

    // コンテキストメニュー処理
    const handleContextMenu = useCallback((event, file) => {
        event.preventDefault();
        // コンテキストメニューを表示する処理
    }, []);

    // 無限スクロール
    const handleLoadMore = useCallback(() => {
        if (hasMore && !loading) {
            fetchFiles();
        }
    }, [hasMore, loading, fetchFiles]);

    // プレイヤーで次の動画へ
    const handleNextVideo = useCallback(() => {
        const currentIndex = files.findIndex((f) => f.id === playingFile?.id);
        if (currentIndex < files.length - 1) {
            setPlayingFile(files[currentIndex + 1]);
        }
    }, [files, playingFile]);

    // プレイヤーで前の動画へ
    const handlePrevVideo = useCallback(() => {
        const currentIndex = files.findIndex((f) => f.id === playingFile?.id);
        if (currentIndex > 0) {
            setPlayingFile(files[currentIndex - 1]);
        }
    }, [files, playingFile]);

    return (
        <Box sx={{ height: "100%", display: "flex", flexDirection: "column" }}>
            {/* ヘッダー情報 */}
            <Box sx={{ p: 2, borderBottom: 1, borderColor: "divider" }}>
                <Typography variant="h6">
                    全ファイル ({totalCount}件)
                </Typography>
            </Box>

            {/* ファイル表示エリア */}
            <Box sx={{ flexGrow: 1, overflow: "auto", p: 2 }}>
                {loading && files.length === 0 ? (
                    <Box
                        sx={{ display: "flex", justifyContent: "center", p: 4 }}
                    >
                        <CircularProgress />
                    </Box>
                ) : files.length === 0 ? (
                    <Box sx={{ textAlign: "center", p: 4 }}>
                        <Typography variant="h6" color="text.secondary">
                            ファイルが見つかりません
                        </Typography>
                    </Box>
                ) : viewMode === "thumbnail" ? (
                    <FileGrid
                        files={files}
                        selectedFiles={selectedFiles}
                        onFileSelect={handleFileSelect}
                        onContextMenu={handleContextMenu}
                        onLoadMore={handleLoadMore}
                        hasMore={hasMore}
                        loading={loading}
                    />
                ) : (
                    <FileList
                        files={files}
                        selectedFiles={selectedFiles}
                        onFileSelect={handleFileSelect}
                        onContextMenu={handleContextMenu}
                        onLoadMore={handleLoadMore}
                        hasMore={hasMore}
                        loading={loading}
                    />
                )}
            </Box>

            {/* 複数選択時の操作バー */}
            {multiSelectMode && selectedFiles.length > 0 && (
                <FileSelectionBar
                    selectedCount={selectedFiles.length}
                    totalCount={files.length}
                    onSelectAll={handleSelectAll}
                    onAction={handleFileAction}
                />
            )}

            {/* 動画プレイヤーモーダル */}
            {playerOpen && playingFile && (
                <VideoPlayerModal
                    file={playingFile}
                    open={playerOpen}
                    onClose={() => setPlayerOpen(false)}
                    onNext={handleNextVideo}
                    onPrev={handlePrevVideo}
                />
            )}
        </Box>
    );
}

export default AllFilesPage;

```

```frontend/src/pages/DeletedFilesPage.jsx
import React, { useState, useEffect, useCallback } from "react";
import { useAtom } from "jotai";
import { Box, Typography, Button } from "@mui/material";
import { Restore as RestoreIcon } from "@mui/icons-material";

import FileGrid from "@components/files/FileGrid";
import FileList from "@components/files/FileList";

import {
    viewModeAtom,
    multiSelectModeAtom,
    selectedFilesAtom,
    searchQueryAtom,
    sortSettingsAtom,
    loadingAtom,
    notificationAtom,
} from "@store/atoms";

import { fileAPI } from "@services/api";

function DeletedFilesPage() {
    const [viewMode] = useAtom(viewModeAtom);
    const [multiSelectMode] = useAtom(multiSelectModeAtom);
    const [selectedFiles, setSelectedFiles] = useAtom(selectedFilesAtom);
    const [searchQuery] = useAtom(searchQueryAtom);
    const [sortSettings] = useAtom(sortSettingsAtom);
    const [loading, setLoading] = useAtom(loadingAtom);
    const [, setNotification] = useAtom(notificationAtom);

    const [files, setFiles] = useState([]);

    const fetchFiles = useCallback(async () => {
        setLoading(true);
        try {
            const response = await fileAPI.getDeletedFiles({
                search: searchQuery,
                sort_by: `${sortSettings.order === "desc" ? "-" : ""}${
                    sortSettings.field
                }`,
            });
            setFiles(response.results || response);
        } catch (error) {
            setNotification({
                open: true,
                message: "ファイルの取得に失敗しました",
                severity: "error",
            });
        } finally {
            setLoading(false);
        }
    }, [searchQuery, sortSettings, setLoading, setNotification]);

    useEffect(() => {
        fetchFiles();
    }, [fetchFiles]);

    const handleFileSelect = useCallback(
        (file) => {
            if (multiSelectMode) {
                setSelectedFiles((prev) => {
                    const isSelected = prev.some((f) => f.id === file.id);
                    return isSelected
                        ? prev.filter((f) => f.id !== file.id)
                        : [...prev, file];
                });
            }
        },
        [multiSelectMode, setSelectedFiles]
    );

    const handleRestoreSelected = async () => {
        if (selectedFiles.length === 0) return;

        setLoading(true);
        try {
            await fileAPI.bulkAction({
                file_ids: selectedFiles.map((f) => f.id),
                action: "restore",
            });

            setNotification({
                open: true,
                message: `${selectedFiles.length}個のファイルを復元しました`,
                severity: "success",
            });

            setSelectedFiles([]);
            fetchFiles();
        } catch (error) {
            setNotification({
                open: true,
                message: "復元に失敗しました",
                severity: "error",
            });
        } finally {
            setLoading(false);
        }
    };

    return (
        <Box sx={{ height: "100%", display: "flex", flexDirection: "column" }}>
            <Box sx={{ p: 2, borderBottom: 1, borderColor: "divider" }}>
                <Box
                    sx={{
                        display: "flex",
                        alignItems: "center",
                        justifyContent: "space-between",
                    }}
                >
                    <Box>
                        <Typography variant="h6">
                            削除済みファイル ({files.length}件)
                        </Typography>
                        <Typography variant="body2" color="text.secondary">
                            削除フラグが設定されているファイルです
                        </Typography>
                    </Box>
                    {multiSelectMode && selectedFiles.length > 0 && (
                        <Button
                            variant="contained"
                            startIcon={<RestoreIcon />}
                            onClick={handleRestoreSelected}
                        >
                            選択したファイルを復元 ({selectedFiles.length}件)
                        </Button>
                    )}
                </Box>
            </Box>

            <Box sx={{ flexGrow: 1, overflow: "auto", p: 2 }}>
                {files.length === 0 ? (
                    <Box sx={{ textAlign: "center", py: 8 }}>
                        <Typography variant="h6" color="text.secondary">
                            削除されたファイルはありません
                        </Typography>
                    </Box>
                ) : viewMode === "thumbnail" ? (
                    <FileGrid
                        files={files}
                        selectedFiles={selectedFiles}
                        onFileSelect={handleFileSelect}
                        onContextMenu={() => {}}
                        onLoadMore={() => {}}
                        hasMore={false}
                        loading={loading}
                    />
                ) : (
                    <FileList
                        files={files}
                        selectedFiles={selectedFiles}
                        onFileSelect={handleFileSelect}
                        onContextMenu={() => {}}
                        onLoadMore={() => {}}
                        hasMore={false}
                        loading={loading}
                    />
                )}
            </Box>
        </Box>
    );
}

export default DeletedFilesPage;

```

```frontend/src/pages/DuplicateFilesPage.jsx
import React, { useState, useEffect, useCallback } from "react";
import { useAtom } from "jotai";
import { Box, Typography, Chip } from "@mui/material";

import FileGrid from "@components/files/FileGrid";
import FileList from "@components/files/FileList";

import {
    viewModeAtom,
    multiSelectModeAtom,
    selectedFilesAtom,
    searchQueryAtom,
    sortSettingsAtom,
    loadingAtom,
    notificationAtom,
} from "@store/atoms";

import { fileAPI } from "@services/api";

function DuplicateFilesPage() {
    const [viewMode] = useAtom(viewModeAtom);
    const [multiSelectMode] = useAtom(multiSelectModeAtom);
    const [selectedFiles, setSelectedFiles] = useAtom(selectedFilesAtom);
    const [searchQuery] = useAtom(searchQueryAtom);
    const [sortSettings] = useAtom(sortSettingsAtom);
    const [loading, setLoading] = useAtom(loadingAtom);
    const [, setNotification] = useAtom(notificationAtom);

    const [files, setFiles] = useState([]);
    const [duplicateGroups, setDuplicateGroups] = useState([]);

    const fetchFiles = useCallback(async () => {
        setLoading(true);
        try {
            const response = await fileAPI.getDuplicateFiles({
                search: searchQuery,
                sort_by: `${sortSettings.order === "desc" ? "-" : ""}${
                    sortSettings.field
                }`,
            });

            const allFiles = response.results || response;
            setFiles(allFiles);

            // 重複グループを作成（MD5ハッシュでグループ化）
            const groups = {};
            allFiles.forEach((file) => {
                const key = `${file.md5_hash}_${file.file_size}`;
                if (!groups[key]) {
                    groups[key] = [];
                }
                groups[key].push(file);
            });

            setDuplicateGroups(
                Object.values(groups).filter((group) => group.length > 1)
            );
        } catch (error) {
            setNotification({
                open: true,
                message: "ファイルの取得に失敗しました",
                severity: "error",
            });
        } finally {
            setLoading(false);
        }
    }, [searchQuery, sortSettings, setLoading, setNotification]);

    useEffect(() => {
        fetchFiles();
    }, [fetchFiles]);

    const handleFileSelect = useCallback(
        (file) => {
            if (multiSelectMode) {
                setSelectedFiles((prev) => {
                    const isSelected = prev.some((f) => f.id === file.id);
                    return isSelected
                        ? prev.filter((f) => f.id !== file.id)
                        : [...prev, file];
                });
            }
        },
        [multiSelectMode, setSelectedFiles]
    );

    return (
        <Box sx={{ height: "100%", display: "flex", flexDirection: "column" }}>
            <Box sx={{ p: 2, borderBottom: 1, borderColor: "divider" }}>
                <Typography variant="h6">
                    重複ファイル ({files.length}件)
                </Typography>
                <Typography variant="body2" color="text.secondary">
                    同じMD5ハッシュとファイルサイズを持つファイルです
                </Typography>
                {duplicateGroups.length > 0 && (
                    <Chip
                        label={`${duplicateGroups.length}個の重複グループ`}
                        color="warning"
                        size="small"
                        sx={{ mt: 1 }}
                    />
                )}
            </Box>

            <Box sx={{ flexGrow: 1, overflow: "auto", p: 2 }}>
                {files.length === 0 ? (
                    <Box sx={{ textAlign: "center", py: 8 }}>
                        <Typography variant="h6" color="text.secondary">
                            重複ファイルはありません
                        </Typography>
                    </Box>
                ) : viewMode === "thumbnail" ? (
                    <FileGrid
                        files={files}
                        selectedFiles={selectedFiles}
                        onFileSelect={handleFileSelect}
                        onContextMenu={() => {}}
                        onLoadMore={() => {}}
                        hasMore={false}
                        loading={loading}
                    />
                ) : (
                    <FileList
                        files={files}
                        selectedFiles={selectedFiles}
                        onFileSelect={handleFileSelect}
                        onContextMenu={() => {}}
                        onLoadMore={() => {}}
                        hasMore={false}
                        loading={loading}
                    />
                )}
            </Box>
        </Box>
    );
}

export default DuplicateFilesPage;

```

```frontend/src/pages/FoldersPage.jsx
import React, { useState, useEffect, useCallback } from "react";
import { useParams, useNavigate } from "react-router-dom";
import { useAtom } from "jotai";
import {
    Box,
    Breadcrumbs,
    Link,
    Typography,
    IconButton,
    Button,
    Dialog,
    DialogTitle,
    DialogContent,
    DialogActions,
    TextField,
    Fab,
    Menu,
    MenuItem,
    Grid,
    Paper,
    Chip,
} from "@mui/material";
import {
    NavigateNext as NavigateNextIcon,
    ArrowBack as BackIcon,
    CreateNewFolder as NewFolderIcon,
    Home as HomeIcon,
    Folder as FolderIcon,
    Edit as EditIcon,
    Delete as DeleteIcon,
    MoreVert as MoreIcon,
} from "@mui/icons-material";

import FileGrid from "@components/files/FileGrid";
import FileList from "@components/files/FileList";
import FileSelectionBar from "@components/files/FileSelectionBar";

import {
    viewModeAtom,
    multiSelectModeAtom,
    selectedFilesAtom,
    currentFolderAtom,
    folderPathAtom,
    folderActionModeAtom,
    loadingAtom,
    notificationAtom,
} from "@store/atoms";

import { folderAPI, fileAPI } from "@services/api";

function FoldersPage() {
    const { folderId } = useParams();
    const navigate = useNavigate();

    const [viewMode] = useAtom(viewModeAtom);
    const [multiSelectMode] = useAtom(multiSelectModeAtom);
    const [selectedFiles, setSelectedFiles] = useAtom(selectedFilesAtom);
    const [currentFolder, setCurrentFolder] = useAtom(currentFolderAtom);
    const [folderPath, setFolderPath] = useAtom(folderPathAtom);
    const [folderActionMode, setFolderActionMode] =
        useAtom(folderActionModeAtom);
    const [loading, setLoading] = useAtom(loadingAtom);
    const [, setNotification] = useAtom(notificationAtom);

    const [folders, setFolders] = useState([]);
    const [files, setFiles] = useState([]);
    const [newFolderDialog, setNewFolderDialog] = useState(false);
    const [newFolderName, setNewFolderName] = useState("");
    const [editingFolder, setEditingFolder] = useState(null);
    const [contextMenuAnchor, setContextMenuAnchor] = useState(null);
    const [contextMenuFolder, setContextMenuFolder] = useState(null);

    // フォルダとファイルの取得
    const fetchFolderContent = useCallback(async () => {
        setLoading(true);
        try {
            // フォルダ一覧取得
            const foldersResponse = await folderAPI.getFolders({
                parent_id: folderId || "null",
            });
            setFolders(foldersResponse);

            // 現在のフォルダ情報取得
            if (folderId) {
                const folderInfo = await folderAPI.getFolder(folderId);
                setCurrentFolder(folderInfo);

                // パンくずリストの構築
                const ancestors = [];
                let current = folderInfo;
                while (current.parent) {
                    ancestors.unshift(current.parent);
                    current = current.parent;
                }
                setFolderPath(ancestors);

                // フォルダ内のファイル取得
                const filesResponse = await fileAPI.getFiles({
                    folder_id: folderId,
                });
                setFiles(filesResponse.results || filesResponse);
            } else {
                setCurrentFolder(null);
                setFolderPath([]);
                setFiles([]);
            }
        } catch (error) {
            console.error("Failed to fetch folder content:", error);
            setNotification({
                open: true,
                message: "フォルダの読み込みに失敗しました",
                severity: "error",
            });
        } finally {
            setLoading(false);
        }
    }, [
        folderId,
        setLoading,
        setNotification,
        setCurrentFolder,
        setFolderPath,
    ]);

    useEffect(() => {
        fetchFolderContent();
    }, [folderId]);

    // フォルダ作成
    const handleCreateFolder = async () => {
        if (!newFolderName.trim()) return;

        try {
            await folderAPI.createFolder({
                folder_name: newFolderName,
                parent_id: folderId || null,
            });

            setNotification({
                open: true,
                message: "フォルダを作成しました",
                severity: "success",
            });

            setNewFolderDialog(false);
            setNewFolderName("");
            fetchFolderContent();
        } catch (error) {
            setNotification({
                open: true,
                message: "フォルダの作成に失敗しました",
                severity: "error",
            });
        }
    };

    // フォルダ名変更
    const handleRenameFolder = async () => {
        if (!editingFolder || !newFolderName.trim()) return;

        try {
            await folderAPI.updateFolder(editingFolder.id, {
                folder_name: newFolderName,
            });

            setNotification({
                open: true,
                message: "フォルダ名を変更しました",
                severity: "success",
            });

            setEditingFolder(null);
            setNewFolderName("");
            fetchFolderContent();
        } catch (error) {
            setNotification({
                open: true,
                message: "フォルダ名の変更に失敗しました",
                severity: "error",
            });
        }
    };

    // フォルダ削除
    const handleDeleteFolder = async (folder) => {
        if (!confirm(`フォルダ「${folder.folder_name}」を削除しますか？`))
            return;

        try {
            await folderAPI.deleteFolder(folder.id);

            setNotification({
                open: true,
                message: "フォルダを削除しました",
                severity: "success",
            });

            fetchFolderContent();
        } catch (error) {
            setNotification({
                open: true,
                message: "フォルダの削除に失敗しました",
                severity: "error",
            });
        }
    };

    // フォルダクリック
    const handleFolderClick = (folder) => {
        navigate(`/folders/${folder.id}`);
    };

    // フォルダコンテキストメニュー
    const handleFolderContextMenu = (event, folder) => {
        event.preventDefault();
        setContextMenuAnchor({ x: event.clientX, y: event.clientY });
        setContextMenuFolder(folder);
    };

    // ファイル選択
    const handleFileSelect = useCallback(
        (file) => {
            if (multiSelectMode) {
                setSelectedFiles((prev) => {
                    const isSelected = prev.some((f) => f.id === file.id);
                    if (isSelected) {
                        return prev.filter((f) => f.id !== file.id);
                    } else {
                        return [...prev, file];
                    }
                });
            }
        },
        [multiSelectMode, setSelectedFiles]
    );

    // フォルダへの移動/コピーモード
    const handleFolderAction = useCallback(() => {
        if (!folderActionMode.active) return;

        const action = folderActionMode.action;
        const targetFiles = folderActionMode.files;

        if (action === "move" || action === "copy") {
            // 現在のフォルダに移動/コピー
            targetFiles.forEach(async (file) => {
                try {
                    await fileAPI.addToFolder(file.id, folderId || null);
                } catch (error) {
                    console.error("Failed to add file to folder:", error);
                }
            });

            setNotification({
                open: true,
                message: `${targetFiles.length}個のファイルを${
                    action === "move" ? "移動" : "コピー"
                }しました`,
                severity: "success",
            });

            setFolderActionMode({ active: false, action: null, files: [] });
            fetchFolderContent();
        }
    }, [
        folderActionMode,
        folderId,
        setFolderActionMode,
        setNotification,
        fetchFolderContent,
    ]);

    return (
        <Box sx={{ height: "100%", display: "flex", flexDirection: "column" }}>
            {/* ヘッダー */}
            <Box sx={{ p: 2, borderBottom: 1, borderColor: "divider" }}>
                {/* パンくずリスト */}
                <Breadcrumbs separator={<NavigateNextIcon fontSize="small" />}>
                    <Link
                        component="button"
                        variant="body1"
                        onClick={() => navigate("/folders")}
                        sx={{ display: "flex", alignItems: "center" }}
                    >
                        <HomeIcon sx={{ mr: 0.5 }} fontSize="small" />
                        ルート
                    </Link>
                    {folderPath.map((folder, index) => (
                        <Link
                            key={folder.id}
                            component="button"
                            variant="body1"
                            onClick={() => navigate(`/folders/${folder.id}`)}
                            disabled={index === folderPath.length - 1}
                        >
                            {folder.folder_name}
                        </Link>
                    ))}
                    {currentFolder && (
                        <Typography color="text.primary">
                            {currentFolder.folder_name}
                        </Typography>
                    )}
                </Breadcrumbs>

                {/* フォルダアクションモード時の表示 */}
                {folderActionMode.active && (
                    <Box sx={{ mt: 2 }}>
                        <Chip
                            label={`${
                                folderActionMode.files.length
                            }個のファイルを${
                                folderActionMode.action === "move"
                                    ? "移動"
                                    : "コピー"
                            }中`}
                            color="primary"
                            sx={{ mr: 2 }}
                        />
                        <Button
                            variant="contained"
                            onClick={handleFolderAction}
                            sx={{ mr: 1 }}
                        >
                            このフォルダへ
                            {folderActionMode.action === "move"
                                ? "移動"
                                : "コピー"}
                        </Button>
                        <Button
                            variant="outlined"
                            onClick={() =>
                                setFolderActionMode({
                                    active: false,
                                    action: null,
                                    files: [],
                                })
                            }
                        >
                            キャンセル
                        </Button>
                    </Box>
                )}
            </Box>

            {/* コンテンツエリア */}
            <Box sx={{ flexGrow: 1, overflow: "auto", p: 2 }}>
                {/* フォルダ一覧 */}
                {folders.length > 0 && (
                    <Box sx={{ mb: 3 }}>
                        <Typography variant="h6" sx={{ mb: 2 }}>
                            フォルダ ({folders.length})
                        </Typography>
                        <Grid container spacing={2}>
                            {folders.map((folder) => (
                                <Grid
                                    item
                                    xs={6}
                                    sm={4}
                                    md={3}
                                    lg={2}
                                    key={folder.id}
                                >
                                    <Paper
                                        sx={{
                                            p: 2,
                                            cursor: "pointer",
                                            transition: "all 0.2s",
                                            "&:hover": {
                                                bgcolor: "action.hover",
                                                transform: "scale(1.02)",
                                            },
                                        }}
                                        onClick={() =>
                                            handleFolderClick(folder)
                                        }
                                        onContextMenu={(e) =>
                                            handleFolderContextMenu(e, folder)
                                        }
                                    >
                                        <Box
                                            sx={{
                                                display: "flex",
                                                alignItems: "center",
                                                mb: 1,
                                            }}
                                        >
                                            <FolderIcon
                                                sx={{
                                                    mr: 1,
                                                    color: "primary.main",
                                                }}
                                            />
                                            <IconButton
                                                size="small"
                                                onClick={(e) => {
                                                    e.stopPropagation();
                                                    handleFolderContextMenu(
                                                        e,
                                                        folder
                                                    );
                                                }}
                                            >
                                                <MoreIcon fontSize="small" />
                                            </IconButton>
                                        </Box>
                                        <Typography variant="body2" noWrap>
                                            {folder.folder_name}
                                        </Typography>
                                        <Typography
                                            variant="caption"
                                            color="text.secondary"
                                        >
                                            {folder.files_count || 0} ファイル
                                        </Typography>
                                    </Paper>
                                </Grid>
                            ))}
                        </Grid>
                    </Box>
                )}

                {/* ファイル一覧 */}
                {files.length > 0 && (
                    <Box>
                        <Typography variant="h6" sx={{ mb: 2 }}>
                            ファイル ({files.length})
                        </Typography>
                        {viewMode === "thumbnail" ? (
                            <FileGrid
                                files={files}
                                selectedFiles={selectedFiles}
                                onFileSelect={handleFileSelect}
                                onContextMenu={() => {}}
                                onLoadMore={() => {}}
                                hasMore={false}
                                loading={loading}
                            />
                        ) : (
                            <FileList
                                files={files}
                                selectedFiles={selectedFiles}
                                onFileSelect={handleFileSelect}
                                onContextMenu={() => {}}
                                onLoadMore={() => {}}
                                hasMore={false}
                                loading={loading}
                            />
                        )}
                    </Box>
                )}

                {/* 空の状態 */}
                {folders.length === 0 && files.length === 0 && !loading && (
                    <Box sx={{ textAlign: "center", py: 8 }}>
                        <FolderIcon
                            sx={{ fontSize: 64, color: "text.disabled", mb: 2 }}
                        />
                        <Typography variant="h6" color="text.secondary">
                            このフォルダは空です
                        </Typography>
                        <Button
                            startIcon={<NewFolderIcon />}
                            onClick={() => setNewFolderDialog(true)}
                            sx={{ mt: 2 }}
                        >
                            新しいフォルダを作成
                        </Button>
                    </Box>
                )}
            </Box>

            {/* 新規フォルダ作成ボタン */}
            <Fab
                color="primary"
                aria-label="新規フォルダ"
                sx={{ position: "fixed", bottom: 16, right: 16 }}
                onClick={() => setNewFolderDialog(true)}
            >
                <NewFolderIcon />
            </Fab>

            {/* 新規フォルダ作成ダイアログ */}
            <Dialog
                open={newFolderDialog}
                onClose={() => setNewFolderDialog(false)}
            >
                <DialogTitle>新しいフォルダを作成</DialogTitle>
                <DialogContent>
                    <TextField
                        autoFocus
                        margin="dense"
                        label="フォルダ名"
                        fullWidth
                        value={newFolderName}
                        onChange={(e) => setNewFolderName(e.target.value)}
                        onKeyPress={(e) => {
                            if (e.key === "Enter") {
                                handleCreateFolder();
                            }
                        }}
                    />
                </DialogContent>
                <DialogActions>
                    <Button onClick={() => setNewFolderDialog(false)}>
                        キャンセル
                    </Button>
                    <Button onClick={handleCreateFolder} variant="contained">
                        作成
                    </Button>
                </DialogActions>
            </Dialog>

            {/* フォルダ名変更ダイアログ */}
            <Dialog
                open={Boolean(editingFolder)}
                onClose={() => setEditingFolder(null)}
            >
                <DialogTitle>フォルダ名を変更</DialogTitle>
                <DialogContent>
                    <TextField
                        autoFocus
                        margin="dense"
                        label="新しいフォルダ名"
                        fullWidth
                        value={newFolderName}
                        onChange={(e) => setNewFolderName(e.target.value)}
                        onKeyPress={(e) => {
                            if (e.key === "Enter") {
                                handleRenameFolder();
                            }
                        }}
                    />
                </DialogContent>
                <DialogActions>
                    <Button onClick={() => setEditingFolder(null)}>
                        キャンセル
                    </Button>
                    <Button onClick={handleRenameFolder} variant="contained">
                        変更
                    </Button>
                </DialogActions>
            </Dialog>

            {/* フォルダコンテキストメニュー */}
            <Menu
                open={Boolean(contextMenuAnchor)}
                onClose={() => setContextMenuAnchor(null)}
                anchorReference="anchorPosition"
                anchorPosition={contextMenuAnchor}
            >
                <MenuItem
                    onClick={() => {
                        setEditingFolder(contextMenuFolder);
                        setNewFolderName(contextMenuFolder?.folder_name || "");
                        setContextMenuAnchor(null);
                    }}
                >
                    <EditIcon fontSize="small" sx={{ mr: 1 }} />
                    名前を変更
                </MenuItem>
                <MenuItem
                    onClick={() => {
                        handleDeleteFolder(contextMenuFolder);
                        setContextMenuAnchor(null);
                    }}
                >
                    <DeleteIcon fontSize="small" sx={{ mr: 1 }} />
                    削除
                </MenuItem>
            </Menu>

            {/* 複数選択時の操作バー */}
            {multiSelectMode && selectedFiles.length > 0 && (
                <FileSelectionBar
                    selectedCount={selectedFiles.length}
                    totalCount={files.length}
                    onSelectAll={() => {}}
                    onAction={() => {}}
                />
            )}
        </Box>
    );
}

export default FoldersPage;

```

```frontend/src/pages/NoFolderFilesPage.jsx
import React, { useState, useEffect, useCallback } from "react";
import { useAtom } from "jotai";
import { Box, Typography } from "@mui/material";

import FileGrid from "@components/files/FileGrid";
import FileList from "@components/files/FileList";
import VideoPlayerModal from "@components/player/VideoPlayerModal";

import {
    viewModeAtom,
    multiSelectModeAtom,
    selectedFilesAtom,
    searchQueryAtom,
    sortSettingsAtom,
    loadingAtom,
    notificationAtom,
} from "@store/atoms";

import { fileAPI } from "@services/api";

function NoFolderFilesPage() {
    const [viewMode] = useAtom(viewModeAtom);
    const [multiSelectMode] = useAtom(multiSelectModeAtom);
    const [selectedFiles, setSelectedFiles] = useAtom(selectedFilesAtom);
    const [searchQuery] = useAtom(searchQueryAtom);
    const [sortSettings] = useAtom(sortSettingsAtom);
    const [loading, setLoading] = useAtom(loadingAtom);
    const [, setNotification] = useAtom(notificationAtom);

    const [files, setFiles] = useState([]);
    const [playerOpen, setPlayerOpen] = useState(false);
    const [playingFile, setPlayingFile] = useState(null);

    // ファイル取得
    const fetchFiles = useCallback(async () => {
        setLoading(true);
        try {
            const response = await fileAPI.getNoFolderFiles({
                search: searchQuery,
                sort_by: `${sortSettings.order === "desc" ? "-" : ""}${
                    sortSettings.field
                }`,
            });
            setFiles(response.results || response);
        } catch (error) {
            setNotification({
                open: true,
                message: "ファイルの取得に失敗しました",
                severity: "error",
            });
        } finally {
            setLoading(false);
        }
    }, [searchQuery, sortSettings, setLoading, setNotification]);

    useEffect(() => {
        fetchFiles();
    }, [fetchFiles]);

    const handleFileSelect = useCallback(
        (file) => {
            if (multiSelectMode) {
                setSelectedFiles((prev) => {
                    const isSelected = prev.some((f) => f.id === file.id);
                    return isSelected
                        ? prev.filter((f) => f.id !== file.id)
                        : [...prev, file];
                });
            } else {
                setPlayingFile(file);
                setPlayerOpen(true);
            }
        },
        [multiSelectMode, setSelectedFiles]
    );

    return (
        <Box sx={{ height: "100%", display: "flex", flexDirection: "column" }}>
            <Box sx={{ p: 2, borderBottom: 1, borderColor: "divider" }}>
                <Typography variant="h6">
                    フォルダに存在しないファイル ({files.length}件)
                </Typography>
                <Typography variant="body2" color="text.secondary">
                    どのフォルダにも振り分けられていないファイルです
                </Typography>
            </Box>

            <Box sx={{ flexGrow: 1, overflow: "auto", p: 2 }}>
                {viewMode === "thumbnail" ? (
                    <FileGrid
                        files={files}
                        selectedFiles={selectedFiles}
                        onFileSelect={handleFileSelect}
                        onContextMenu={() => {}}
                        onLoadMore={() => {}}
                        hasMore={false}
                        loading={loading}
                    />
                ) : (
                    <FileList
                        files={files}
                        selectedFiles={selectedFiles}
                        onFileSelect={handleFileSelect}
                        onContextMenu={() => {}}
                        onLoadMore={() => {}}
                        hasMore={false}
                        loading={loading}
                    />
                )}
            </Box>

            {playerOpen && playingFile && (
                <VideoPlayerModal
                    file={playingFile}
                    open={playerOpen}
                    onClose={() => setPlayerOpen(false)}
                />
            )}
        </Box>
    );
}

export default NoFolderFilesPage;

```

```frontend/src/services/api.js
import axios from "axios";

const API_BASE_URL =
    import.meta.env.VITE_API_BASE_URL || "http://localhost:8000/api";
const MEDIA_URL =
    import.meta.env.VITE_MEDIA_URL || "http://localhost:8000/media";

// Axiosインスタンスの作成
const api = axios.create({
    baseURL: API_BASE_URL,
    headers: {
        "Content-Type": "application/json",
    },
});

// リクエストインターセプター
api.interceptors.request.use(
    (config) => {
        // 必要に応じて認証トークンなどを追加
        return config;
    },
    (error) => {
        return Promise.reject(error);
    }
);

// レスポンスインターセプター
api.interceptors.response.use(
    (response) => {
        return response.data;
    },
    (error) => {
        console.error("API Error:", error);
        return Promise.reject(error);
    }
);

// ファイル関連API
export const fileAPI = {
    // ファイル一覧取得
    getFiles: (params = {}) => {
        return api.get("/files/", { params });
    },

    // すべてのファイル取得
    getAllFiles: (params = {}) => {
        return api.get("/files/all/", { params });
    },

    // フォルダに属さないファイル取得
    getNoFolderFiles: (params = {}) => {
        return api.get("/files/no-folder/", { params });
    },

    // 削除済みファイル取得
    getDeletedFiles: (params = {}) => {
        return api.get("/files/deleted/", { params });
    },

    // 重複ファイル取得
    getDuplicateFiles: (params = {}) => {
        return api.get("/files/duplicates/", { params });
    },

    // ファイル詳細取得
    getFile: (id) => {
        return api.get(`/files/${id}/`);
    },

    // ファイル更新
    updateFile: (id, data) => {
        return api.patch(`/files/${id}/`, data);
    },

    // 削除フラグ設定
    markAsDeleted: (id) => {
        return api.post(`/files/${id}/mark_deleted/`);
    },

    // 削除フラグ解除
    restoreFile: (id) => {
        return api.post(`/files/${id}/restore/`);
    },

    // フォルダに追加
    addToFolder: (id, folderId) => {
        return api.post(`/files/${id}/add_to_folder/`, { folder_id: folderId });
    },

    // フォルダから削除
    removeFromFolder: (id, folderId) => {
        return api.post(`/files/${id}/remove_from_folder/`, {
            folder_id: folderId,
        });
    },

    // タグ追加
    addTags: (id, tagNames) => {
        return api.post(`/files/${id}/add_tags/`, { tag_names: tagNames });
    },

    // タグ削除
    removeTags: (id, tagNames) => {
        return api.post(`/files/${id}/remove_tags/`, { tag_names: tagNames });
    },

    // 一括操作
    bulkAction: (data) => {
        return api.post("/files/bulk_action/", data);
    },
};

// フォルダ関連API
export const folderAPI = {
    // フォルダ一覧取得
    getFolders: (params = {}) => {
        return api.get("/folders/", { params });
    },

    // フォルダツリー取得
    getFolderTree: () => {
        return api.get("/folders/tree/");
    },

    // フォルダ詳細取得
    getFolder: (id) => {
        return api.get(`/folders/${id}/`);
    },

    // フォルダ作成
    createFolder: (data) => {
        return api.post("/folders/", data);
    },

    // フォルダ更新
    updateFolder: (id, data) => {
        return api.patch(`/folders/${id}/`, data);
    },

    // フォルダ削除
    deleteFolder: (id) => {
        return api.delete(`/folders/${id}/`);
    },
};

// タグ関連API
export const tagAPI = {
    // タグ一覧取得
    getTags: (params = {}) => {
        return api.get("/tags/", { params });
    },

    // 人気タグ取得
    getPopularTags: (limit = 20) => {
        return api.get("/tags/popular/", { params: { limit } });
    },

    // タグ検索
    searchTags: (query) => {
        return api.get("/tags/search/", { params: { q: query } });
    },

    // タグ作成
    createTag: (data) => {
        return api.post("/tags/", data);
    },

    // タグ更新
    updateTag: (id, data) => {
        return api.patch(`/tags/${id}/`, data);
    },

    // タグ削除
    deleteTag: (id) => {
        return api.delete(`/tags/${id}/`);
    },
};

// グループ関連API
export const groupAPI = {
    // グループ一覧取得
    getGroups: () => {
        return api.get("/groups/");
    },

    // グループ作成
    createGroup: (data) => {
        return api.post("/groups/", data);
    },

    // グループ更新
    updateGroup: (id, data) => {
        return api.patch(`/groups/${id}/`, data);
    },

    // グループ削除
    deleteGroup: (id) => {
        return api.delete(`/groups/${id}/`);
    },
};

// システム関連API
export const systemAPI = {
    // 強制スキャン実行
    forceRefresh: () => {
        return api.get("/force_refresh/");
    },

    // スキャン履歴取得
    getScanHistory: () => {
        return api.get("/scan-history/");
    },

    // 最新スキャン履歴取得
    getLatestScan: () => {
        return api.get("/scan-history/latest/");
    },
};

// メディアURL生成ヘルパー
export const getMediaUrl = (path) => {
    if (!path) return null;
    if (path.startsWith("http")) return path;
    return `${MEDIA_URL}/${path}`;
};

// サムネイルURL生成ヘルパー
export const getThumbnailUrl = (file) => {
    if (file.thumbnail_url) {
        return file.thumbnail_url;
    }
    if (file.thumbnail_file_path) {
        return getMediaUrl(file.thumbnail_file_path);
    }
    return null;
};

// 動画URL生成ヘルパー
export const getVideoUrl = (file) => {
    if (file.video_url) {
        return file.video_url;
    }
    if (file.file_path) {
        return getMediaUrl(file.file_path);
    }
    return null;
};

export default api;

```

```frontend/src/store/atoms.js
import { atom } from "jotai";
import { atomWithStorage } from "jotai/utils";

// 表示モード（サムネイル or 詳細）
export const viewModeAtom = atomWithStorage("viewMode", "thumbnail");

// 複数選択モード
export const multiSelectModeAtom = atom(false);

// 選択されたファイル
export const selectedFilesAtom = atom([]);

// 現在のフォルダ
export const currentFolderAtom = atom(null);

// フォルダパス（階層）
export const folderPathAtom = atom([]);

// 検索クエリ
export const searchQueryAtom = atom("");

// フィルター設定
export const filterSettingsAtom = atom({
    showDeleted: false,
    showDuplicates: false,
    showNoFolder: false,
    tags: [],
});

// ソート設定
export const sortSettingsAtom = atomWithStorage("sortSettings", {
    field: "created_at",
    order: "desc",
});

// プレイヤー設定（ローカルストレージに保存）
export const playerSettingsAtom = atomWithStorage("playerSettings", {
    playbackSpeed: 1.0,
    volume: 1.0,
    muted: false,
    loop: false,
    autoPlay: true,
    skipSeconds: 5, // ダブルタップでスキップする秒数
    longPressSpeed: 2.0, // 長押し時の倍速
    aspectRatioFit: "contain", // 'contain' or 'cover'
    abLoop: {
        enabled: false,
        start: null,
        end: null,
    },
});

// 開いているプレイヤー
export const openPlayersAtom = atom([]);

// プレイヤーレイアウトモード
export const playerLayoutModeAtom = atom("free"); // 'free' or 'grid'

// コンテキストメニュー
export const contextMenuAtom = atom({
    open: false,
    x: 0,
    y: 0,
    file: null,
    type: null, // 'file', 'folder', 'background'
});

// 通知
export const notificationAtom = atom({
    open: false,
    message: "",
    severity: "info", // 'success', 'error', 'warning', 'info'
});

// ローディング状態
export const loadingAtom = atom(false);

// フォルダツリー
export const folderTreeAtom = atom([]);

// タグリスト
export const tagsListAtom = atom([]);

// グループリスト
export const groupsListAtom = atom([]);

// 最近使用したタグ
export const recentTagsAtom = atomWithStorage("recentTags", []);

// お気に入りフォルダ
export const favoriteFoldersAtom = atomWithStorage("favoriteFolders", []);

// 表示設定
export const displaySettingsAtom = atomWithStorage("displaySettings", {
    thumbnailSize: "medium", // 'small', 'medium', 'large'
    showFileInfo: true,
    animatedThumbnails: true,
    gridColumns: "auto", // 'auto', 2, 3, 4, 5, 6
});

// キーボードショートカット設定
export const keyboardShortcutsAtom = atomWithStorage("keyboardShortcuts", {
    playPause: " ", // スペースキー
    fullscreen: "f",
    volumeUp: "ArrowUp",
    volumeDown: "ArrowDown",
    seekForward: "ArrowRight",
    seekBackward: "ArrowLeft",
    speedUp: ">",
    speedDown: "<",
    toggleLoop: "l",
    toggleMute: "m",
    nextVideo: "n",
    previousVideo: "p",
});

// ドラッグ中のファイル
export const draggingFilesAtom = atom(null);

// フォルダ移動/コピーモード
export const folderActionModeAtom = atom({
    active: false,
    action: null, // 'move' or 'copy'
    files: [],
});

// 最後に開いたファイル（履歴）
export const fileHistoryAtom = atomWithStorage("fileHistory", []);

// ウィンドウサイズ（レスポンシブ対応）
export const windowSizeAtom = atom({
    width: window.innerWidth,
    height: window.innerHeight,
});

// デバイスタイプ
export const deviceTypeAtom = atom((get) => {
    const { width } = get(windowSizeAtom);
    if (width < 480) return "mobile";
    if (width < 768) return "tablet";
    return "desktop";
});

// タッチデバイスかどうか
export const isTouchDeviceAtom = atom(
    "ontouchstart" in window || navigator.maxTouchPoints > 0
);

```

```frontend/src/utils/format.js
/**
 * フォーマット用ユーティリティ関数
 */

/**
 * 時間を MM:SS または HH:MM:SS 形式にフォーマット
 * @param {number} seconds - 秒数
 * @returns {string} フォーマットされた時間文字列
 */
export const formatTime = (seconds) => {
    if (!seconds || isNaN(seconds)) return "0:00";

    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = Math.floor(seconds % 60);

    if (hours > 0) {
        return `${hours}:${minutes.toString().padStart(2, "0")}:${secs
            .toString()
            .padStart(2, "0")}`;
    }
    return `${minutes}:${secs.toString().padStart(2, "0")}`;
};

/**
 * ファイルサイズを人間が読みやすい形式にフォーマット
 * @param {number} bytes - バイト数
 * @returns {string} フォーマットされたサイズ
 */
export const formatFileSize = (bytes) => {
    if (!bytes || bytes === 0) return "0 B";

    const units = ["B", "KB", "MB", "GB", "TB"];
    const i = Math.floor(Math.log(bytes) / Math.log(1024));

    return `${(bytes / Math.pow(1024, i)).toFixed(2)} ${units[i]}`;
};

/**
 * 日付を相対的な時間表現にフォーマット
 * @param {string|Date} date - 日付
 * @returns {string} 相対時間表現
 */
export const formatRelativeTime = (date) => {
    const now = new Date();
    const target = new Date(date);
    const diff = now - target;

    const seconds = Math.floor(diff / 1000);
    const minutes = Math.floor(seconds / 60);
    const hours = Math.floor(minutes / 60);
    const days = Math.floor(hours / 24);
    const months = Math.floor(days / 30);
    const years = Math.floor(days / 365);

    if (years > 0) return `${years}年前`;
    if (months > 0) return `${months}ヶ月前`;
    if (days > 0) return `${days}日前`;
    if (hours > 0) return `${hours}時間前`;
    if (minutes > 0) return `${minutes}分前`;
    return "たった今";
};

/**
 * 日付を YYYY/MM/DD HH:mm 形式にフォーマット
 * @param {string|Date} date - 日付
 * @returns {string} フォーマットされた日付
 */
export const formatDateTime = (date) => {
    const d = new Date(date);
    const year = d.getFullYear();
    const month = (d.getMonth() + 1).toString().padStart(2, "0");
    const day = d.getDate().toString().padStart(2, "0");
    const hours = d.getHours().toString().padStart(2, "0");
    const minutes = d.getMinutes().toString().padStart(2, "0");

    return `${year}/${month}/${day} ${hours}:${minutes}`;
};

/**
 * ファイル名を短縮表示
 * @param {string} filename - ファイル名
 * @param {number} maxLength - 最大長
 * @returns {string} 短縮されたファイル名
 */
export const truncateFileName = (filename, maxLength = 30) => {
    if (!filename || filename.length <= maxLength) return filename;

    const extension = filename.split(".").pop();
    const nameWithoutExt = filename.slice(0, -(extension.length + 1));
    const truncatedName = nameWithoutExt.slice(
        0,
        maxLength - extension.length - 4
    );

    return `${truncatedName}...${extension}`;
};

/**
 * 数値を3桁ごとにカンマ区切り
 * @param {number} num - 数値
 * @returns {string} カンマ区切りの数値
 */
export const formatNumber = (num) => {
    if (!num && num !== 0) return "0";
    return num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
};

/**
 * 動画の解像度を判定
 * @param {number} width - 幅
 * @param {number} height - 高さ
 * @returns {string} 解像度の名称
 */
export const getResolutionLabel = (width, height) => {
    if (!width || !height) return "Unknown";

    if (height >= 2160) return "4K";
    if (height >= 1440) return "2K";
    if (height >= 1080) return "Full HD";
    if (height >= 720) return "HD";
    if (height >= 480) return "SD";
    return "Low";
};

/**
 * ビットレートを適切な単位でフォーマット
 * @param {number} bitrate - ビットレート（bps）
 * @returns {string} フォーマットされたビットレート
 */
export const formatBitrate = (bitrate) => {
    if (!bitrate) return "Unknown";

    if (bitrate >= 1000000) {
        return `${(bitrate / 1000000).toFixed(2)} Mbps`;
    }
    if (bitrate >= 1000) {
        return `${(bitrate / 1000).toFixed(2)} Kbps`;
    }
    return `${bitrate} bps`;
};

/**
 * パスからファイル名を抽出
 * @param {string} path - ファイルパス
 * @returns {string} ファイル名
 */
export const getFileNameFromPath = (path) => {
    if (!path) return "";
    return path.split(/[/\\]/).pop() || path;
};

/**
 * パスから拡張子を抽出
 * @param {string} path - ファイルパス
 * @returns {string} 拡張子
 */
export const getFileExtension = (path) => {
    if (!path) return "";
    const parts = path.split(".");
    return parts.length > 1 ? parts.pop().toLowerCase() : "";
};

```

```frontend/src/utils/keyboard.js
/**
 * キーボードショートカット処理
 */

import { atom } from "jotai";

// グローバルキーボードショートカット設定
const shortcuts = {
    // ナビゲーション
    "ctrl+1": {
        action: "navigate",
        target: "/all-files",
        description: "全ファイル",
    },
    "ctrl+2": {
        action: "navigate",
        target: "/no-folder",
        description: "フォルダに存在しない",
    },
    "ctrl+3": {
        action: "navigate",
        target: "/folders",
        description: "フォルダ",
    },
    "ctrl+4": {
        action: "navigate",
        target: "/deleted",
        description: "削除ファイル",
    },
    "ctrl+5": {
        action: "navigate",
        target: "/duplicates",
        description: "重複ファイル",
    },

    // 検索
    "ctrl+f": { action: "search", description: "検索" },
    "ctrl+k": { action: "search", description: "検索（代替）" },
    escape: { action: "closeSearch", description: "検索を閉じる" },

    // 表示切替
    "ctrl+shift+v": { action: "toggleView", description: "表示モード切替" },
    "ctrl+m": { action: "toggleMultiSelect", description: "複数選択切替" },

    // ファイル操作
    "ctrl+a": { action: "selectAll", description: "全選択" },
    "ctrl+shift+a": { action: "deselectAll", description: "選択解除" },
    delete: { action: "deleteSelected", description: "選択ファイルを削除" },
    "ctrl+r": { action: "refresh", description: "更新" },

    // プレイヤー（グローバル）
    f11: { action: "fullscreen", description: "フルスクリーン" },
};

// プレイヤー専用ショートカット
const playerShortcuts = {
    " ": { action: "playPause", description: "再生/一時停止" },
    f: { action: "fullscreen", description: "フルスクリーン" },
    m: { action: "mute", description: "ミュート切替" },
    l: { action: "loop", description: "ループ切替" },
    ArrowLeft: { action: "seekBackward", description: "巻き戻し" },
    ArrowRight: { action: "seekForward", description: "スキップ" },
    ArrowUp: { action: "volumeUp", description: "音量アップ" },
    ArrowDown: { action: "volumeDown", description: "音量ダウン" },
    "<": { action: "speedDown", description: "速度ダウン" },
    ">": { action: "speedUp", description: "速度アップ" },
    ",": { action: "speedDown", description: "速度ダウン（代替）" },
    ".": { action: "speedUp", description: "速度アップ（代替）" },
    n: { action: "nextVideo", description: "次の動画" },
    p: { action: "previousVideo", description: "前の動画" },
    a: { action: "setABLoopStart", description: "A-Bループ開始点" },
    b: { action: "setABLoopEnd", description: "A-Bループ終了点" },
    r: { action: "toggleABLoop", description: "A-Bループ切替" },
    1: { action: "speed1x", description: "1倍速" },
    2: { action: "speed2x", description: "2倍速" },
    5: { action: "speed05x", description: "0.5倍速" },
};

// 現在のハンドラーを保存
let currentHandlers = new Map();

/**
 * キーボードイベントからキー文字列を生成
 */
const getKeyString = (event) => {
    const parts = [];

    if (event.ctrlKey || event.metaKey) parts.push("ctrl");
    if (event.shiftKey) parts.push("shift");
    if (event.altKey) parts.push("alt");

    // キー名を正規化
    let key = event.key.toLowerCase();

    // 特殊キーの変換
    const keyMap = {
        arrowleft: "ArrowLeft",
        arrowright: "ArrowRight",
        arrowup: "ArrowUp",
        arrowdown: "ArrowDown",
        escape: "escape",
        enter: "enter",
        delete: "delete",
        " ": " ",
    };

    if (keyMap[key]) {
        key = keyMap[key];
    }

    parts.push(key);

    return parts.join("+");
};

/**
 * ショートカットハンドラーを登録
 */
export const registerShortcut = (keyCombo, handler, options = {}) => {
    const {
        preventDefault = true,
        stopPropagation = false,
        scope = "global",
    } = options;

    const wrappedHandler = (event) => {
        const keyString = getKeyString(event);

        if (keyString === keyCombo) {
            if (preventDefault) event.preventDefault();
            if (stopPropagation) event.stopPropagation();
            handler(event);
            return true;
        }
        return false;
    };

    currentHandlers.set(keyCombo, { handler: wrappedHandler, scope });
    return () => currentHandlers.delete(keyCombo);
};

/**
 * グローバルキーボードショートカットをセットアップ
 */
export const setupKeyboardShortcuts = () => {
    const handleKeyDown = (event) => {
        // 入力フィールドでは無効化
        if (
            event.target.matches("input, textarea, select, [contenteditable]")
        ) {
            return;
        }

        const keyString = getKeyString(event);

        // 登録されたハンドラーを実行
        for (const [combo, { handler }] of currentHandlers) {
            if (handler(event)) {
                return;
            }
        }

        // デフォルトショートカット
        const shortcut = shortcuts[keyString];
        if (shortcut) {
            event.preventDefault();
            handleShortcutAction(shortcut.action, event);
        }
    };

    document.addEventListener("keydown", handleKeyDown);

    return () => {
        document.removeEventListener("keydown", handleKeyDown);
    };
};

/**
 * プレイヤー用キーボードショートカットをセットアップ
 */
export const setupPlayerShortcuts = (playerRef, callbacks) => {
    const handleKeyDown = (event) => {
        // プレイヤーがフォーカスされていない場合は無効
        if (!playerRef.current?.contains(document.activeElement)) {
            return;
        }

        const key = event.key;
        const shortcut = playerShortcuts[key];

        if (shortcut) {
            event.preventDefault();
            handlePlayerShortcutAction(shortcut.action, callbacks, event);
        }
    };

    document.addEventListener("keydown", handleKeyDown);

    return () => {
        document.removeEventListener("keydown", handleKeyDown);
    };
};

/**
 * ショートカットアクションを処理
 */
const handleShortcutAction = (action, event) => {
    switch (action) {
        case "navigate":
            // ナビゲーション処理は各コンポーネントで実装
            window.dispatchEvent(
                new CustomEvent("shortcut:navigate", {
                    detail: { target: event.target },
                })
            );
            break;

        case "search":
            window.dispatchEvent(new CustomEvent("shortcut:search"));
            break;

        case "closeSearch":
            window.dispatchEvent(new CustomEvent("shortcut:closeSearch"));
            break;

        case "toggleView":
            window.dispatchEvent(new CustomEvent("shortcut:toggleView"));
            break;

        case "toggleMultiSelect":
            window.dispatchEvent(new CustomEvent("shortcut:toggleMultiSelect"));
            break;

        case "selectAll":
            window.dispatchEvent(new CustomEvent("shortcut:selectAll"));
            break;

        case "deselectAll":
            window.dispatchEvent(new CustomEvent("shortcut:deselectAll"));
            break;

        case "deleteSelected":
            window.dispatchEvent(new CustomEvent("shortcut:deleteSelected"));
            break;

        case "refresh":
            window.location.reload();
            break;

        case "fullscreen":
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                document.exitFullscreen();
            }
            break;

        default:
            console.warn("Unknown shortcut action:", action);
    }
};

/**
 * プレイヤーショートカットアクションを処理
 */
const handlePlayerShortcutAction = (action, callbacks, event) => {
    const {
        onPlayPause,
        onSeekForward,
        onSeekBackward,
        onVolumeUp,
        onVolumeDown,
        onSpeedUp,
        onSpeedDown,
        onToggleMute,
        onToggleLoop,
        onToggleFullscreen,
        onNextVideo,
        onPreviousVideo,
        onSetSpeed,
        onSetABLoopStart,
        onSetABLoopEnd,
        onToggleABLoop,
    } = callbacks;

    switch (action) {
        case "playPause":
            onPlayPause?.();
            break;

        case "seekForward":
            onSeekForward?.();
            break;

        case "seekBackward":
            onSeekBackward?.();
            break;

        case "volumeUp":
            onVolumeUp?.();
            break;

        case "volumeDown":
            onVolumeDown?.();
            break;

        case "speedUp":
            onSpeedUp?.();
            break;

        case "speedDown":
            onSpeedDown?.();
            break;

        case "mute":
            onToggleMute?.();
            break;

        case "loop":
            onToggleLoop?.();
            break;

        case "fullscreen":
            onToggleFullscreen?.();
            break;

        case "nextVideo":
            onNextVideo?.();
            break;

        case "previousVideo":
            onPreviousVideo?.();
            break;

        case "speed1x":
            onSetSpeed?.(1);
            break;

        case "speed2x":
            onSetSpeed?.(2);
            break;

        case "speed05x":
            onSetSpeed?.(0.5);
            break;

        case "setABLoopStart":
            onSetABLoopStart?.();
            break;

        case "setABLoopEnd":
            onSetABLoopEnd?.();
            break;

        case "toggleABLoop":
            onToggleABLoop?.();
            break;

        default:
            console.warn("Unknown player shortcut action:", action);
    }
};

/**
 * ショートカットヘルプを取得
 */
export const getShortcutHelp = () => {
    const globalShortcuts = Object.entries(shortcuts).map(([key, value]) => ({
        key: key.toUpperCase().replace("+", " + "),
        description: value.description,
        category: "グローバル",
    }));

    const playerShortcutsList = Object.entries(playerShortcuts).map(
        ([key, value]) => ({
            key: key === " " ? "Space" : key.toUpperCase(),
            description: value.description,
            category: "プレイヤー",
        })
    );

    return [...globalShortcuts, ...playerShortcutsList];
};

/**
 * ショートカットが有効かどうかを確認
 */
export const isShortcutEnabled = (keyCombo) => {
    return (
        shortcuts[keyCombo] !== undefined ||
        playerShortcuts[keyCombo] !== undefined
    );
};

/**
 * カスタムショートカットを追加
 */
export const addCustomShortcut = (keyCombo, action, description) => {
    shortcuts[keyCombo] = { action, description, custom: true };
};

/**
 * カスタムショートカットを削除
 */
export const removeCustomShortcut = (keyCombo) => {
    if (shortcuts[keyCombo]?.custom) {
        delete shortcuts[keyCombo];
    }
};

```

```frontend/vite.config.js
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import path from 'path';

export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
      '@components': path.resolve(__dirname, './src/components'),
      '@pages': path.resolve(__dirname, './src/pages'),
      '@hooks': path.resolve(__dirname, './src/hooks'),
      '@services': path.resolve(__dirname, './src/services'),
      '@store': path.resolve(__dirname, './src/store'),
      '@utils': path.resolve(__dirname, './src/utils'),
    },
  },
  server: {
    port: 3000,
    proxy: {
      '/api': {
        target: 'http://localhost:8000',
        changeOrigin: true,
      },
      '/media': {
        target: 'http://localhost:8000',
        changeOrigin: true,
      },
    },
  },
  build: {
    outDir: 'dist',
    sourcemap: true,
    chunkSizeWarningLimit: 2000,
  },
});
```

```install.bat
@echo off
echo ========================================
echo Video Streaming Backend Installation
echo ========================================
echo.

:: Python仮想環境の作成
echo [1/8] Creating Python virtual environment...
python -m venv venv
if errorlevel 1 (
    echo Error: Failed to create virtual environment.
    pause
    exit /b 1
)

:: 仮想環境のアクティベート
echo [2/8] Activating virtual environment...
call venv\Scripts\activate.bat
if errorlevel 1 (
    echo Error: Failed to activate virtual environment.
    pause
    exit /b 1
)

:: pipのアップグレード
echo [3/8] Upgrading pip...
python -m pip install --upgrade pip

:: 依存関係のインストール
echo [4/8] Installing Python dependencies...
pip install -r requirements.txt
if errorlevel 1 (
    echo Error: Failed to install dependencies.
    pause
    exit /b 1
)

:: メディアフォルダの作成
echo [5/8] Creating media directories...
if not exist "media" mkdir media
if not exist "media\videos" mkdir media\videos
if not exist "media\gifs" mkdir media\gifs
if not exist "logs" mkdir logs

:: MySQLデータベースの作成（MySQLが環境変数に設定されている前提）
echo [6/8] Setting up MySQL database...
echo Please enter MySQL root password:
set /p MYSQL_ROOT_PASSWORD=
mysql -u root -p%MYSQL_ROOT_PASSWORD% -e "CREATE DATABASE IF NOT EXISTS video_streaming_db CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;"
mysql -u root -p%MYSQL_ROOT_PASSWORD% -e "CREATE USER IF NOT EXISTS 'video_user'@'localhost' IDENTIFIED BY 'video_pass_2024';"
mysql -u root -p%MYSQL_ROOT_PASSWORD% -e "GRANT ALL PRIVILEGES ON video_streaming_db.* TO 'video_user'@'localhost';"
mysql -u root -p%MYSQL_ROOT_PASSWORD% -e "FLUSH PRIVILEGES;"

:: Djangoの初期設定
echo [7/8] Running Django migrations...
cd backend
python manage.py makemigrations
python manage.py migrate
if errorlevel 1 (
    echo Error: Failed to run migrations.
    cd ..
    pause
    exit /b 1
)

:: スーパーユーザーの作成
echo [8/8] Creating Django superuser...
echo.
echo Please create a superuser account:
python manage.py createsuperuser

cd ..

echo.
echo ========================================
echo Installation completed successfully!
echo ========================================
echo.
echo To start the server, run: runserver.bat
echo.
pause
```

```README_PROJECT.md
# 動画配信サイト - 完全版

自宅用の動画配信サイト/Webアプリケーションです。  
動画ファイルを効率的に管理し、高機能なカスタムプレイヤーで視聴できます。

## 🎯 主な機能

### ファイル管理
- **5つの表示モード**
  - 全ファイル（削除フラグなし）
  - フォルダに存在しないファイル
  - フォルダ別表示（階層構造対応）
  - 削除ファイル一覧
  - 重複ファイル一覧

- **フォルダシステム**
  - ハードリンク/シンボリックリンク的な管理
  - ファイルは物理的に移動せず、タグで管理
  - 階層フォルダ構造対応
  - 複数フォルダへの所属可能

### カスタム動画プレイヤー
- **高度な再生制御**
  - 滑らかなA-Bループ機能
  - 0.1-5倍速の細かい速度調整
  - 長押しで2倍速再生
  - ダブルタップでスキップ/巻き戻し
  - フリックでシーク

- **複数動画の同時再生**
  - PiP風の複数プレイヤー表示
  - 自由配置モード/グリッド配置モード
  - ドラッグ&ドロップで配置変更
  - ピンチでサイズ変更

### UI/UX
- **表示モード切替**
  - サムネイル表示（動くGIF）
  - 詳細表示（テーブル）
  - バーチャライゼーション対応

- **操作性**
  - 右クリック/長押しメニュー
  - 複数選択での一括操作
  - ドラッグ&ドロップ対応
  - キーボードショートカット

## 🛠️ 技術スタック

### バックエンド
- Django 5.0.1
- Django REST Framework
- MySQL 8.0
- Daphne (ASGI)
- FFmpeg（動画処理）

### フロントエンド
- React 18.2
- Material-UI 5.15
- Vite 5.0
- Jotai（状態管理）
- React Virtual（仮想スクロール）

## 📋 必要要件

- Windows 11
- Python 3.10以上
- Node.js 18以上
- MySQL 8.0以上
- FFmpeg
- Redis（オプション）

## 🚀 セットアップ手順

### 1. 事前準備

#### FFmpegのインストール
```bash
# 1. FFmpeg公式サイトからダウンロード
# 2. C:\ffmpeg に解凍
# 3. システム環境変数PATHに C:\ffmpeg\bin を追加
```

#### MySQLのインストール
```bash
# 1. MySQL Installer をダウンロード
# 2. インストール時にrootパスワードを設定
# 3. MySQLサービスが起動していることを確認
```

### 2. プロジェクトのセットアップ

```bash
# プロジェクトをクローン/配置
git clone [repository-url]
cd video_streaming
```

### 3. バックエンドのインストール

```bash
# バックエンドのインストール
install.bat

# 以下の入力が求められます：
# 1. MySQLのrootパスワード
# 2. Django管理者アカウント情報
```

### 4. フロントエンドのインストール

```bash
# フロントエンドのインストール
frontend_install.bat
```

### 5. 動画ファイルの配置

`media/videos/` フォルダに動画ファイルを配置してください。

対応フォーマット：
- mp4, avi, mkv, mov, wmv, flv, webm, m4v, mpg, mpeg

### 6. システムの起動

```bash
# バックエンドとフロントエンドを同時起動
start_all.bat
```

または個別に起動：

```bash
# バックエンド起動
runserver.bat

# フロントエンド起動（別ウィンドウで）
cd frontend
npm run dev
```

## 📍 アクセスURL

- **フロントエンド**: http://localhost:3000
- **バックエンドAPI**: http://localhost:8000/api
- **Django管理画面**: http://localhost:8000/admin

## 📁 ディレクトリ構造

```
video_streaming/
├── install.bat              # バックエンドインストール
├── runserver.bat            # バックエンド起動
├── frontend_install.bat     # フロントエンドインストール
├── start_all.bat           # 統合起動
├── requirements.txt        # Python依存関係
├── backend/               # Djangoバックエンド
│   ├── manage.py
│   ├── backend/           # プロジェクト設定
│   └── videos/           # 動画管理アプリ
├── frontend/             # Reactフロントエンド
│   ├── package.json
│   ├── vite.config.js
│   └── src/
│       ├── components/   # UIコンポーネント
│       ├── pages/       # ページコンポーネント
│       ├── services/    # APIサービス
│       ├── store/       # 状態管理
│       └── utils/       # ユーティリティ
├── media/               # メディアファイル
│   ├── videos/         # 動画ファイル
│   └── gifs/          # サムネイルGIF
└── logs/              # ログファイル
```

## ⚙️ 自動処理

### バックグラウンドタスク
1. **起動時スキャン**: サーバー起動時に自動実行
2. **定期スキャン**: 6時間ごとに自動実行
3. **重複検出**: MD5ハッシュで自動検出
4. **GIF生成**: 動画の最初10秒から自動生成

## 🎮 使い方

### 基本操作
1. **ファイル表示切替**: ヘッダーのトグルボタン
2. **複数選択**: 複数選択ボタンをON
3. **右クリックメニュー**: ファイルを右クリック/長押し
4. **動画再生**: サムネイルをクリック

### プレイヤー操作
- **スペース**: 再生/一時停止
- **ダブルタップ左**: 5秒巻き戻し
- **ダブルタップ右**: 5秒スキップ
- **長押し**: 2倍速再生
- **F**: フルスクリーン
- **L**: ループ切替
- **M**: ミュート切替

### 複数動画再生
1. 動画プレイヤーの「+」ボタンをクリック
2. 追加する動画を選択
3. 「選択動画をすべて開く」をクリック
4. ドラッグで配置変更、ピンチでサイズ変更

## 🔧 トラブルシューティング

### よくある問題

#### MySQLエラー
```
Error: Can't connect to MySQL server
```
→ MySQLサービスが起動しているか確認

#### FFmpegエラー
```
Error: ffmpeg not found
```
→ FFmpegがPATHに追加されているか確認

#### ポート使用中
```
Error: Port 8000/3000 is already in use
```
→ 他のアプリケーションがポートを使用していないか確認

#### 動画が再生されない
- 動画ファイルのパスを確認
- FFmpegが正しくインストールされているか確認
- ブラウザのコンソールでエラーを確認

## 🔒 セキュリティ注意事項

- このシステムは**自宅内での使用**を想定しています
- 外部公開する場合は以下の対策が必要：
  - Django SECRET_KEYの変更
  - DEBUG=Falseに設定
  - 適切な認証機能の追加
  - HTTPSの設定
  - ファイアウォール設定

## 📝 カスタマイズ

### 設定ファイル

#### バックエンド設定
`backend/backend/settings.py`:
- データベース設定
- メディアファイルパス
- スキャン間隔

#### フロントエンド設定
`frontend/.env`:
- APIエンドポイント
- メディアURL

### プレイヤー設定
`frontend/src/store/atoms.js`:
- デフォルト再生速度
- スキップ秒数
- その他プレイヤー設定

## 🚧 今後の機能追加予定

- [ ] 字幕対応
- [ ] プレイリスト機能
- [ ] 視聴履歴
- [ ] お気に入り機能
- [ ] 動画エンコード機能
- [ ] モバイルアプリ版

## 📄 ライセンス

個人使用のみ。商用利用不可。

## 🤝 貢献

プルリクエストは歓迎します。  
大きな変更の場合は、まずissueを開いて変更内容を議論してください。

## 📧 サポート

問題が発生した場合は、以下を確認してください：
1. このREADMEのトラブルシューティング
2. ログファイル（`logs/django.log`）
3. ブラウザのコンソール

---

© 2024 Video Streaming System - Personal Use Only
```

```readme.md
# 動画配信サイト バックエンド

自宅用の動画配信サイトのバックエンドシステムです。  
Django + Django REST Framework + MySQL + Daphne で構築されています。

## システム要件

- Windows 11
- Python 3.10以上
- MySQL 8.0以上
- Redis（オプション：Celeryを使用する場合）
- FFmpeg（動画処理用）

## 事前準備

### 1. FFmpegのインストール

1. [FFmpeg公式サイト](https://ffmpeg.org/download.html)からWindows用バイナリをダウンロード
2. 適当な場所に解凍（例：`C:\ffmpeg`）
3. システム環境変数のPATHに追加（例：`C:\ffmpeg\bin`）

### 2. MySQLのインストール

1. [MySQL公式サイト](https://dev.mysql.com/downloads/installer/)からMySQL Installerをダウンロード
2. インストール時にrootパスワードを設定

### 3. Redis（オプション）

Celeryを使用する場合：
1. [Redis for Windows](https://github.com/microsoftarchive/redis/releases)からダウンロード
2. インストールしてサービスとして実行

## セットアップ手順

### 1. プロジェクトのクローン/配置

```bash
# プロジェクトフォルダを作成
mkdir video_streaming
cd video_streaming

# ファイルを配置
# - install.bat
# - runserver.bat
# - requirements.txt
# - backend/
```

### 2. インストールの実行

```bash
# install.batを実行
install.bat
```

インストール中に以下の入力が求められます：
1. MySQLのrootパスワード
2. Django管理者アカウントの情報

### 3. 動画ファイルの配置

`media/videos/` フォルダに動画ファイルを配置してください。  
対応フォーマット：mp4, avi, mkv, mov, wmv, flv, webm, m4v, mpg, mpeg

## サーバーの起動

```bash
# runserver.batを実行
runserver.bat
```

サーバーは `http://localhost:8000` で起動します。

## API エンドポイント

### ファイル管理

- `GET /api/files/` - ファイル一覧
- `GET /api/files/all/` - 削除されていないすべてのファイル
- `GET /api/files/no-folder/` - フォルダに属さないファイル
- `GET /api/files/deleted/` - 削除フラグが付いたファイル
- `GET /api/files/duplicates/` - 重複ファイル
- `GET /api/files/{id}/` - ファイル詳細
- `POST /api/files/{id}/mark_deleted/` - 削除フラグ設定
- `POST /api/files/{id}/restore/` - 削除フラグ解除
- `POST /api/files/{id}/add_to_folder/` - フォルダに追加
- `POST /api/files/{id}/remove_from_folder/` - フォルダから削除
- `POST /api/files/{id}/add_tags/` - タグ追加
- `POST /api/files/{id}/remove_tags/` - タグ削除
- `POST /api/files/bulk_action/` - 一括操作

### フォルダ管理

- `GET /api/folders/` - フォルダ一覧
- `GET /api/folders/tree/` - フォルダツリー
- `POST /api/folders/` - フォルダ作成
- `PUT /api/folders/{id}/` - フォルダ更新
- `DELETE /api/folders/{id}/` - フォルダ削除

### タグ管理

- `GET /api/tags/` - タグ一覧
- `GET /api/tags/popular/` - 人気タグ
- `GET /api/tags/search/?q={query}` - タグ検索
- `POST /api/tags/` - タグ作成

### グループ管理

- `GET /api/groups/` - グループ一覧
- `POST /api/groups/` - グループ作成

### システム管理

- `GET /api/force_refresh/` - 強制ファイルスキャン
- `GET /api/scan-history/` - スキャン履歴
- `GET /api/scan-history/latest/` - 最新のスキャン履歴

## 管理画面

Django管理画面: `http://localhost:8000/admin/`

インストール時に作成した管理者アカウントでログイン可能です。

## ディレクトリ構造

```
video_streaming/
├── install.bat           # インストールスクリプト
├── runserver.bat         # サーバー起動スクリプト  
├── requirements.txt      # Python依存関係
├── venv/                 # Python仮想環境
├── backend/              # Djangoプロジェクト
│   ├── manage.py
│   ├── backend/          # プロジェクト設定
│   │   ├── settings.py
│   │   ├── urls.py
│   │   ├── asgi.py
│   │   ├── wsgi.py
│   │   └── celery.py
│   └── videos/           # 動画管理アプリ
│       ├── models.py
│       ├── views.py
│       ├── serializers.py
│       ├── urls.py
│       ├── utils.py
│       ├── tasks.py
│       └── admin.py
├── media/                # メディアファイル
│   ├── videos/           # 動画ファイル
│   └── gifs/             # サムネイルGIF
└── logs/                 # ログファイル
```

## 自動処理

以下の処理が自動的に実行されます：

1. **起動時スキャン**: サーバー起動時に動画ファイルをスキャン
2. **定期スキャン**: 6時間ごとに動画ファイルをスキャン
3. **重複検出**: MD5ハッシュとファイルサイズで重複を検出
4. **GIF生成**: 動画の最初の10秒からサムネイルGIFを自動生成

## トラブルシューティング

### MySQLエラー

```
Error: Can't connect to MySQL server
```
→ MySQLサービスが起動しているか確認

### FFmpegエラー

```
Error: ffmpeg not found
```
→ FFmpegがPATHに追加されているか確認

### ポート使用中エラー

```
Error: [Errno 10048] Only one usage of each socket address
```
→ 8000番ポートが他のアプリで使用されていないか確認

## サービス化（nssm使用）

Windows サービスとして登録する場合：

```bash
# nssmをダウンロードして配置
nssm install VideoStreamingServer "C:\path\to\runserver.bat"
nssm start VideoStreamingServer
```

## 注意事項

- 本システムは自宅内での使用を想定しています
- 外部公開する場合はセキュリティ設定の見直しが必要です
- 大量の動画ファイルがある場合、初回スキャンに時間がかかります

## ライセンス

個人使用のみ
```

```requirements.txt
Django==5.0.1
djangorestframework==3.14.0
django-cors-headers==4.3.1
mysqlclient==2.2.1
daphne==4.0.0
channels==4.0.0
Pillow==10.2.0
ffmpeg-python==0.2.0
celery==5.3.4
redis==5.0.1
python-dotenv==1.0.0
watchdog==3.0.0
django-cleanup==8.0.0
imageio==2.33.1
imageio-ffmpeg==0.4.9
```

```runserver.bat

```

```start_all.bat
@echo off
echo ========================================
echo Starting Video Streaming System
echo ========================================
echo.

:: バックエンドとフロントエンドを並行して起動
echo Starting Backend Server (Django)...
start "Backend Server" cmd /k "cd backend && call ..\venv\Scripts\activate.bat && daphne -b 0.0.0.0 -p 8000 backend.asgi:application"

:: 少し待機
timeout /t 3 /nobreak >nul

echo Starting Frontend Server (React)...
start "Frontend Server" cmd /k "cd frontend && npm run dev"

echo.
echo ========================================
echo Both servers are starting...
echo ========================================
echo.
echo Backend:  http://localhost:8000
echo Frontend: http://localhost:3000
echo Admin:    http://localhost:8000/admin
echo.
echo Press any key to open the frontend in your browser...
pause >nul

:: ブラウザで開く
start http://localhost:3000

echo.
echo The servers are running in separate windows.
echo Close those windows to stop the servers.
echo.
pause
```

```test_system.bat
@echo off
echo ========================================
echo Video Streaming System Test
echo ========================================
echo.

:: Python確認
echo [1/6] Checking Python...
python --version >nul 2>&1
if errorlevel 1 (
    echo ERROR: Python is not installed
    pause
    exit /b 1
)
python --version

:: Node.js確認
echo.
echo [2/6] Checking Node.js...
node --version >nul 2>&1
if errorlevel 1 (
    echo ERROR: Node.js is not installed
    pause
    exit /b 1
)
node --version
npm --version

:: MySQL確認
echo.
echo [3/6] Checking MySQL...
mysql --version >nul 2>&1
if errorlevel 1 (
    echo WARNING: MySQL command not found in PATH
    echo Make sure MySQL service is running
) else (
    mysql --version
)

:: FFmpeg確認
echo.
echo [4/6] Checking FFmpeg...
ffmpeg -version >nul 2>&1
if errorlevel 1 (
    echo ERROR: FFmpeg is not installed or not in PATH
    pause
    exit /b 1
)
ffmpeg -version | findstr "ffmpeg version"

:: バックエンド確認
echo.
echo [5/6] Testing Backend...
cd backend
call ..\venv\Scripts\activate.bat >nul 2>&1
if errorlevel 1 (
    echo ERROR: Virtual environment not found. Run install.bat first
    cd ..
    pause
    exit /b 1
)

python manage.py check >nul 2>&1
if errorlevel 1 (
    echo ERROR: Django configuration error
    cd ..
    pause
    exit /b 1
)
echo Django configuration: OK

:: データベース接続テスト
python -c "from django.db import connection; cursor = connection.cursor(); print('Database connection: OK')" 2>nul
if errorlevel 1 (
    echo ERROR: Cannot connect to database
    echo Make sure MySQL is running and configured correctly
    cd ..
    pause
    exit /b 1
)

cd ..

:: フロントエンド確認
echo.
echo [6/6] Testing Frontend...
cd frontend
if not exist node_modules (
    echo ERROR: Node modules not found. Run frontend_install.bat first
    cd ..
    pause
    exit /b 1
)
echo Frontend dependencies: OK

cd ..

:: メディアフォルダ確認
echo.
echo Checking media directories...
if not exist media\videos (
    echo Creating media\videos directory...
    mkdir media\videos
)
if not exist media\gifs (
    echo Creating media\gifs directory...
    mkdir media\gifs
)
echo Media directories: OK

:: 動作テスト
echo.
echo ========================================
echo System Test Completed Successfully!
echo ========================================
echo.
echo All components are properly installed.
echo.
echo To start the system:
echo   start_all.bat
echo.
echo To test the API:
echo   1. Start the backend server
echo   2. Open http://localhost:8000/api
echo.
echo To test the frontend:
echo   1. Start both servers
echo   2. Open http://localhost:3000
echo.
pause
```

```USER_GUIDE.md
# 動画配信システム ユーザーガイド

## 🚀 クイックスタート

### 1. 初回セットアップ
```batch
# 完全セットアップ（推奨）
complete_setup.bat

# または個別にセットアップ
install.bat           # バックエンド
frontend_install.bat  # フロントエンド
```

### 2. システム起動
```batch
# 統合起動（推奨）
start_all.bat

# または個別に起動
runserver.bat        # バックエンド
cd frontend && npm run dev  # フロントエンド
```

### 3. アクセス
- **アプリケーション**: http://localhost:3000
- **管理画面**: http://localhost:8000/admin
- **API**: http://localhost:8000/api

## 📁 動画ファイルの追加

1. `media/videos/` フォルダに動画ファイルを配置
2. システムが自動的にスキャン（起動時・6時間ごと）
3. または手動スキャン：ヘッダーの更新ボタンをクリック

### 対応フォーマット
- MP4, AVI, MKV, MOV, WMV, FLV, WebM, M4V, MPG, MPEG

## 🎮 基本操作

### ナビゲーション

#### ページ切り替え
- **全ファイル**: すべての有効な動画
- **フォルダに存在しない**: 未分類の動画
- **フォルダ**: フォルダ管理
- **削除ファイル**: 削除フラグ付きファイル
- **重複ファイル**: 重複検出されたファイル

#### キーボードショートカット
- `Ctrl + 1-5`: 各ページへ移動
- `Ctrl + F`: 検索
- `Ctrl + Shift + V`: 表示モード切替
- `Ctrl + M`: 複数選択モード切替

### ファイル操作

#### シングルクリック
- **サムネイルモード**: 動画を再生
- **複数選択モード**: ファイルを選択

#### 右クリック/長押しメニュー
- フォルダへ移動
- フォルダへコピー
- タグを追加
- ファイルを削除（削除フラグ）
- ファイルを復元（削除ページ）

#### 複数選択操作
1. 複数選択ボタンをON
2. ファイルをクリックで選択
3. 画面下部のバーで一括操作

## 🎬 動画プレイヤー

### 基本コントロール
- **スペース**: 再生/一時停止
- **F**: フルスクリーン
- **M**: ミュート
- **L**: ループ再生
- **←/→**: 巻き戻し/スキップ
- **↑/↓**: 音量調整

### タッチ操作（モバイル/タブレット）
- **シングルタップ（中央）**: 再生/一時停止
- **ダブルタップ（左）**: 5秒巻き戻し
- **ダブルタップ（右）**: 5秒スキップ
- **長押し**: 2倍速再生
- **フリック**: シーク
- **ピンチ**: ズーム

### A-Bループ
1. プレイヤーのループボタンをクリック
2. 開始地点で「開始地点を設定」
3. 終了地点で「終了地点を設定」
4. 自動的にループ再生

### 再生速度
- 0.1倍速〜5倍速まで調整可能
- プリセット: 0.25, 0.5, 0.75, 1, 1.25, 1.5, 2倍速

## 📂 フォルダ管理

### フォルダの作成
1. フォルダページへ移動
2. 右下の「+」ボタンをクリック
3. フォルダ名を入力

### フォルダ階層
- 親フォルダ内に子フォルダを作成可能
- パンくずリストで階層を確認
- クリックで上位フォルダへ移動

### ファイルの整理
1. **移動**: ファイルを別フォルダへ完全移動
2. **コピー**: ファイルを複数フォルダで参照
3. **削除**: フォルダからの参照を削除（ファイル自体は残る）

## 🎯 複数動画の同時再生

### 開き方
1. 動画プレイヤーの「+」ボタンをクリック
2. 追加する動画を選択
3. 「選択動画をすべて開く」をクリック

### レイアウトモード

#### 自由配置モード
- ドラッグで移動
- リサイズハンドルでサイズ変更
- 個別にフルスクリーン可能

#### グリッド配置モード
- 自動的に均等配置
- 動画数に応じて最適化

## 🔍 検索とフィルタ

### 検索方法
- **ファイル名検索**: 部分一致で検索
- **タグ検索**: `tag:タグ名` で検索
- **複合検索**: スペース区切りでAND検索

### ソート
詳細表示で列ヘッダーをクリック：
- ファイル名
- ファイルサイズ
- 動画時間
- 作成日時

## ⚙️ 設定

### 表示設定
- **サムネイルサイズ**: 小/中/大
- **ファイル情報表示**: ON/OFF
- **アニメーションGIF**: ON/OFF
- **グリッド列数**: 自動/2-6列

### プレイヤー設定
- **デフォルト再生速度**: 0.25-5倍速
- **デフォルト音量**: 0-100%
- **スキップ秒数**: 5-30秒
- **長押し倍速**: 1.5-5倍速
- **自動再生**: ON/OFF
- **ループ再生**: ON/OFF

## 🛠️ トラブルシューティング

### 動画が表示されない
1. `media/videos/` に動画ファイルがあるか確認
2. 手動スキャン実行（更新ボタン）
3. サポートされているフォーマットか確認

### サムネイルが表示されない
- FFmpegが正しくインストールされているか確認
- `media/gifs/` フォルダの書き込み権限を確認

### 再生できない
- ブラウザが動画フォーマットをサポートしているか確認
- 動画ファイルが破損していないか確認
- コンソールでエラーを確認（F12）

### システムが重い
- 同時に開いている動画数を減らす
- サムネイルサイズを小さくする
- アニメーションGIFを無効化

## 📱 デバイス対応

### PC (Windows/Mac/Linux)
- すべての機能が利用可能
- キーボードショートカット対応
- マウス操作最適化

### タブレット (iPad/Android)
- タッチ操作対応
- ピンチズーム対応
- 横画面推奨

### スマートフォン
- 基本機能のみ
- シングル動画再生推奨
- 縦画面対応

## 🔒 セキュリティ注意

このシステムは**自宅内での使用**を想定しています。
外部公開する場合は必ず：
1. 認証機能を追加
2. HTTPSを設定
3. ファイアウォール設定
4. Django設定を本番用に変更

## 💡 Tips & Tricks

### パフォーマンス向上
- 定期的に重複ファイルを整理
- 不要な削除ファイルを完全削除
- データベースの最適化

### 便利な使い方
- よく見る動画は「お気に入り」フォルダへ
- タグで細かく分類
- A-Bループで特定シーンを繰り返し
- 複数動画で比較視聴

### バックアップ
定期的にバックアップ：
- `media/` フォルダ
- データベース（MySQL）
- 設定ファイル

## 📞 サポート

問題が発生した場合：
1. `test_system.bat` で診断
2. `logs/django.log` を確認
3. ブラウザコンソール（F12）を確認
4. このガイドのトラブルシューティングを参照

---

© 2024 Video Streaming System - Personal Use Only
```

