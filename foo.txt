```.gitignore
# Byte-code files
*.pyc
__pycache__/

# Virtual environment
venv/
env/
.venv/
.git/

# Database files
*.sqlite3

# Media and static files (if served locally for development)
media/
static/

# Environment-specific configuration (e.g., sensitive settings)
.env
local_settings.py

# Editor and IDE specific files
.vscode/
.idea/
*.swp
*~

# Test coverage files
.coverage
.coverage.*

# Django specific
migrations/00*.py # Ignore initial migration files if you're using a specific migration workflow
```

```backend/backend/__init__.py
"""
Backend Django project package.
"""
```

```backend/backend/asgi.py
"""
ASGI config for backend project.
It exposes the ASGI callable as a module-level variable named ``application``.
"""

import os
from django.core.asgi import get_asgi_application
from channels.routing import ProtocolTypeRouter, URLRouter
from channels.auth import AuthMiddlewareStack

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'backend.settings')

# Django ASGI application
django_asgi_app = get_asgi_application()

# Import routing after Django setup
from videos import routing

application = ProtocolTypeRouter({
    "http": django_asgi_app,
    "websocket": AuthMiddlewareStack(
        URLRouter(
            routing.websocket_urlpatterns
        )
    ),
})
```

```backend/backend/celery.py
"""
Celery configuration for backend project.
"""

import os
from celery import Celery
from celery.schedules import crontab

# Djangoの設定モジュールを指定
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'backend.settings')

# Celeryアプリケーションインスタンスを作成
app = Celery('backend')

# Djangoの設定ファイルから設定を読み込み
app.config_from_object('django.conf:settings', namespace='CELERY')

# 登録されたDjangoアプリケーションからタスクを自動検出
app.autodiscover_tasks()

# 定期タスクの設定
app.conf.beat_schedule = {
    # 6時間ごとにファイルスキャンを実行
    'periodic-file-scan': {
        'task': 'videos.tasks.periodic_scan_task',
        'schedule': crontab(minute=0, hour='*/6'),  # 0:00, 6:00, 12:00, 18:00に実行
    },
    # 毎日午前3時に古いスキャン履歴を削除
    'cleanup-scan-history': {
        'task': 'videos.tasks.cleanup_old_scan_history',
        'schedule': crontab(hour=3, minute=0),
    },
    # 毎日午前4時に欠けているサムネイルを生成
    'generate-missing-thumbnails': {
        'task': 'videos.tasks.generate_missing_thumbnails',
        'schedule': crontab(hour=4, minute=0),
    },
}

@app.task(bind=True)
def debug_task(self):
    """デバッグ用タスク"""
    print(f'Request: {self.request!r}')
```

```backend/backend/settings.py
"""
Django settings for video streaming backend project.
"""

from pathlib import Path
import os
from datetime import timedelta

# Build paths inside the project
BASE_DIR = Path(__file__).resolve().parent.parent

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = "django-insecure-your-secret-key-change-this-in-production-@#$%^&*()"

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

ALLOWED_HOSTS = ["localhost", "127.0.0.1", "0.0.0.0", "*"]

# Application definition
INSTALLED_APPS = [
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",
    "rest_framework",
    "corsheaders",
    "channels",
    "videos",
    "django_cleanup.apps.CleanupConfig",
]

MIDDLEWARE = [
    "django.middleware.security.SecurityMiddleware",
    "django.contrib.sessions.middleware.SessionMiddleware",
    "corsheaders.middleware.CorsMiddleware",
    "django.middleware.common.CommonMiddleware",
    "django.middleware.csrf.CsrfViewMiddleware",
    "django.contrib.auth.middleware.AuthenticationMiddleware",
    "django.contrib.messages.middleware.MessageMiddleware",
    "django.middleware.clickjacking.XFrameOptionsMiddleware",
]

ROOT_URLCONF = "backend.urls"

TEMPLATES = [
    {
        "BACKEND": "django.template.backends.django.DjangoTemplates",
        "DIRS": [],
        "APP_DIRS": True,
        "OPTIONS": {
            "context_processors": [
                "django.template.context_processors.debug",
                "django.template.context_processors.request",
                "django.contrib.auth.context_processors.auth",
                "django.contrib.messages.context_processors.messages",
            ],
        },
    },
]

# ASGI application for Daphne
ASGI_APPLICATION = "backend.asgi.application"

# Database configuration for MySQL
DATABASES = {
    "default": {
        "ENGINE": "django.db.backends.mysql",
        "NAME": "video_streaming_db",
        "USER": "video_user",
        "PASSWORD": "video_pass_2024",
        "HOST": "localhost",
        "PORT": "3306",
        "OPTIONS": {
            "charset": "utf8mb4",
            "init_command": "SET sql_mode='STRICT_TRANS_TABLES'",
        },
    }
}

# Password validation
AUTH_PASSWORD_VALIDATORS = [
    {
        "NAME": "django.contrib.auth.password_validation.UserAttributeSimilarityValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.MinimumLengthValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.CommonPasswordValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.NumericPasswordValidator",
    },
]

# Internationalization
LANGUAGE_CODE = "ja-JP"
TIME_ZONE = "Asia/Tokyo"
USE_I18N = True
USE_TZ = True

# Static files (CSS, JavaScript, Images)
STATIC_URL = "/static/"
STATIC_ROOT = os.path.join(BASE_DIR, "staticfiles")

# Media files configuration
MEDIA_URL = "/media/"
MEDIA_ROOT = os.path.join(BASE_DIR.parent, "media")

# Video and GIF directories
VIDEO_DIR = os.path.join(MEDIA_ROOT, "videos")
GIF_DIR = os.path.join(MEDIA_ROOT, "gifs")

# Default primary key field type
DEFAULT_AUTO_FIELD = "django.db.models.BigAutoField"

# REST Framework configuration
REST_FRAMEWORK = {
    "DEFAULT_PERMISSION_CLASSES": [
        "rest_framework.permissions.AllowAny",
    ],
    "DEFAULT_AUTHENTICATION_CLASSES": [],
    "DEFAULT_PAGINATION_CLASS": "rest_framework.pagination.PageNumberPagination",
    "PAGE_SIZE": 100,
    "DEFAULT_RENDERER_CLASSES": [
        "rest_framework.renderers.JSONRenderer",
    ],
}

# CORS settings
CORS_ALLOW_ALL_ORIGINS = True
CORS_ALLOW_CREDENTIALS = True

# Celery Configuration (for background tasks)
CELERY_BROKER_URL = "redis://localhost:6379/0"
CELERY_RESULT_BACKEND = "redis://localhost:6379/0"
CELERY_ACCEPT_CONTENT = ["json"]
CELERY_TASK_SERIALIZER = "json"
CELERY_RESULT_SERIALIZER = "json"
CELERY_TIMEZONE = TIME_ZONE

# File scan settings
FILE_SCAN_INTERVAL = 6 * 60 * 60  # 6 hours in seconds

# FFmpeg settings
FFMPEG_BINARY = "ffmpeg"  # Assumes ffmpeg is in PATH

# Logging configuration
LOGGING = {
    "version": 1,
    "disable_existing_loggers": False,
    "formatters": {
        "verbose": {
            "format": "{levelname} {asctime} {module} {message}",
            "style": "{",
        },
    },
    "handlers": {
        "file": {
            "level": "INFO",
            "class": "logging.FileHandler",
            "filename": os.path.join(BASE_DIR.parent, "logs", "django.log"),
            "formatter": "verbose",
        },
        "console": {
            "level": "INFO",
            "class": "logging.StreamHandler",
            "formatter": "verbose",
        },
    },
    "root": {
        "handlers": ["console", "file"],
        "level": "INFO",
    },
    "loggers": {
        "django": {
            "handlers": ["console", "file"],
            "level": "INFO",
            "propagate": False,
        },
        "videos": {
            "handlers": ["console", "file"],
            "level": "DEBUG",
            "propagate": False,
        },
    },
}

```

```backend/backend/urls.py
"""
URL configuration for backend project.
"""

from django.contrib import admin
from django.urls import path, include
from django.conf import settings
from django.conf.urls.static import static

urlpatterns = [
    path('admin/', admin.site.urls),
    path('api/', include('videos.urls')),
]

# Serve media files in development
if settings.DEBUG:
    urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)
    urlpatterns += static(settings.STATIC_URL, document_root=settings.STATIC_ROOT)
```

```backend/backend/wsgi.py
"""
WSGI config for backend project.

It exposes the WSGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.0/howto/deployment/wsgi/
"""

import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'backend.settings')

application = get_wsgi_application()
```

```backend/manage.py
#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""
import os
import sys


def main():
    """Run administrative tasks."""
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'backend.settings')
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)


if __name__ == '__main__':
    main()
```

```backend/videos/__init__.py
"""
Videos application package.
"""

default_app_config = 'videos.apps.VideosConfig'
```

```backend/videos/admin.py
"""
Django admin configuration for videos app.
"""

from django.contrib import admin
from django.utils.html import format_html
from .models import File, Folder, Tag, Group, ScanHistory


@admin.register(File)
class FileAdmin(admin.ModelAdmin):
    list_display = ['file_name', 'file_size_display', 'duration_display', 'delete_flag', 'duplicate_flag', 'created_at']
    list_filter = ['delete_flag', 'duplicate_flag', 'created_at', 'folders']
    search_fields = ['file_name', 'md5_hash']
    filter_horizontal = ['folders', 'tags']
    readonly_fields = ['file_path', 'md5_hash', 'file_size', 'video_duration', 'width', 'height', 'fps', 'codec', 'bitrate', 'created_at', 'updated_at']
    
    fieldsets = (
        ('基本情報', {
            'fields': ('file_name', 'file_path', 'file_size', 'md5_hash')
        }),
        ('動画情報', {
            'fields': ('video_duration', 'width', 'height', 'fps', 'codec', 'bitrate')
        }),
        ('分類', {
            'fields': ('folders', 'tags')
        }),
        ('フラグ', {
            'fields': ('delete_flag', 'duplicate_flag')
        }),
        ('サムネイル', {
            'fields': ('thumbnail_file_path',)
        }),
        ('メタデータ', {
            'fields': ('metadata',),
            'classes': ('collapse',)
        }),
        ('タイムスタンプ', {
            'fields': ('created_at', 'updated_at', 'last_accessed')
        })
    )
    
    def file_size_display(self, obj):
        """ファイルサイズを人間が読みやすい形式で表示"""
        size = obj.file_size
        for unit in ['B', 'KB', 'MB', 'GB', 'TB']:
            if size < 1024.0:
                return f"{size:.1f} {unit}"
            size /= 1024.0
        return f"{size:.1f} PB"
    file_size_display.short_description = 'ファイルサイズ'
    
    def duration_display(self, obj):
        """動画の長さを時:分:秒形式で表示"""
        if obj.video_duration:
            hours = int(obj.video_duration // 3600)
            minutes = int((obj.video_duration % 3600) // 60)
            seconds = int(obj.video_duration % 60)
            if hours > 0:
                return f"{hours}:{minutes:02d}:{seconds:02d}"
            else:
                return f"{minutes}:{seconds:02d}"
        return "-"
    duration_display.short_description = '動画の長さ'
    
    actions = ['mark_as_deleted', 'restore_files', 'mark_as_duplicate']
    
    def mark_as_deleted(self, request, queryset):
        """選択したファイルに削除フラグを設定"""
        updated = queryset.update(delete_flag=True)
        self.message_user(request, f"{updated}個のファイルに削除フラグを設定しました。")
    mark_as_deleted.short_description = "削除フラグを設定"
    
    def restore_files(self, request, queryset):
        """選択したファイルの削除フラグを解除"""
        updated = queryset.update(delete_flag=False)
        self.message_user(request, f"{updated}個のファイルの削除フラグを解除しました。")
    restore_files.short_description = "削除フラグを解除"
    
    def mark_as_duplicate(self, request, queryset):
        """選択したファイルに重複フラグを設定"""
        updated = queryset.update(duplicate_flag=True)
        self.message_user(request, f"{updated}個のファイルに重複フラグを設定しました。")
    mark_as_duplicate.short_description = "重複フラグを設定"


@admin.register(Folder)
class FolderAdmin(admin.ModelAdmin):
    list_display = ['folder_name', 'parent', 'files_count', 'children_count', 'created_at']
    list_filter = ['created_at', 'parent']
    search_fields = ['folder_name']
    raw_id_fields = ['parent']
    
    def files_count(self, obj):
        """フォルダ内のファイル数"""
        return obj.files.count()
    files_count.short_description = 'ファイル数'
    
    def children_count(self, obj):
        """子フォルダ数"""
        return obj.children.count()
    children_count.short_description = '子フォルダ数'


@admin.register(Tag)
class TagAdmin(admin.ModelAdmin):
    list_display = ['tag_name', 'usage_count', 'groups_display', 'created_at']
    list_filter = ['groups', 'created_at']
    search_fields = ['tag_name']
    filter_horizontal = ['groups']
    readonly_fields = ['usage_count', 'created_at', 'updated_at']
    
    def groups_display(self, obj):
        """所属グループを表示"""
        groups = obj.groups.all()
        if groups:
            return ", ".join([g.name for g in groups])
        return "-"
    groups_display.short_description = '所属グループ'


@admin.register(Group)
class GroupAdmin(admin.ModelAdmin):
    list_display = ['name', 'tags_count', 'created_at']
    search_fields = ['name']
    readonly_fields = ['created_at', 'updated_at']
    
    def tags_count(self, obj):
        """グループ内のタグ数"""
        return obj.tags.count()
    tags_count.short_description = 'タグ数'


@admin.register(ScanHistory)
class ScanHistoryAdmin(admin.ModelAdmin):
    list_display = ['started_at', 'status_display', 'files_scanned', 'files_added', 'duplicates_found', 'duration_display']
    list_filter = ['status', 'started_at']
    readonly_fields = ['started_at', 'completed_at', 'status', 'files_scanned', 'files_added', 'files_updated', 'duplicates_found', 'errors']
    
    def status_display(self, obj):
        """ステータスを色付きで表示"""
        colors = {
            'running': 'orange',
            'completed': 'green',
            'failed': 'red'
        }
        color = colors.get(obj.status, 'black')
        return format_html(
            '<span style="color: {};">{}</span>',
            color,
            obj.get_status_display()
        )
    status_display.short_description = 'ステータス'
    
    def duration_display(self, obj):
        """実行時間を表示"""
        if obj.completed_at and obj.started_at:
            delta = obj.completed_at - obj.started_at
            total_seconds = int(delta.total_seconds())
            hours = total_seconds // 3600
            minutes = (total_seconds % 3600) // 60
            seconds = total_seconds % 60
            if hours > 0:
                return f"{hours}時間{minutes}分{seconds}秒"
            elif minutes > 0:
                return f"{minutes}分{seconds}秒"
            else:
                return f"{seconds}秒"
        elif obj.status == 'running':
            return "実行中..."
        return "-"
    duration_display.short_description = '実行時間'
    
    def has_add_permission(self, request):
        """手動でスキャン履歴を追加することを防ぐ"""
        return False
```

```backend/videos/apps.py
# backend/videos/apps.py
import os
import sys
import threading
import logging
import importlib
from typing import Optional, Tuple, Set

from django.apps import AppConfig, apps as django_apps
from django.db import connection
from django.db.models.signals import post_migrate

logger = logging.getLogger(__name__)


class VideosConfig(AppConfig):
    name = 'videos'
    verbose_name = 'Videos'

    def __init__(self, app_name, app_module):
        super().__init__(app_name, app_module)
        # スキャン開始済みフラグ（重複起動防止）
        self._scans_started = False
        # post_migrate ハンドラ登録用フラグ
        self._post_migrate_connected = False

    # ------------------------------------------------------------------
    # DB 準備が整っているかを判定するユーティリティ
    # モデルの _meta.db_table を動的に参照することで、
    # db_table 名を変更しても追従できるようにする。
    # ------------------------------------------------------------------
    def _db_ready(self) -> bool:
        try:
            existing_tables: Set[str] = set(connection.introspection.table_names())
        except Exception as e:
            logger.debug("Failed to introspect DB tables: %s", e)
            return False

        required_model_names = ['ScanHistory', 'File', 'Folder', 'Tag', 'Group']
        required_tables = set()
        for mname in required_model_names:
            try:
                model = django_apps.get_model('videos', mname)
            except LookupError:
                # モデルがロードされていない（アプリ未ロードなど）
                logger.debug("Model videos.%s not available yet", mname)
                return False
            required_tables.add(model._meta.db_table)

        missing = required_tables - existing_tables
        if missing:
            logger.debug("DB missing required tables: %s", missing)
            return False
        return True

    # ------------------------------------------------------------------
    # スキャン関数（initial_scan, periodic_scan）を探して返す
    # 探索候補モジュールはプロジェクト差で異なるため複数候補を見る
    # ------------------------------------------------------------------
    def _find_scan_functions(self) -> Tuple[Optional[callable], Optional[callable]]:
        candidates = [
            'videos.scanner',
            'videos.tasks',
            'videos.scan',
            'videos.utils',
            'videos.management.scan',  # まれに管理コマンド配下
        ]
        initial_scan = None
        periodic_scan = None
        for modname in candidates:
            try:
                mod = importlib.import_module(modname)
            except Exception:
                continue
            # 明示的に関数名を探す
            if hasattr(mod, 'initial_scan'):
                initial_scan = getattr(mod, 'initial_scan')
            if hasattr(mod, 'periodic_scan'):
                periodic_scan = getattr(mod, 'periodic_scan')
            # もしモジュールがクラス内実装であれば属性名違いの可能性もあるが
            # 最低限上記2つが見つかれば十分。
            if initial_scan or periodic_scan:
                logger.debug("Found scan module %s (initial=%s periodic=%s)", modname, bool(initial_scan), bool(periodic_scan))
                break
        return initial_scan, periodic_scan

    # ------------------------------------------------------------------
    # 実際にスキャンスレッドを起動する。重複起動しないようにチェックする。
    # ------------------------------------------------------------------
    def _start_scans(self):
        if self._scans_started:
            logger.debug("Scans already started; skip.")
            return

        initial_scan, periodic_scan = self._find_scan_functions()

        if not initial_scan and not periodic_scan:
            logger.warning("No scan entrypoints found (initial_scan / periodic_scan). Skipping automatic scan startup.")
            return

        # 起動用ラッパー。例外が出てもスレッドが潰れないようにする。
        def _safe_run(func, *args, **kwargs):
            try:
                logger.info("Starting scan function: %s", getattr(func, '__name__', repr(func)))
                func(*args, **kwargs)
            except Exception:
                logger.exception("Exception occurred while running scan function %s", getattr(func, '__name__', repr(func)))

        # initial_scan は一度だけ起動（バックグラウンド）
        if initial_scan:
            t = threading.Thread(target=_safe_run, args=(initial_scan,), daemon=True, name='videos.initial_scan')
            t.start()
            logger.info("Initial scan thread started.")

        # periodic_scan はデーモンスレッドで起動（実装側でループ/スリープ管理する想定）
        if periodic_scan:
            t2 = threading.Thread(target=_safe_run, args=(periodic_scan,), daemon=True, name='videos.periodic_scan')
            t2.start()
            logger.info("Periodic scan thread started.")

        self._scans_started = True

    # ------------------------------------------------------------------
    # post_migrate シグナルハンドラ（マイグレーション完了後に呼ばれる）
    # DB が未準備で起動時にスキップされた場合、ここで再チェックしてスキャンを開始する
    # ------------------------------------------------------------------
    def _on_post_migrate(self, **kwargs):
        # 開発サーバの再読み込み子プロセス対策
        if os.environ.get('RUN_MAIN') != 'true':
            return
        # 既に起動済みなら無視
        if self._scans_started:
            return
        # テーブルが用意できているか再チェック
        if self._db_ready():
            logger.info("DB ready after migrations; starting scans via post_migrate handler.")
            self._start_scans()
        else:
            logger.debug("post_migrate: DB still not ready; skipping start.")

    # ------------------------------------------------------------------
    # AppConfig.ready(): Django 起動時に呼ばれる
    # - RUN_MAIN チェックで子プロセスを除外
    # - runserver からの起動時のみ自動スキャンを検討
    # - DB が未準備なら post_migrate で開始するよう接続
    # ------------------------------------------------------------------
    def ready(self):
        # 開発サーバのリロード子プロセスでは実行しない（重複防止）
        if os.environ.get('RUN_MAIN') != 'true':
            return

        # まず runserver / daphne などサーバ起動コマンドかどうかを判定
        is_server = any(k in ' '.join(sys.argv) for k in ('runserver', 'daphne', 'gunicorn', 'uvicorn'))

        if not is_server:
            # サーバ以外（manage.py migrate 等）のときはスキャンを開始しない
            logger.debug("Not a server process (sys.argv: %s). Skipping automatic scan startup.", sys.argv)
            return

        # DB の準備状況に応じて即時かシグナル待ちかを決める
        try:
            if self._db_ready():
                logger.info("Database ready at startup; starting initial and periodic scans.")
                self._start_scans()
            else:
                logger.warning("Database not ready at startup; connecting post_migrate handler to start scans after migrations.")
                # post_migrate を一度だけ接続する
                if not self._post_migrate_connected:
                    post_migrate.connect(self._on_post_migrate, dispatch_uid=f'videos_post_migrate_{id(self)}')
                    self._post_migrate_connected = True
        except Exception:
            logger.exception("Exception while checking DB readiness in ready(); connecting post_migrate handler as fallback.")
            if not self._post_migrate_connected:
                post_migrate.connect(self._on_post_migrate, dispatch_uid=f'videos_post_migrate_{id(self)}')
                self._post_migrate_connected = True

```

```backend/videos/migrations/__init__.py

```

```backend/videos/migrations/0001_initial.py
# Generated by Django 5.0.1 on 2025-09-21 15:07

import django.core.validators
import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='Group',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(max_length=100, unique=True, verbose_name='グループ名')),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
            ],
            options={
                'verbose_name': 'タググループ',
                'verbose_name_plural': 'タググループ',
                'db_table': 'video_groups',
                'ordering': ['name'],
            },
        ),
        migrations.CreateModel(
            name='ScanHistory',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('started_at', models.DateTimeField(auto_now_add=True, verbose_name='開始時刻')),
                ('completed_at', models.DateTimeField(blank=True, null=True, verbose_name='完了時刻')),
                ('status', models.CharField(choices=[('running', '実行中'), ('completed', '完了'), ('failed', '失敗')], default='running', max_length=20, verbose_name='ステータス')),
                ('files_scanned', models.IntegerField(default=0, verbose_name='スキャン済みファイル数')),
                ('files_added', models.IntegerField(default=0, verbose_name='追加ファイル数')),
                ('files_updated', models.IntegerField(default=0, verbose_name='更新ファイル数')),
                ('duplicates_found', models.IntegerField(default=0, verbose_name='重複ファイル数')),
                ('errors', models.JSONField(blank=True, default=list, verbose_name='エラー')),
            ],
            options={
                'verbose_name': 'スキャン履歴',
                'verbose_name_plural': 'スキャン履歴',
                'db_table': 'scan_history',
                'ordering': ['-started_at'],
            },
        ),
        migrations.CreateModel(
            name='Folder',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('folder_name', models.CharField(max_length=255, verbose_name='フォルダ名')),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
                ('parent', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, related_name='children', to='videos.folder', verbose_name='親フォルダ')),
            ],
            options={
                'verbose_name': 'フォルダ',
                'verbose_name_plural': 'フォルダ',
                'db_table': 'folders',
                'ordering': ['parent__id', 'folder_name'],
                'unique_together': {('folder_name', 'parent')},
            },
        ),
        migrations.CreateModel(
            name='Tag',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('tag_name', models.CharField(max_length=100, unique=True, verbose_name='タグ名')),
                ('usage_count', models.IntegerField(default=0, validators=[django.core.validators.MinValueValidator(0)], verbose_name='使用回数')),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
                ('groups', models.ManyToManyField(blank=True, related_name='tags', to='videos.group', verbose_name='所属グループ')),
            ],
            options={
                'verbose_name': 'タグ',
                'verbose_name_plural': 'タグ',
                'db_table': 'tags',
                'ordering': ['-usage_count', 'tag_name'],
            },
        ),
        migrations.CreateModel(
            name='File',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('file_name', models.CharField(max_length=255, verbose_name='ファイル名')),
                ('file_path', models.CharField(db_index=True, max_length=255, verbose_name='ファイルパス')),
                ('file_size', models.BigIntegerField(validators=[django.core.validators.MinValueValidator(0)], verbose_name='ファイルサイズ（バイト）')),
                ('md5_hash', models.CharField(db_index=True, max_length=32, verbose_name='MD5ハッシュ')),
                ('video_duration', models.FloatField(blank=True, null=True, validators=[django.core.validators.MinValueValidator(0)], verbose_name='動画の長さ（秒）')),
                ('delete_flag', models.BooleanField(db_index=True, default=False, verbose_name='削除フラグ')),
                ('duplicate_flag', models.BooleanField(db_index=True, default=False, verbose_name='重複フラグ')),
                ('thumbnail_file_path', models.CharField(blank=True, max_length=255, null=True, verbose_name='サムネイルGIFパス')),
                ('metadata', models.JSONField(blank=True, default=dict, verbose_name='メタデータ')),
                ('width', models.IntegerField(blank=True, null=True, verbose_name='動画の幅')),
                ('height', models.IntegerField(blank=True, null=True, verbose_name='動画の高さ')),
                ('fps', models.FloatField(blank=True, null=True, verbose_name='FPS')),
                ('codec', models.CharField(blank=True, max_length=50, null=True, verbose_name='コーデック')),
                ('bitrate', models.IntegerField(blank=True, null=True, verbose_name='ビットレート')),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
                ('last_accessed', models.DateTimeField(blank=True, null=True)),
                ('folders', models.ManyToManyField(blank=True, related_name='files', to='videos.folder', verbose_name='所属フォルダ')),
                ('tags', models.ManyToManyField(blank=True, related_name='files', to='videos.tag', verbose_name='タグ')),
            ],
            options={
                'verbose_name': 'ファイル',
                'verbose_name_plural': 'ファイル',
                'db_table': 'files',
                'ordering': ['-created_at'],
                'indexes': [models.Index(fields=['file_size', 'md5_hash'], name='files_file_si_9d1719_idx'), models.Index(fields=['delete_flag', 'duplicate_flag'], name='files_delete__2332b5_idx')],
            },
        ),
    ]

```

```backend/videos/migrations/0002_file_file_path_hash.py
# Generated by Django 5.0.1 on 2025-09-21 15:10

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('videos', '0001_initial'),
    ]

    operations = [
        migrations.AddField(
            model_name='file',
            name='file_path_hash',
            field=models.CharField(blank=True, db_index=True, editable=False, max_length=64, null=True, unique=True, verbose_name='ファイルパスハッシュ'),
        ),
    ]

```

```backend/videos/models.py
"""
Models for video streaming application.
"""

import hashlib
from django.db import models
from django.core.validators import MinValueValidator
import json


def sha256_hex(s: str) -> str:
    return hashlib.sha256(s.encode('utf-8')).hexdigest()


class Group(models.Model):
    """タググループモデル"""
    name = models.CharField(max_length=100, unique=True, verbose_name='グループ名')
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        db_table = 'video_groups'
        verbose_name = 'タググループ'
        verbose_name_plural = 'タググループ'
        ordering = ['name']

    def __str__(self):
        return self.name


class Tag(models.Model):
    """タグモデル"""
    tag_name = models.CharField(max_length=100, unique=True, verbose_name='タグ名')
    groups = models.ManyToManyField(Group, related_name='tags', blank=True, verbose_name='所属グループ')
    usage_count = models.IntegerField(default=0, validators=[MinValueValidator(0)], verbose_name='使用回数')
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        db_table = 'tags'
        verbose_name = 'タグ'
        verbose_name_plural = 'タグ'
        ordering = ['-usage_count', 'tag_name']

    def __str__(self):
        return self.tag_name

    def increment_usage(self):
        """使用回数をインクリメント"""
        self.usage_count += 1
        self.save(update_fields=['usage_count'])


class Folder(models.Model):
    """フォルダモデル"""
    folder_name = models.CharField(max_length=255, verbose_name='フォルダ名')
    parent = models.ForeignKey(
        'self',
        on_delete=models.CASCADE,
        null=True,
        blank=True,
        related_name='children',
        verbose_name='親フォルダ'
    )
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        db_table = 'folders'
        verbose_name = 'フォルダ'
        verbose_name_plural = 'フォルダ'
        ordering = ['parent__id', 'folder_name']
        unique_together = [['folder_name', 'parent']]

    def __str__(self):
        if self.parent:
            return f"{self.parent} / {self.folder_name}"
        return self.folder_name

    def get_full_path(self):
        """フルパスを取得"""
        if self.parent:
            return f"{self.parent.get_full_path()}/{self.folder_name}"
        return self.folder_name

    def get_ancestors(self):
        """祖先フォルダのリストを取得"""
        ancestors = []
        current = self.parent
        while current:
            ancestors.insert(0, current)
            current = current.parent
        return ancestors


class File(models.Model):
    """ファイルモデル"""
    file_name = models.CharField(max_length=255, verbose_name='ファイル名')
    file_path = models.CharField(max_length=255, verbose_name='ファイルパス', db_index=True)
    # 追加フィールド：固定長ハッシュ（SHA-256）。このフィールドをユニークキーとして使い、MySQLのインデックス長エラーを回避する
    file_path_hash = models.CharField(max_length=64, unique=True, editable=False, null=True, blank=True, verbose_name='ファイルパスハッシュ', db_index=True)

    file_size = models.BigIntegerField(validators=[MinValueValidator(0)], verbose_name='ファイルサイズ（バイト）')
    md5_hash = models.CharField(max_length=32, db_index=True, verbose_name='MD5ハッシュ')
    video_duration = models.FloatField(null=True, blank=True, validators=[MinValueValidator(0)], verbose_name='動画の長さ（秒）')
    folders = models.ManyToManyField(Folder, related_name='files', blank=True, verbose_name='所属フォルダ')
    tags = models.ManyToManyField('Tag', related_name='files', blank=True, verbose_name='タグ')
    delete_flag = models.BooleanField(default=False, db_index=True, verbose_name='削除フラグ')
    duplicate_flag = models.BooleanField(default=False, db_index=True, verbose_name='重複フラグ')
    thumbnail_file_path = models.CharField(max_length=255, null=True, blank=True, verbose_name='サムネイルGIFパス')

    # メタデータ用のJSONフィールド
    metadata = models.JSONField(default=dict, blank=True, verbose_name='メタデータ')

    # 動画情報
    width = models.IntegerField(null=True, blank=True, verbose_name='動画の幅')
    height = models.IntegerField(null=True, blank=True, verbose_name='動画の高さ')
    fps = models.FloatField(null=True, blank=True, verbose_name='FPS')
    codec = models.CharField(max_length=50, null=True, blank=True, verbose_name='コーデック')
    bitrate = models.IntegerField(null=True, blank=True, verbose_name='ビットレート')

    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    last_accessed = models.DateTimeField(null=True, blank=True)

    class Meta:
        db_table = 'files'
        verbose_name = 'ファイル'
        verbose_name_plural = 'ファイル'
        ordering = ['-created_at']
        indexes = [
            models.Index(fields=['file_size', 'md5_hash']),
            models.Index(fields=['delete_flag', 'duplicate_flag']),
        ]

    def __str__(self):
        return self.file_name

    def add_tag(self, tag_name):
        """タグを追加"""
        tag, created = Tag.objects.get_or_create(tag_name=tag_name)
        self.tags.add(tag)
        tag.increment_usage()
        return tag

    def remove_tag(self, tag_name):
        """タグを削除"""
        try:
            tag = Tag.objects.get(tag_name=tag_name)
            self.tags.remove(tag)
            if tag.usage_count > 0:
                tag.usage_count -= 1
                tag.save(update_fields=['usage_count'])
        except Tag.DoesNotExist:
            pass

    def add_to_folder(self, folder):
        """フォルダに追加"""
        self.folders.add(folder)

    def remove_from_folder(self, folder):
        """フォルダから削除"""
        self.folders.remove(folder)

    def mark_as_deleted(self):
        """削除フラグを設定"""
        self.delete_flag = True
        self.save(update_fields=['delete_flag', 'updated_at'])

    def restore(self):
        """削除フラグを解除"""
        self.delete_flag = False
        self.save(update_fields=['delete_flag', 'updated_at'])

    def mark_as_duplicate(self):
        """重複フラグを設定"""
        self.duplicate_flag = True
        self.save(update_fields=['duplicate_flag', 'updated_at'])

    def get_relative_thumbnail_path(self):
        """相対サムネイルパスを取得"""
        if self.thumbnail_file_path:
            return self.thumbnail_file_path.replace('\\', '/')
        return None

    # ここに save() を追加してハッシュをセットする（既存メソッドは消していません）
    def save(self, *args, **kwargs):
        # file_path が設定されているなら SHA-256 を計算して file_path_hash に入れる
        if self.file_path:
            self.file_path_hash = sha256_hex(self.file_path)
        super().save(*args, **kwargs)


class ScanHistory(models.Model):
    """ファイルスキャン履歴"""
    started_at = models.DateTimeField(auto_now_add=True, verbose_name='開始時刻')
    completed_at = models.DateTimeField(null=True, blank=True, verbose_name='完了時刻')
    status = models.CharField(
        max_length=20,
        choices=[
            ('running', '実行中'),
            ('completed', '完了'),
            ('failed', '失敗'),
        ],
        default='running',
        verbose_name='ステータス'
    )
    files_scanned = models.IntegerField(default=0, verbose_name='スキャン済みファイル数')
    files_added = models.IntegerField(default=0, verbose_name='追加ファイル数')
    files_updated = models.IntegerField(default=0, verbose_name='更新ファイル数')
    duplicates_found = models.IntegerField(default=0, verbose_name='重複ファイル数')
    errors = models.JSONField(default=list, blank=True, verbose_name='エラー')

    class Meta:
        db_table = 'scan_history'
        verbose_name = 'スキャン履歴'
        verbose_name_plural = 'スキャン履歴'
        ordering = ['-started_at']

    def __str__(self):
        return f"Scan {self.started_at.strftime('%Y-%m-%d %H:%M:%S')}"

```

```backend/videos/routing.py
"""
WebSocket routing for videos application.
"""

from django.urls import re_path

# WebSocketのURLパターン（現在は空だが、将来的にリアルタイム機能を追加する場合に使用）
websocket_urlpatterns = [
    # 例: re_path(r'ws/scan-status/$', ScanStatusConsumer.as_asgi()),
]
```

```backend/videos/serializers.py
"""
Serializers for video streaming application.
"""

from rest_framework import serializers
from .models import File, Folder, Tag, Group, ScanHistory


class GroupSerializer(serializers.ModelSerializer):
    """タググループシリアライザー"""
    tags_count = serializers.IntegerField(source='tags.count', read_only=True)
    
    class Meta:
        model = Group
        fields = ['id', 'name', 'tags_count', 'created_at', 'updated_at']
        read_only_fields = ['created_at', 'updated_at']


class TagSerializer(serializers.ModelSerializer):
    """タグシリアライザー"""
    groups = GroupSerializer(many=True, read_only=True)
    group_ids = serializers.PrimaryKeyRelatedField(
        many=True, 
        queryset=Group.objects.all(), 
        write_only=True, 
        required=False,
        source='groups'
    )
    
    class Meta:
        model = Tag
        fields = ['id', 'tag_name', 'groups', 'group_ids', 'usage_count', 'created_at', 'updated_at']
        read_only_fields = ['usage_count', 'created_at', 'updated_at']


class FolderSerializer(serializers.ModelSerializer):
    """フォルダシリアライザー"""
    full_path = serializers.CharField(source='get_full_path', read_only=True)
    children_count = serializers.IntegerField(source='children.count', read_only=True)
    files_count = serializers.IntegerField(source='files.count', read_only=True)
    parent_id = serializers.PrimaryKeyRelatedField(
        queryset=Folder.objects.all(),
        source='parent',
        allow_null=True,
        required=False
    )
    
    class Meta:
        model = Folder
        fields = [
            'id', 'folder_name', 'parent', 'parent_id', 'full_path', 
            'children_count', 'files_count', 'created_at', 'updated_at'
        ]
        read_only_fields = ['created_at', 'updated_at']
    
    def validate(self, data):
        """循環参照のチェック"""
        if self.instance and 'parent' in data:
            parent = data['parent']
            if parent:
                # 自分自身を親にできない
                if parent.id == self.instance.id:
                    raise serializers.ValidationError("フォルダは自分自身を親にできません。")
                
                # 自分の子孫を親にできない
                current = parent
                while current.parent:
                    if current.parent.id == self.instance.id:
                        raise serializers.ValidationError("フォルダの子孫を親にすることはできません。")
                    current = current.parent
        
        return data


class FileListSerializer(serializers.ModelSerializer):
    """ファイルリスト用シリアライザー（軽量版）"""
    thumbnail_url = serializers.SerializerMethodField()
    folder_ids = serializers.PrimaryKeyRelatedField(
        many=True, 
        source='folders',
        read_only=True
    )
    tag_names = serializers.StringRelatedField(
        many=True,
        source='tags',
        read_only=True
    )
    
    class Meta:
        model = File
        fields = [
            'id', 'file_name', 'file_size', 'video_duration',
            'folder_ids', 'tag_names', 'delete_flag', 'duplicate_flag',
            'thumbnail_url', 'created_at', 'updated_at'
        ]
    
    def get_thumbnail_url(self, obj):
        """サムネイルURLを取得"""
        if obj.thumbnail_file_path:
            request = self.context.get('request')
            if request:
                return request.build_absolute_uri(f'/media/{obj.get_relative_thumbnail_path()}')
        return None


class FileDetailSerializer(serializers.ModelSerializer):
    """ファイル詳細シリアライザー"""
    folders = FolderSerializer(many=True, read_only=True)
    tags = TagSerializer(many=True, read_only=True)
    thumbnail_url = serializers.SerializerMethodField()
    video_url = serializers.SerializerMethodField()
    
    folder_ids = serializers.PrimaryKeyRelatedField(
        many=True,
        queryset=Folder.objects.all(),
        write_only=True,
        required=False,
        source='folders'
    )
    tag_ids = serializers.PrimaryKeyRelatedField(
        many=True,
        queryset=Tag.objects.all(),
        write_only=True,
        required=False,
        source='tags'
    )
    tag_names = serializers.ListField(
        child=serializers.CharField(),
        write_only=True,
        required=False
    )
    
    class Meta:
        model = File
        fields = [
            'id', 'file_name', 'file_path', 'file_size', 'md5_hash',
            'video_duration', 'folders', 'folder_ids', 'tags', 'tag_ids', 'tag_names',
            'delete_flag', 'duplicate_flag', 'thumbnail_url', 'video_url',
            'metadata', 'width', 'height', 'fps', 'codec', 'bitrate',
            'created_at', 'updated_at', 'last_accessed'
        ]
        read_only_fields = [
            'file_path', 'file_size', 'md5_hash', 'video_duration',
            'width', 'height', 'fps', 'codec', 'bitrate',
            'created_at', 'updated_at'
        ]
    
    def get_thumbnail_url(self, obj):
        """サムネイルURLを取得"""
        if obj.thumbnail_file_path:
            request = self.context.get('request')
            if request:
                return request.build_absolute_uri(f'/media/{obj.get_relative_thumbnail_path()}')
        return None
    
    def get_video_url(self, obj):
        """動画URLを取得"""
        request = self.context.get('request')
        if request:
            relative_path = obj.file_path.replace('\\', '/')
            if relative_path.startswith('media/'):
                relative_path = relative_path[6:]
            return request.build_absolute_uri(f'/media/{relative_path}')
        return None
    
    def update(self, instance, validated_data):
        """更新処理"""
        # タグ名からタグを作成/取得
        tag_names = validated_data.pop('tag_names', None)
        if tag_names is not None:
            for tag_name in tag_names:
                instance.add_tag(tag_name)
        
        # フォルダとタグの更新
        folders = validated_data.pop('folders', None)
        tags = validated_data.pop('tags', None)
        
        instance = super().update(instance, validated_data)
        
        if folders is not None:
            instance.folders.set(folders)
        
        if tags is not None:
            instance.tags.set(tags)
            # 使用回数の更新
            for tag in tags:
                tag.increment_usage()
        
        return instance


class FileBulkActionSerializer(serializers.Serializer):
    """ファイル一括操作用シリアライザー"""
    file_ids = serializers.ListField(
        child=serializers.IntegerField(),
        required=True
    )
    action = serializers.ChoiceField(
        choices=[
            ('delete', '削除フラグ設定'),
            ('restore', '削除フラグ解除'),
            ('add_to_folder', 'フォルダに追加'),
            ('remove_from_folder', 'フォルダから削除'),
            ('add_tags', 'タグ追加'),
            ('remove_tags', 'タグ削除'),
        ],
        required=True
    )
    folder_id = serializers.IntegerField(required=False)
    tag_ids = serializers.ListField(
        child=serializers.IntegerField(),
        required=False
    )
    tag_names = serializers.ListField(
        child=serializers.CharField(),
        required=False
    )


class ScanHistorySerializer(serializers.ModelSerializer):
    """スキャン履歴シリアライザー"""
    duration = serializers.SerializerMethodField()
    
    class Meta:
        model = ScanHistory
        fields = [
            'id', 'started_at', 'completed_at', 'status',
            'files_scanned', 'files_added', 'files_updated',
            'duplicates_found', 'errors', 'duration'
        ]
    
    def get_duration(self, obj):
        """実行時間を取得"""
        if obj.completed_at and obj.started_at:
            delta = obj.completed_at - obj.started_at
            return delta.total_seconds()
        return None
```

```backend/videos/tasks.py
"""
Background tasks for video processing.
"""

import logging
from celery import shared_task
from django.utils import timezone
from datetime import timedelta
from .utils import scan_video_directory, check_and_mark_duplicates

logger = logging.getLogger('videos')


@shared_task
def periodic_scan_task():
    """
    定期的なファイルスキャンタスク
    """
    logger.info("Starting periodic file scan task...")
    
    try:
        # ファイルスキャンを実行
        scan_history = scan_video_directory()
        
        # 重複チェック
        duplicates = check_and_mark_duplicates()
        
        logger.info(f"Periodic scan completed. Files added: {scan_history.files_added}, Duplicates: {duplicates}")
        
        return {
            'status': 'success',
            'scan_id': scan_history.id,
            'files_added': scan_history.files_added,
            'files_updated': scan_history.files_updated,
            'duplicates_found': duplicates
        }
    
    except Exception as e:
        logger.error(f"Periodic scan failed: {str(e)}")
        return {
            'status': 'failed',
            'error': str(e)
        }


@shared_task
def cleanup_old_scan_history():
    """
    古いスキャン履歴を削除
    """
    from .models import ScanHistory
    
    # 30日以上前の履歴を削除
    cutoff_date = timezone.now() - timedelta(days=30)
    deleted_count = ScanHistory.objects.filter(started_at__lt=cutoff_date).delete()[0]
    
    logger.info(f"Deleted {deleted_count} old scan history records")
    return deleted_count


@shared_task
def generate_missing_thumbnails():
    """
    サムネイルが欠けているファイルのGIFを生成
    """
    from .models import File
    from .utils import create_gif_thumbnail
    import os
    from django.conf import settings
    
    files_without_thumbnails = File.objects.filter(
        thumbnail_file_path__isnull=True,
        delete_flag=False
    )
    
    generated_count = 0
    
    for file in files_without_thumbnails:
        try:
            video_path = os.path.join(settings.MEDIA_ROOT, file.file_path)
            
            if not os.path.exists(video_path):
                logger.warning(f"Video file not found: {video_path}")
                continue
            
            gif_filename = f"{os.path.splitext(file.file_name)[0]}.gif"
            gif_path = os.path.join(settings.GIF_DIR, gif_filename)
            
            if create_gif_thumbnail(video_path, gif_path):
                file.thumbnail_file_path = f"gifs/{gif_filename}"
                file.save(update_fields=['thumbnail_file_path', 'updated_at'])
                generated_count += 1
                logger.info(f"Generated thumbnail for: {file.file_name}")
        
        except Exception as e:
            logger.error(f"Failed to generate thumbnail for {file.file_name}: {str(e)}")
    
    logger.info(f"Generated {generated_count} missing thumbnails")
    return generated_count
```

```backend/videos/urls.py
"""
URL routing for videos application.
"""

from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import (
    FileViewSet, FolderViewSet, TagViewSet, GroupViewSet,
    ScanView, ScanHistoryViewSet
)

router = DefaultRouter()
router.register(r'files', FileViewSet, basename='file')
router.register(r'folders', FolderViewSet, basename='folder')
router.register(r'tags', TagViewSet, basename='tag')
router.register(r'groups', GroupViewSet, basename='group')
router.register(r'scan-history', ScanHistoryViewSet, basename='scan-history')

urlpatterns = [
    path('', include(router.urls)),
    path('force_refresh/', ScanView.as_view(), name='force-refresh'),
    
    # 特殊なファイルリスト用エンドポイント
    path('files/all/', FileViewSet.as_view({'get': 'all_files'}), name='all-files'),
    path('files/no-folder/', FileViewSet.as_view({'get': 'no_folder_files'}), name='no-folder-files'),
    path('files/deleted/', FileViewSet.as_view({'get': 'deleted_files'}), name='deleted-files'),
    path('files/duplicates/', FileViewSet.as_view({'get': 'duplicate_files'}), name='duplicate-files'),
]
```

```backend/videos/utils.py
"""
Utility functions for video processing and file management.
"""

import os
import hashlib
import subprocess
import json
import logging
from pathlib import Path
from datetime import datetime
import ffmpeg
import imageio
from django.conf import settings
from .models import File, ScanHistory

logger = logging.getLogger('videos')


def get_video_info(file_path):
    """
    FFmpegを使用して動画情報を取得
    """
    try:
        probe = ffmpeg.probe(file_path)
        video_stream = next((stream for stream in probe['streams'] if stream['codec_type'] == 'video'), None)
        
        if video_stream:
            duration = float(probe['format'].get('duration', 0))
            width = int(video_stream.get('width', 0))
            height = int(video_stream.get('height', 0))
            fps = eval(video_stream.get('r_frame_rate', '0/1'))
            if isinstance(fps, tuple):
                fps = fps[0] / fps[1] if fps[1] != 0 else 0
            codec = video_stream.get('codec_name', '')
            bitrate = int(probe['format'].get('bit_rate', 0))
            
            return {
                'duration': duration,
                'width': width,
                'height': height,
                'fps': fps,
                'codec': codec,
                'bitrate': bitrate
            }
    except Exception as e:
        logger.error(f"Error getting video info for {file_path}: {e}")
    
    return None


def calculate_md5_partial(file_path, max_size=10*1024*1024):
    """
    ファイルの最初の部分のMD5ハッシュを計算（大きなファイル用）
    FFmpegを使用して最初のキーフレームまでをコピーしてから計算
    """
    try:
        # 一時ファイルパス
        temp_file = file_path + '.temp.mp4'
        
        # FFmpegで最初の部分をコピー
        try:
            (
                ffmpeg
                .input(file_path)
                .output(temp_file, t=1, c='copy', f='mp4')
                .overwrite_output()
                .run(capture_stdout=True, capture_stderr=True)
            )
        except ffmpeg.Error:
            # エラーが発生した場合は直接ファイルを読む
            return calculate_md5_direct(file_path, max_size)
        
        # 一時ファイルのMD5を計算
        md5_hash = hashlib.md5()
        with open(temp_file, 'rb') as f:
            while chunk := f.read(8192):
                md5_hash.update(chunk)
        
        # 一時ファイルを削除
        if os.path.exists(temp_file):
            os.remove(temp_file)
        
        return md5_hash.hexdigest()
    
    except Exception as e:
        logger.error(f"Error calculating MD5 for {file_path}: {e}")
        # フォールバック：直接ファイルを読む
        return calculate_md5_direct(file_path, max_size)


def calculate_md5_direct(file_path, max_size=10*1024*1024):
    """
    ファイルの最初の部分を直接読んでMD5を計算（フォールバック）
    """
    try:
        md5_hash = hashlib.md5()
        with open(file_path, 'rb') as f:
            bytes_read = 0
            while bytes_read < max_size:
                chunk = f.read(min(8192, max_size - bytes_read))
                if not chunk:
                    break
                md5_hash.update(chunk)
                bytes_read += len(chunk)
        return md5_hash.hexdigest()
    except Exception as e:
        logger.error(f"Error calculating MD5 (direct) for {file_path}: {e}")
        return None


def create_gif_thumbnail(video_path, gif_path, duration=10, fps=10, scale=320):
    """
    動画からGIFサムネイルを作成
    """
    try:
        # 出力ディレクトリを確認
        os.makedirs(os.path.dirname(gif_path), exist_ok=True)
        
        # 動画情報を取得
        video_info = get_video_info(video_path)
        if not video_info:
            return False
        
        # GIF作成時間を決定（動画が短い場合は動画全体）
        gif_duration = min(duration, video_info['duration'])
        
        # FFmpegでGIFを生成
        try:
            (
                ffmpeg
                .input(video_path, ss=0, t=gif_duration)
                .filter('fps', fps=fps)
                .filter('scale', scale, -1)
                .output(gif_path, loop=0)
                .overwrite_output()
                .run(capture_stdout=True, capture_stderr=True)
            )
            return True
        except ffmpeg.Error as e:
            logger.error(f"FFmpeg error creating GIF: {e.stderr.decode()}")
            return False
    
    except Exception as e:
        logger.error(f"Error creating GIF thumbnail for {video_path}: {e}")
        return False


def scan_video_directory():
    """
    動画ディレクトリをスキャンしてデータベースを更新
    """
    scan_history = ScanHistory.objects.create()
    
    video_dir = settings.VIDEO_DIR
    gif_dir = settings.GIF_DIR
    
    if not os.path.exists(video_dir):
        logger.error(f"Video directory does not exist: {video_dir}")
        scan_history.status = 'failed'
        scan_history.errors = [f"Video directory does not exist: {video_dir}"]
        scan_history.save()
        return scan_history
    
    # 対象の動画拡張子
    video_extensions = {'.mp4', '.avi', '.mkv', '.mov', '.wmv', '.flv', '.webm', '.m4v', '.mpg', '.mpeg'}
    
    files_scanned = 0
    files_added = 0
    files_updated = 0
    duplicates_found = 0
    errors = []
    
    try:
        # ディレクトリ内のすべてのファイルを走査
        for root, dirs, files in os.walk(video_dir):
            for filename in files:
                file_path = os.path.join(root, filename)
                
                # 動画ファイルのみ処理
                if not any(filename.lower().endswith(ext) for ext in video_extensions):
                    continue
                
                files_scanned += 1
                
                try:
                    # ファイル情報を取得
                    file_size = os.path.getsize(file_path)
                    relative_path = os.path.relpath(file_path, settings.MEDIA_ROOT)
                    
                    # データベースに存在するか確認（ファイル名とサイズで）
                    existing_file = File.objects.filter(
                        file_name=filename,
                        file_size=file_size
                    ).first()
                    
                    if existing_file:
                        # 既存ファイルの場合はパスを更新
                        if existing_file.file_path != relative_path:
                            existing_file.file_path = relative_path
                            existing_file.save(update_fields=['file_path', 'updated_at'])
                            files_updated += 1
                        continue
                    
                    # MD5ハッシュを計算
                    md5_hash = calculate_md5_partial(file_path)
                    if not md5_hash:
                        errors.append(f"Failed to calculate MD5 for {file_path}")
                        continue
                    
                    # 重複チェック
                    is_duplicate = File.objects.filter(
                        file_size=file_size,
                        md5_hash=md5_hash
                    ).exists()
                    
                    if is_duplicate:
                        # 既存の重複ファイルにもフラグを設定
                        File.objects.filter(
                            file_size=file_size,
                            md5_hash=md5_hash
                        ).update(duplicate_flag=True)
                        duplicates_found += 1
                    
                    # 動画情報を取得
                    video_info = get_video_info(file_path)
                    
                    # GIFサムネイルを作成
                    gif_filename = f"{os.path.splitext(filename)[0]}.gif"
                    gif_path = os.path.join(gif_dir, gif_filename)
                    gif_created = create_gif_thumbnail(file_path, gif_path)
                    
                    # ファイルレコードを作成
                    file_record = File(
                        file_name=filename,
                        file_path=relative_path,
                        file_size=file_size,
                        md5_hash=md5_hash,
                        duplicate_flag=is_duplicate
                    )
                    
                    if video_info:
                        file_record.video_duration = video_info['duration']
                        file_record.width = video_info['width']
                        file_record.height = video_info['height']
                        file_record.fps = video_info['fps']
                        file_record.codec = video_info['codec']
                        file_record.bitrate = video_info['bitrate']
                    
                    if gif_created:
                        file_record.thumbnail_file_path = f"gifs/{gif_filename}"
                    
                    file_record.save()
                    files_added += 1
                    
                    logger.info(f"Added file: {filename}")
                
                except Exception as e:
                    error_msg = f"Error processing file {file_path}: {str(e)}"
                    logger.error(error_msg)
                    errors.append(error_msg)
        
        # スキャン履歴を更新
        scan_history.completed_at = datetime.now()
        scan_history.status = 'completed'
        scan_history.files_scanned = files_scanned
        scan_history.files_added = files_added
        scan_history.files_updated = files_updated
        scan_history.duplicates_found = duplicates_found
        scan_history.errors = errors
        scan_history.save()
        
        logger.info(f"Scan completed: {files_scanned} scanned, {files_added} added, {files_updated} updated, {duplicates_found} duplicates")
        
    except Exception as e:
        error_msg = f"Scan failed: {str(e)}"
        logger.error(error_msg)
        scan_history.completed_at = datetime.now()
        scan_history.status = 'failed'
        scan_history.errors = [error_msg]
        scan_history.save()
    
    return scan_history


def check_and_mark_duplicates():
    """
    すべてのファイルの重複をチェックしてフラグを更新
    """
    from django.db.models import Count
    
    # 重複の可能性があるグループを検索
    duplicate_groups = File.objects.values('file_size', 'md5_hash').annotate(
        count=Count('id')
    ).filter(count__gt=1)
    
    duplicates_marked = 0
    
    for group in duplicate_groups:
        # 同じサイズとMD5を持つファイルを取得
        files = File.objects.filter(
            file_size=group['file_size'],
            md5_hash=group['md5_hash']
        )
        
        # すべてに重複フラグを設定
        updated = files.update(duplicate_flag=True)
        duplicates_marked += updated
    
    logger.info(f"Marked {duplicates_marked} files as duplicates")
    return duplicates_marked
```

```backend/videos/views.py
"""
Views for video streaming application.
"""

from rest_framework import viewsets, status
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework.views import APIView
from django.db.models import Q, Count
from django.utils import timezone
import logging

from .models import File, Folder, Tag, Group, ScanHistory
from .serializers import (
    FileListSerializer, FileDetailSerializer, FileBulkActionSerializer,
    FolderSerializer, TagSerializer, GroupSerializer, ScanHistorySerializer
)
from .utils import scan_video_directory, check_and_mark_duplicates

logger = logging.getLogger('videos')


class FileViewSet(viewsets.ModelViewSet):
    """ファイルビューセット"""
    queryset = File.objects.all()
    
    def get_serializer_class(self):
        if self.action in ['list']:
            return FileListSerializer
        return FileDetailSerializer
    
    def get_queryset(self):
        queryset = super().get_queryset()
        
        # クエリパラメータでフィルタリング
        params = self.request.query_params
        
        # 削除フラグでフィルタ
        delete_flag = params.get('delete_flag')
        if delete_flag is not None:
            queryset = queryset.filter(delete_flag=delete_flag.lower() == 'true')
        
        # 重複フラグでフィルタ
        duplicate_flag = params.get('duplicate_flag')
        if duplicate_flag is not None:
            queryset = queryset.filter(duplicate_flag=duplicate_flag.lower() == 'true')
        
        # フォルダでフィルタ
        folder_id = params.get('folder_id')
        if folder_id:
            queryset = queryset.filter(folders__id=folder_id)
        
        # フォルダに属さないファイル
        no_folder = params.get('no_folder')
        if no_folder and no_folder.lower() == 'true':
            queryset = queryset.filter(folders__isnull=True)
        
        # タグでフィルタ
        tag_ids = params.getlist('tag_ids')
        if tag_ids:
            queryset = queryset.filter(tags__id__in=tag_ids).distinct()
        
        # 検索
        search = params.get('search')
        if search:
            queryset = queryset.filter(
                Q(file_name__icontains=search) |
                Q(tags__tag_name__icontains=search)
            ).distinct()
        
        # ソート
        sort_by = params.get('sort_by', '-created_at')
        queryset = queryset.order_by(sort_by)
        
        return queryset
    
    @action(detail=False, methods=['get'])
    def all_files(self, request):
        """削除されていないすべてのファイル"""
        queryset = self.get_queryset().filter(delete_flag=False)
        page = self.paginate_queryset(queryset)
        if page is not None:
            serializer = FileListSerializer(page, many=True, context={'request': request})
            return self.get_paginated_response(serializer.data)
        serializer = FileListSerializer(queryset, many=True, context={'request': request})
        return Response(serializer.data)
    
    @action(detail=False, methods=['get'])
    def no_folder_files(self, request):
        """フォルダに属さないファイル"""
        queryset = self.get_queryset().filter(folders__isnull=True, delete_flag=False)
        page = self.paginate_queryset(queryset)
        if page is not None:
            serializer = FileListSerializer(page, many=True, context={'request': request})
            return self.get_paginated_response(serializer.data)
        serializer = FileListSerializer(queryset, many=True, context={'request': request})
        return Response(serializer.data)
    
    @action(detail=False, methods=['get'])
    def deleted_files(self, request):
        """削除フラグが付いたファイル"""
        queryset = self.get_queryset().filter(delete_flag=True)
        page = self.paginate_queryset(queryset)
        if page is not None:
            serializer = FileListSerializer(page, many=True, context={'request': request})
            return self.get_paginated_response(serializer.data)
        serializer = FileListSerializer(queryset, many=True, context={'request': request})
        return Response(serializer.data)
    
    @action(detail=False, methods=['get'])
    def duplicate_files(self, request):
        """重複フラグが付いたファイル"""
        queryset = self.get_queryset().filter(duplicate_flag=True)
        page = self.paginate_queryset(queryset)
        if page is not None:
            serializer = FileListSerializer(page, many=True, context={'request': request})
            return self.get_paginated_response(serializer.data)
        serializer = FileListSerializer(queryset, many=True, context={'request': request})
        return Response(serializer.data)
    
    @action(detail=True, methods=['post'])
    def mark_deleted(self, request, pk=None):
        """削除フラグを設定"""
        file = self.get_object()
        file.mark_as_deleted()
        serializer = FileDetailSerializer(file, context={'request': request})
        return Response(serializer.data)
    
    @action(detail=True, methods=['post'])
    def restore(self, request, pk=None):
        """削除フラグを解除"""
        file = self.get_object()
        file.restore()
        serializer = FileDetailSerializer(file, context={'request': request})
        return Response(serializer.data)
    
    @action(detail=True, methods=['post'])
    def add_to_folder(self, request, pk=None):
        """フォルダに追加"""
        file = self.get_object()
        folder_id = request.data.get('folder_id')
        
        if not folder_id:
            return Response({'error': 'folder_id is required'}, status=status.HTTP_400_BAD_REQUEST)
        
        try:
            folder = Folder.objects.get(id=folder_id)
            file.add_to_folder(folder)
            serializer = FileDetailSerializer(file, context={'request': request})
            return Response(serializer.data)
        except Folder.DoesNotExist:
            return Response({'error': 'Folder not found'}, status=status.HTTP_404_NOT_FOUND)
    
    @action(detail=True, methods=['post'])
    def remove_from_folder(self, request, pk=None):
        """フォルダから削除"""
        file = self.get_object()
        folder_id = request.data.get('folder_id')
        
        if not folder_id:
            return Response({'error': 'folder_id is required'}, status=status.HTTP_400_BAD_REQUEST)
        
        try:
            folder = Folder.objects.get(id=folder_id)
            file.remove_from_folder(folder)
            serializer = FileDetailSerializer(file, context={'request': request})
            return Response(serializer.data)
        except Folder.DoesNotExist:
            return Response({'error': 'Folder not found'}, status=status.HTTP_404_NOT_FOUND)
    
    @action(detail=True, methods=['post'])
    def add_tags(self, request, pk=None):
        """タグを追加"""
        file = self.get_object()
        tag_names = request.data.get('tag_names', [])
        
        for tag_name in tag_names:
            file.add_tag(tag_name)
        
        serializer = FileDetailSerializer(file, context={'request': request})
        return Response(serializer.data)
    
    @action(detail=True, methods=['post'])
    def remove_tags(self, request, pk=None):
        """タグを削除"""
        file = self.get_object()
        tag_names = request.data.get('tag_names', [])
        
        for tag_name in tag_names:
            file.remove_tag(tag_name)
        
        serializer = FileDetailSerializer(file, context={'request': request})
        return Response(serializer.data)
    
    @action(detail=False, methods=['post'])
    def bulk_action(self, request):
        """一括操作"""
        serializer = FileBulkActionSerializer(data=request.data)
        
        if not serializer.is_valid():
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
        
        data = serializer.validated_data
        file_ids = data['file_ids']
        action = data['action']
        
        files = File.objects.filter(id__in=file_ids)
        
        if action == 'delete':
            files.update(delete_flag=True, updated_at=timezone.now())
        elif action == 'restore':
            files.update(delete_flag=False, updated_at=timezone.now())
        elif action == 'add_to_folder':
            folder_id = data.get('folder_id')
            if folder_id:
                try:
                    folder = Folder.objects.get(id=folder_id)
                    for file in files:
                        file.add_to_folder(folder)
                except Folder.DoesNotExist:
                    return Response({'error': 'Folder not found'}, status=status.HTTP_404_NOT_FOUND)
        elif action == 'remove_from_folder':
            folder_id = data.get('folder_id')
            if folder_id:
                try:
                    folder = Folder.objects.get(id=folder_id)
                    for file in files:
                        file.remove_from_folder(folder)
                except Folder.DoesNotExist:
                    return Response({'error': 'Folder not found'}, status=status.HTTP_404_NOT_FOUND)
        elif action == 'add_tags':
            tag_names = data.get('tag_names', [])
            for file in files:
                for tag_name in tag_names:
                    file.add_tag(tag_name)
        elif action == 'remove_tags':
            tag_names = data.get('tag_names', [])
            for file in files:
                for tag_name in tag_names:
                    file.remove_tag(tag_name)
        
        return Response({'success': True, 'files_affected': files.count()})
    
    def retrieve(self, request, *args, **kwargs):
        """ファイル詳細取得時に最終アクセス時刻を更新"""
        instance = self.get_object()
        instance.last_accessed = timezone.now()
        instance.save(update_fields=['last_accessed'])
        serializer = self.get_serializer(instance)
        return Response(serializer.data)


class FolderViewSet(viewsets.ModelViewSet):
    """フォルダビューセット"""
    queryset = Folder.objects.all()
    serializer_class = FolderSerializer
    
    def get_queryset(self):
        queryset = super().get_queryset()
        
        # 親フォルダでフィルタ
        parent_id = self.request.query_params.get('parent_id')
        if parent_id == 'null':
            queryset = queryset.filter(parent__isnull=True)
        elif parent_id:
            queryset = queryset.filter(parent_id=parent_id)
        
        return queryset
    
    @action(detail=False, methods=['get'])
    def tree(self, request):
        """フォルダツリー構造を取得"""
        def build_tree(parent=None):
            folders = []
            for folder in Folder.objects.filter(parent=parent):
                folder_data = FolderSerializer(folder).data
                folder_data['children'] = build_tree(folder)
                folders.append(folder_data)
            return folders
        
        tree = build_tree()
        return Response(tree)


class TagViewSet(viewsets.ModelViewSet):
    """タグビューセット"""
    queryset = Tag.objects.all()
    serializer_class = TagSerializer
    
    @action(detail=False, methods=['get'])
    def popular(self, request):
        """人気のタグを取得"""
        limit = int(request.query_params.get('limit', 20))
        tags = self.queryset.order_by('-usage_count')[:limit]
        serializer = self.get_serializer(tags, many=True)
        return Response(serializer.data)
    
    @action(detail=False, methods=['get'])
    def search(self, request):
        """タグを検索"""
        query = request.query_params.get('q', '')
        if query:
            tags = self.queryset.filter(tag_name__icontains=query)
        else:
            tags = self.queryset.all()
        
        serializer = self.get_serializer(tags, many=True)
        return Response(serializer.data)


class GroupViewSet(viewsets.ModelViewSet):
    """タググループビューセット"""
    queryset = Group.objects.all()
    serializer_class = GroupSerializer


class ScanView(APIView):
    """ファイルスキャンビュー"""
    
    def get(self, request, format=None):
        """強制スキャンを実行"""
        logger.info("Starting forced file scan...")
        scan_history = scan_video_directory()
        
        # 重複チェック
        check_and_mark_duplicates()
        
        serializer = ScanHistorySerializer(scan_history)
        return Response(serializer.data)


class ScanHistoryViewSet(viewsets.ReadOnlyModelViewSet):
    """スキャン履歴ビューセット"""
    queryset = ScanHistory.objects.all()
    serializer_class = ScanHistorySerializer
    
    @action(detail=False, methods=['get'])
    def latest(self, request):
        """最新のスキャン履歴を取得"""
        latest = self.queryset.first()
        if latest:
            serializer = self.get_serializer(latest)
            return Response(serializer.data)
        return Response({'message': 'No scan history found'}, status=status.HTTP_404_NOT_FOUND)
```

```Django Video Streaming Backend Setup - Claude.url
[InternetShortcut]
URL=https://claude.ai/chat/976505d8-44b8-48af-bf93-41ef21bbabcc

```

```install.bat
@echo off
echo ========================================
echo Video Streaming Backend Installation
echo ========================================
echo.

:: Python仮想環境の作成
echo [1/8] Creating Python virtual environment...
python -m venv venv
if errorlevel 1 (
    echo Error: Failed to create virtual environment.
    pause
    exit /b 1
)

:: 仮想環境のアクティベート
echo [2/8] Activating virtual environment...
call venv\Scripts\activate.bat
if errorlevel 1 (
    echo Error: Failed to activate virtual environment.
    pause
    exit /b 1
)

:: pipのアップグレード
echo [3/8] Upgrading pip...
python -m pip install --upgrade pip

:: 依存関係のインストール
echo [4/8] Installing Python dependencies...
pip install -r requirements.txt
if errorlevel 1 (
    echo Error: Failed to install dependencies.
    pause
    exit /b 1
)

:: メディアフォルダの作成
echo [5/8] Creating media directories...
if not exist "media" mkdir media
if not exist "media\videos" mkdir media\videos
if not exist "media\gifs" mkdir media\gifs
if not exist "logs" mkdir logs

:: MySQLデータベースの作成（MySQLが環境変数に設定されている前提）
echo [6/8] Setting up MySQL database...
echo Please enter MySQL root password:
set /p MYSQL_ROOT_PASSWORD=
mysql -u root -p%MYSQL_ROOT_PASSWORD% -e "CREATE DATABASE IF NOT EXISTS video_streaming_db CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;"
mysql -u root -p%MYSQL_ROOT_PASSWORD% -e "CREATE USER IF NOT EXISTS 'video_user'@'localhost' IDENTIFIED BY 'video_pass_2024';"
mysql -u root -p%MYSQL_ROOT_PASSWORD% -e "GRANT ALL PRIVILEGES ON video_streaming_db.* TO 'video_user'@'localhost';"
mysql -u root -p%MYSQL_ROOT_PASSWORD% -e "FLUSH PRIVILEGES;"

:: Djangoの初期設定
echo [7/8] Running Django migrations...
cd backend
python manage.py makemigrations
python manage.py migrate
if errorlevel 1 (
    echo Error: Failed to run migrations.
    cd ..
    pause
    exit /b 1
)

:: スーパーユーザーの作成
echo [8/8] Creating Django superuser...
echo.
echo Please create a superuser account:
python manage.py createsuperuser

cd ..

echo.
echo ========================================
echo Installation completed successfully!
echo ========================================
echo.
echo To start the server, run: runserver.bat
echo.
pause
```

```logs/django.log
[ファイル読み込みエラー: The process cannot access the file 'C:\dev\video_streaming\logs\django.log' because it is being used by another process.]
```

```readme.md
# 動画配信サイト バックエンド

自宅用の動画配信サイトのバックエンドシステムです。  
Django + Django REST Framework + MySQL + Daphne で構築されています。

## システム要件

- Windows 11
- Python 3.10以上
- MySQL 8.0以上
- Redis（オプション：Celeryを使用する場合）
- FFmpeg（動画処理用）

## 事前準備

### 1. FFmpegのインストール

1. [FFmpeg公式サイト](https://ffmpeg.org/download.html)からWindows用バイナリをダウンロード
2. 適当な場所に解凍（例：`C:\ffmpeg`）
3. システム環境変数のPATHに追加（例：`C:\ffmpeg\bin`）

### 2. MySQLのインストール

1. [MySQL公式サイト](https://dev.mysql.com/downloads/installer/)からMySQL Installerをダウンロード
2. インストール時にrootパスワードを設定

### 3. Redis（オプション）

Celeryを使用する場合：
1. [Redis for Windows](https://github.com/microsoftarchive/redis/releases)からダウンロード
2. インストールしてサービスとして実行

## セットアップ手順

### 1. プロジェクトのクローン/配置

```bash
# プロジェクトフォルダを作成
mkdir video_streaming
cd video_streaming

# ファイルを配置
# - install.bat
# - runserver.bat
# - requirements.txt
# - backend/
```

### 2. インストールの実行

```bash
# install.batを実行
install.bat
```

インストール中に以下の入力が求められます：
1. MySQLのrootパスワード
2. Django管理者アカウントの情報

### 3. 動画ファイルの配置

`media/videos/` フォルダに動画ファイルを配置してください。  
対応フォーマット：mp4, avi, mkv, mov, wmv, flv, webm, m4v, mpg, mpeg

## サーバーの起動

```bash
# runserver.batを実行
runserver.bat
```

サーバーは `http://localhost:8000` で起動します。

## API エンドポイント

### ファイル管理

- `GET /api/files/` - ファイル一覧
- `GET /api/files/all/` - 削除されていないすべてのファイル
- `GET /api/files/no-folder/` - フォルダに属さないファイル
- `GET /api/files/deleted/` - 削除フラグが付いたファイル
- `GET /api/files/duplicates/` - 重複ファイル
- `GET /api/files/{id}/` - ファイル詳細
- `POST /api/files/{id}/mark_deleted/` - 削除フラグ設定
- `POST /api/files/{id}/restore/` - 削除フラグ解除
- `POST /api/files/{id}/add_to_folder/` - フォルダに追加
- `POST /api/files/{id}/remove_from_folder/` - フォルダから削除
- `POST /api/files/{id}/add_tags/` - タグ追加
- `POST /api/files/{id}/remove_tags/` - タグ削除
- `POST /api/files/bulk_action/` - 一括操作

### フォルダ管理

- `GET /api/folders/` - フォルダ一覧
- `GET /api/folders/tree/` - フォルダツリー
- `POST /api/folders/` - フォルダ作成
- `PUT /api/folders/{id}/` - フォルダ更新
- `DELETE /api/folders/{id}/` - フォルダ削除

### タグ管理

- `GET /api/tags/` - タグ一覧
- `GET /api/tags/popular/` - 人気タグ
- `GET /api/tags/search/?q={query}` - タグ検索
- `POST /api/tags/` - タグ作成

### グループ管理

- `GET /api/groups/` - グループ一覧
- `POST /api/groups/` - グループ作成

### システム管理

- `GET /api/force_refresh/` - 強制ファイルスキャン
- `GET /api/scan-history/` - スキャン履歴
- `GET /api/scan-history/latest/` - 最新のスキャン履歴

## 管理画面

Django管理画面: `http://localhost:8000/admin/`

インストール時に作成した管理者アカウントでログイン可能です。

## ディレクトリ構造

```
video_streaming/
├── install.bat           # インストールスクリプト
├── runserver.bat         # サーバー起動スクリプト  
├── requirements.txt      # Python依存関係
├── venv/                 # Python仮想環境
├── backend/              # Djangoプロジェクト
│   ├── manage.py
│   ├── backend/          # プロジェクト設定
│   │   ├── settings.py
│   │   ├── urls.py
│   │   ├── asgi.py
│   │   ├── wsgi.py
│   │   └── celery.py
│   └── videos/           # 動画管理アプリ
│       ├── models.py
│       ├── views.py
│       ├── serializers.py
│       ├── urls.py
│       ├── utils.py
│       ├── tasks.py
│       └── admin.py
├── media/                # メディアファイル
│   ├── videos/           # 動画ファイル
│   └── gifs/             # サムネイルGIF
└── logs/                 # ログファイル
```

## 自動処理

以下の処理が自動的に実行されます：

1. **起動時スキャン**: サーバー起動時に動画ファイルをスキャン
2. **定期スキャン**: 6時間ごとに動画ファイルをスキャン
3. **重複検出**: MD5ハッシュとファイルサイズで重複を検出
4. **GIF生成**: 動画の最初の10秒からサムネイルGIFを自動生成

## トラブルシューティング

### MySQLエラー

```
Error: Can't connect to MySQL server
```
→ MySQLサービスが起動しているか確認

### FFmpegエラー

```
Error: ffmpeg not found
```
→ FFmpegがPATHに追加されているか確認

### ポート使用中エラー

```
Error: [Errno 10048] Only one usage of each socket address
```
→ 8000番ポートが他のアプリで使用されていないか確認

## サービス化（nssm使用）

Windows サービスとして登録する場合：

```bash
# nssmをダウンロードして配置
nssm install VideoStreamingServer "C:\path\to\runserver.bat"
nssm start VideoStreamingServer
```

## 注意事項

- 本システムは自宅内での使用を想定しています
- 外部公開する場合はセキュリティ設定の見直しが必要です
- 大量の動画ファイルがある場合、初回スキャンに時間がかかります

## ライセンス

個人使用のみ
```

```requirements.txt
Django==5.0.1
djangorestframework==3.14.0
django-cors-headers==4.3.1
mysqlclient==2.2.1
daphne==4.0.0
channels==4.0.0
Pillow==10.2.0
ffmpeg-python==0.2.0
celery==5.3.4
redis==5.0.1
python-dotenv==1.0.0
watchdog==3.0.0
django-cleanup==8.0.0
imageio==2.33.1
imageio-ffmpeg==0.4.9
```

```runserver.bat

```

